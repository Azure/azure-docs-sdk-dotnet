<Type Name="TypeDefinition" FullName="Azure.Analytics.Purview.DataMap.TypeDefinition">
  <TypeSignature Language="C#" Value="public class TypeDefinition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TypeDefinition extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Analytics.Purview.DataMap.TypeDefinition" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeDefinition" />
  <TypeSignature Language="F#" Value="type TypeDefinition = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The TypeDefinition sub-client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of TypeDefinition for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BatchCreate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt; BatchCreate (Azure.Analytics.Purview.DataMap.AtlasTypesDef body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt; BatchCreate(class Azure.Analytics.Purview.DataMap.AtlasTypesDef body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchCreate(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchCreate (body As AtlasTypesDef, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasTypesDef)" />
      <MemberSignature Language="F#" Value="abstract member BatchCreate : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&#xA;override this.BatchCreate : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;" Usage="typeDefinition.BatchCreate (body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Azure.Analytics.Purview.DataMap.AtlasTypesDef" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="body"> Body parameter. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Create all atlas type definitions in bulk. Please avoid recreating existing types. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> is null. </exception>
        <example>
This sample shows how to call BatchCreate.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

AtlasTypesDef body = new AtlasTypesDef
{
    ClassificationDefs = { },
    EntityDefs = {new AtlasEntityDef
    {
        Name = "azure_sql_server_example",
        TypeVersion = "1.0",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Set,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "databases",
            TypeName = "array<azure_sql_db>",
        }},
        SuperTypes = {"azure_resource"},
    }},
    EnumDefs = { },
    RelationshipDefs = { },
    StructDefs = { },
};
Response<AtlasTypesDef> response = client.BatchCreate(body);
]]></code>
This sample shows how to call BatchCreate.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

AtlasTypesDef body = new AtlasTypesDef
{
    BusinessMetadataDefs = {new AtlasBusinessMetadataDef
    {
        Description = "",
        Name = "myBizMetadata1",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Single,
            IsIndexable = true,
            IsOptional = true,
            IsUnique = false,
            Name = "bizAttr1",
            Options =
            {
                ["maxStrLength"] = "50",
                ["applicableEntityTypes"] = "[\"Path\"]"
            },
            TypeName = "string",
        }},
    }},
    ClassificationDefs = { },
    EntityDefs = { },
    EnumDefs = { },
    RelationshipDefs = { },
    StructDefs = { },
};
Response<AtlasTypesDef> response = client.BatchCreate(body);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchCreate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response BatchCreate (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response BatchCreate(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchCreate(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchCreate (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member BatchCreate : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.BatchCreate : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.BatchCreate (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Create all atlas type definitions in bulk. Please avoid recreating existing types.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchCreate(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchCreate and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

using RequestContent content = RequestContent.Create(new
{
    enumDefs = Array.Empty<object>(),
    structDefs = Array.Empty<object>(),
    classificationDefs = Array.Empty<object>(),
    entityDefs = new object[]
    {
        new
        {
            name = "azure_sql_server_example",
            superTypes = new object[]
            {
                "azure_resource"
            },
            typeVersion = "1.0",
            attributeDefs = new object[]
            {
                new
                {
                    name = "databases",
                    typeName = "array<azure_sql_db>",
                    cardinality = "SET",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                }
            },
        }
    },
    relationshipDefs = Array.Empty<object>(),
});
Response response = client.BatchCreate(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call BatchCreate and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

using RequestContent content = RequestContent.Create(new
{
    enumDefs = Array.Empty<object>(),
    structDefs = Array.Empty<object>(),
    classificationDefs = Array.Empty<object>(),
    entityDefs = Array.Empty<object>(),
    relationshipDefs = Array.Empty<object>(),
    businessMetadataDefs = new object[]
    {
        new
        {
            name = "myBizMetadata1",
            description = "",
            attributeDefs = new object[]
            {
                new
                {
                    name = "bizAttr1",
                    typeName = "string",
                    isOptional = true,
                    cardinality = "SINGLE",
                    isUnique = false,
                    isIndexable = true,
                    options = new
                    {
                        maxStrLength = "50",
                        applicableEntityTypes = "[\"Path\"]",
                    },
                }
            },
        }
    },
});
Response response = client.BatchCreate(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchCreateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt; BatchCreateAsync (Azure.Analytics.Purview.DataMap.AtlasTypesDef body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt; BatchCreateAsync(class Azure.Analytics.Purview.DataMap.AtlasTypesDef body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchCreateAsync(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchCreateAsync (body As AtlasTypesDef, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasTypesDef))" />
      <MemberSignature Language="F#" Value="abstract member BatchCreateAsync : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;&#xA;override this.BatchCreateAsync : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;" Usage="typeDefinition.BatchCreateAsync (body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Azure.Analytics.Purview.DataMap.AtlasTypesDef" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="body"> Body parameter. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Create all atlas type definitions in bulk. Please avoid recreating existing types. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> is null. </exception>
        <example>
This sample shows how to call BatchCreateAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

AtlasTypesDef body = new AtlasTypesDef
{
    ClassificationDefs = { },
    EntityDefs = {new AtlasEntityDef
    {
        Name = "azure_sql_server_example",
        TypeVersion = "1.0",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Set,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "databases",
            TypeName = "array<azure_sql_db>",
        }},
        SuperTypes = {"azure_resource"},
    }},
    EnumDefs = { },
    RelationshipDefs = { },
    StructDefs = { },
};
Response<AtlasTypesDef> response = await client.BatchCreateAsync(body);
]]></code>
This sample shows how to call BatchCreateAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

AtlasTypesDef body = new AtlasTypesDef
{
    BusinessMetadataDefs = {new AtlasBusinessMetadataDef
    {
        Description = "",
        Name = "myBizMetadata1",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Single,
            IsIndexable = true,
            IsOptional = true,
            IsUnique = false,
            Name = "bizAttr1",
            Options =
            {
                ["maxStrLength"] = "50",
                ["applicableEntityTypes"] = "[\"Path\"]"
            },
            TypeName = "string",
        }},
    }},
    ClassificationDefs = { },
    EntityDefs = { },
    EnumDefs = { },
    RelationshipDefs = { },
    StructDefs = { },
};
Response<AtlasTypesDef> response = await client.BatchCreateAsync(body);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchCreateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; BatchCreateAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; BatchCreateAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchCreateAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchCreateAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member BatchCreateAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.BatchCreateAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.BatchCreateAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Create all atlas type definitions in bulk. Please avoid recreating existing types.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchCreateAsync(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchCreateAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

using RequestContent content = RequestContent.Create(new
{
    enumDefs = Array.Empty<object>(),
    structDefs = Array.Empty<object>(),
    classificationDefs = Array.Empty<object>(),
    entityDefs = new object[]
    {
        new
        {
            name = "azure_sql_server_example",
            superTypes = new object[]
            {
                "azure_resource"
            },
            typeVersion = "1.0",
            attributeDefs = new object[]
            {
                new
                {
                    name = "databases",
                    typeName = "array<azure_sql_db>",
                    cardinality = "SET",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                }
            },
        }
    },
    relationshipDefs = Array.Empty<object>(),
});
Response response = await client.BatchCreateAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call BatchCreateAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

using RequestContent content = RequestContent.Create(new
{
    enumDefs = Array.Empty<object>(),
    structDefs = Array.Empty<object>(),
    classificationDefs = Array.Empty<object>(),
    entityDefs = Array.Empty<object>(),
    relationshipDefs = Array.Empty<object>(),
    businessMetadataDefs = new object[]
    {
        new
        {
            name = "myBizMetadata1",
            description = "",
            attributeDefs = new object[]
            {
                new
                {
                    name = "bizAttr1",
                    typeName = "string",
                    isOptional = true,
                    cardinality = "SINGLE",
                    isUnique = false,
                    isIndexable = true,
                    options = new
                    {
                        maxStrLength = "50",
                        applicableEntityTypes = "[\"Path\"]",
                    },
                }
            },
        }
    },
});
Response response = await client.BatchCreateAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchDelete">
      <MemberSignature Language="C#" Value="public virtual Azure.Response BatchDelete (Azure.Analytics.Purview.DataMap.AtlasTypesDef body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response BatchDelete(class Azure.Analytics.Purview.DataMap.AtlasTypesDef body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchDelete(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchDelete (body As AtlasTypesDef, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member BatchDelete : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.BatchDelete : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; Azure.Response" Usage="typeDefinition.BatchDelete (body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Azure.Analytics.Purview.DataMap.AtlasTypesDef" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="body"> Body parameter. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Delete API for all types in bulk. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> is null. </exception>
        <example>
This sample shows how to call BatchDelete.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

AtlasTypesDef body = new AtlasTypesDef
{
    ClassificationDefs = { },
    EntityDefs = {new AtlasEntityDef
    {
        Name = "azure_sql_server_example",
        TypeVersion = "1.0",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Set,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "databases",
            TypeName = "array<azure_sql_db>",
        }},
        SuperTypes = {"azure_resource"},
    }},
    EnumDefs = { },
    RelationshipDefs = { },
    StructDefs = { },
};
Response response = client.BatchDelete(body);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchDelete">
      <MemberSignature Language="C#" Value="public virtual Azure.Response BatchDelete (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response BatchDelete(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchDelete(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchDelete (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member BatchDelete : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.BatchDelete : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.BatchDelete (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete API for all types in bulk.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchDelete(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchDelete.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

using RequestContent content = RequestContent.Create(new
{
    enumDefs = Array.Empty<object>(),
    structDefs = Array.Empty<object>(),
    classificationDefs = Array.Empty<object>(),
    entityDefs = new object[]
    {
        new
        {
            name = "azure_sql_server_example",
            superTypes = new object[]
            {
                "azure_resource"
            },
            typeVersion = "1.0",
            attributeDefs = new object[]
            {
                new
                {
                    name = "databases",
                    typeName = "array<azure_sql_db>",
                    cardinality = "SET",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                }
            },
        }
    },
    relationshipDefs = Array.Empty<object>(),
});
Response response = client.BatchDelete(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchDeleteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; BatchDeleteAsync (Azure.Analytics.Purview.DataMap.AtlasTypesDef body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; BatchDeleteAsync(class Azure.Analytics.Purview.DataMap.AtlasTypesDef body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchDeleteAsync(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchDeleteAsync (body As AtlasTypesDef, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member BatchDeleteAsync : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.BatchDeleteAsync : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.BatchDeleteAsync (body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Azure.Analytics.Purview.DataMap.AtlasTypesDef" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="body"> Body parameter. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Delete API for all types in bulk. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> is null. </exception>
        <example>
This sample shows how to call BatchDeleteAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

AtlasTypesDef body = new AtlasTypesDef
{
    ClassificationDefs = { },
    EntityDefs = {new AtlasEntityDef
    {
        Name = "azure_sql_server_example",
        TypeVersion = "1.0",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Set,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "databases",
            TypeName = "array<azure_sql_db>",
        }},
        SuperTypes = {"azure_resource"},
    }},
    EnumDefs = { },
    RelationshipDefs = { },
    StructDefs = { },
};
Response response = await client.BatchDeleteAsync(body);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchDeleteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; BatchDeleteAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; BatchDeleteAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchDeleteAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchDeleteAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member BatchDeleteAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.BatchDeleteAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.BatchDeleteAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete API for all types in bulk.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchDeleteAsync(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchDeleteAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

using RequestContent content = RequestContent.Create(new
{
    enumDefs = Array.Empty<object>(),
    structDefs = Array.Empty<object>(),
    classificationDefs = Array.Empty<object>(),
    entityDefs = new object[]
    {
        new
        {
            name = "azure_sql_server_example",
            superTypes = new object[]
            {
                "azure_resource"
            },
            typeVersion = "1.0",
            attributeDefs = new object[]
            {
                new
                {
                    name = "databases",
                    typeName = "array<azure_sql_db>",
                    cardinality = "SET",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                }
            },
        }
    },
    relationshipDefs = Array.Empty<object>(),
});
Response response = await client.BatchDeleteAsync(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchUpdate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt; BatchUpdate (Azure.Analytics.Purview.DataMap.AtlasTypesDef body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt; BatchUpdate(class Azure.Analytics.Purview.DataMap.AtlasTypesDef body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchUpdate(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchUpdate (body As AtlasTypesDef, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasTypesDef)" />
      <MemberSignature Language="F#" Value="abstract member BatchUpdate : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&#xA;override this.BatchUpdate : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;" Usage="typeDefinition.BatchUpdate (body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Azure.Analytics.Purview.DataMap.AtlasTypesDef" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="body"> Body parameter. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Update all types in bulk, changes detected in the type definitions would be
            persisted.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> is null. </exception>
        <example>
This sample shows how to call BatchUpdate.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

AtlasTypesDef body = new AtlasTypesDef
{
    ClassificationDefs = { },
    EntityDefs = {new AtlasEntityDef
    {
        Name = "azure_sql_server",
        TypeVersion = "1.0",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Set,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "databases",
            TypeName = "array<azure_sql_db>",
        }},
        SuperTypes = {"azure_resource"},
    }, new AtlasEntityDef
    {
        Name = "azure_sql_db",
        TypeVersion = "1.0",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Single,
            Constraints = {new AtlasConstraintDef
            {
                Params =
                {
                    ["attribute"] = BinaryData.FromObjectAsJson("databases")
                },
                Type = "inverseRef",
            }},
            IsIndexable = false,
            IsOptional = false,
            IsUnique = false,
            Name = "server",
            TypeName = "azure_sql_server",
        }, new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Set,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "schemas",
            TypeName = "array<azure_sql_schema>",
        }, new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Single,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "collation",
            TypeName = "string",
        }, new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Single,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "compatibilityLevel",
            TypeName = "int",
        }},
        SuperTypes = {"azure_resource"},
    }},
    EnumDefs = { },
    RelationshipDefs = {new AtlasRelationshipDef
    {
        Name = "azure_sql_server_databases",
        TypeVersion = "1.0",
        EndDef1 = new AtlasRelationshipEndDef
        {
            Cardinality = CardinalityValue.Set,
            IsContainer = true,
            IsLegacyAttribute = true,
            Name = "databases",
            Type = "azure_sql_server",
        },
        EndDef2 = new AtlasRelationshipEndDef
        {
            Cardinality = CardinalityValue.Single,
            IsContainer = false,
            IsLegacyAttribute = true,
            Name = "server",
            Type = "azure_sql_db",
        },
        RelationshipCategory = RelationshipCategory.Composition,
    }, new AtlasRelationshipDef
    {
        Name = "azure_sql_db_schemas",
        TypeVersion = "1.0",
        EndDef1 = new AtlasRelationshipEndDef
        {
            Cardinality = CardinalityValue.Set,
            IsContainer = true,
            IsLegacyAttribute = true,
            Name = "schemas",
            Type = "azure_sql_db",
        },
        EndDef2 = new AtlasRelationshipEndDef
        {
            Cardinality = CardinalityValue.Single,
            IsContainer = false,
            IsLegacyAttribute = true,
            Name = "db",
            Type = "azure_sql_schema",
        },
        RelationshipCategory = RelationshipCategory.Composition,
    }},
    StructDefs = { },
};
Response<AtlasTypesDef> response = client.BatchUpdate(body);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchUpdate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response BatchUpdate (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response BatchUpdate(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchUpdate(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchUpdate (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member BatchUpdate : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.BatchUpdate : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.BatchUpdate (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Update all types in bulk, changes detected in the type definitions would be
            persisted.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchUpdate(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchUpdate and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

using RequestContent content = RequestContent.Create(new
{
    enumDefs = Array.Empty<object>(),
    structDefs = Array.Empty<object>(),
    classificationDefs = Array.Empty<object>(),
    entityDefs = new object[]
    {
        new
        {
            name = "azure_sql_server",
            superTypes = new object[]
            {
                "azure_resource"
            },
            typeVersion = "1.0",
            attributeDefs = new object[]
            {
                new
                {
                    name = "databases",
                    typeName = "array<azure_sql_db>",
                    cardinality = "SET",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                }
            },
        },
        new
        {
            name = "azure_sql_db",
            superTypes = new object[]
            {
                "azure_resource"
            },
            typeVersion = "1.0",
            attributeDefs = new object[]
            {
                new
                {
                    name = "server",
                    typeName = "azure_sql_server",
                    cardinality = "SINGLE",
                    constraints = new object[]
                    {
                        new Dictionary<string, object>
                        {
                            ["type"] = "inverseRef",
                            ["params"] = new
                            {
                                attribute = "databases",
                            }
                        }
                    },
                    isIndexable = false,
                    isOptional = false,
                    isUnique = false,
                },
                new
                {
                    name = "schemas",
                    typeName = "array<azure_sql_schema>",
                    cardinality = "SET",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                },
                new
                {
                    name = "collation",
                    typeName = "string",
                    cardinality = "SINGLE",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                },
                new
                {
                    name = "compatibilityLevel",
                    typeName = "int",
                    cardinality = "SINGLE",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                }
            },
        }
    },
    relationshipDefs = new object[]
    {
        new
        {
            name = "azure_sql_server_databases",
            typeVersion = "1.0",
            relationshipCategory = "COMPOSITION",
            endDef1 = new
            {
                type = "azure_sql_server",
                name = "databases",
                isContainer = true,
                cardinality = "SET",
                isLegacyAttribute = true,
            },
            endDef2 = new
            {
                type = "azure_sql_db",
                name = "server",
                isContainer = false,
                cardinality = "SINGLE",
                isLegacyAttribute = true,
            },
        },
        new
        {
            name = "azure_sql_db_schemas",
            typeVersion = "1.0",
            relationshipCategory = "COMPOSITION",
            endDef1 = new
            {
                type = "azure_sql_db",
                name = "schemas",
                isContainer = true,
                cardinality = "SET",
                isLegacyAttribute = true,
            },
            endDef2 = new
            {
                type = "azure_sql_schema",
                name = "db",
                isContainer = false,
                cardinality = "SINGLE",
                isLegacyAttribute = true,
            },
        }
    },
});
Response response = client.BatchUpdate(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchUpdateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt; BatchUpdateAsync (Azure.Analytics.Purview.DataMap.AtlasTypesDef body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt; BatchUpdateAsync(class Azure.Analytics.Purview.DataMap.AtlasTypesDef body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchUpdateAsync(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchUpdateAsync (body As AtlasTypesDef, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasTypesDef))" />
      <MemberSignature Language="F#" Value="abstract member BatchUpdateAsync : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;&#xA;override this.BatchUpdateAsync : Azure.Analytics.Purview.DataMap.AtlasTypesDef * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;" Usage="typeDefinition.BatchUpdateAsync (body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Azure.Analytics.Purview.DataMap.AtlasTypesDef" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="body"> Body parameter. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Update all types in bulk, changes detected in the type definitions would be
            persisted.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> is null. </exception>
        <example>
This sample shows how to call BatchUpdateAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

AtlasTypesDef body = new AtlasTypesDef
{
    ClassificationDefs = { },
    EntityDefs = {new AtlasEntityDef
    {
        Name = "azure_sql_server",
        TypeVersion = "1.0",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Set,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "databases",
            TypeName = "array<azure_sql_db>",
        }},
        SuperTypes = {"azure_resource"},
    }, new AtlasEntityDef
    {
        Name = "azure_sql_db",
        TypeVersion = "1.0",
        AttributeDefs = {new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Single,
            Constraints = {new AtlasConstraintDef
            {
                Params =
                {
                    ["attribute"] = BinaryData.FromObjectAsJson("databases")
                },
                Type = "inverseRef",
            }},
            IsIndexable = false,
            IsOptional = false,
            IsUnique = false,
            Name = "server",
            TypeName = "azure_sql_server",
        }, new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Set,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "schemas",
            TypeName = "array<azure_sql_schema>",
        }, new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Single,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "collation",
            TypeName = "string",
        }, new AtlasAttributeDef
        {
            Cardinality = CardinalityValue.Single,
            IsIndexable = false,
            IsOptional = true,
            IsUnique = false,
            Name = "compatibilityLevel",
            TypeName = "int",
        }},
        SuperTypes = {"azure_resource"},
    }},
    EnumDefs = { },
    RelationshipDefs = {new AtlasRelationshipDef
    {
        Name = "azure_sql_server_databases",
        TypeVersion = "1.0",
        EndDef1 = new AtlasRelationshipEndDef
        {
            Cardinality = CardinalityValue.Set,
            IsContainer = true,
            IsLegacyAttribute = true,
            Name = "databases",
            Type = "azure_sql_server",
        },
        EndDef2 = new AtlasRelationshipEndDef
        {
            Cardinality = CardinalityValue.Single,
            IsContainer = false,
            IsLegacyAttribute = true,
            Name = "server",
            Type = "azure_sql_db",
        },
        RelationshipCategory = RelationshipCategory.Composition,
    }, new AtlasRelationshipDef
    {
        Name = "azure_sql_db_schemas",
        TypeVersion = "1.0",
        EndDef1 = new AtlasRelationshipEndDef
        {
            Cardinality = CardinalityValue.Set,
            IsContainer = true,
            IsLegacyAttribute = true,
            Name = "schemas",
            Type = "azure_sql_db",
        },
        EndDef2 = new AtlasRelationshipEndDef
        {
            Cardinality = CardinalityValue.Single,
            IsContainer = false,
            IsLegacyAttribute = true,
            Name = "db",
            Type = "azure_sql_schema",
        },
        RelationshipCategory = RelationshipCategory.Composition,
    }},
    StructDefs = { },
};
Response<AtlasTypesDef> response = await client.BatchUpdateAsync(body);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchUpdateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; BatchUpdateAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; BatchUpdateAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchUpdateAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchUpdateAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member BatchUpdateAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.BatchUpdateAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.BatchUpdateAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Update all types in bulk, changes detected in the type definitions would be
            persisted.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.BatchUpdateAsync(Azure.Analytics.Purview.DataMap.AtlasTypesDef,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchUpdateAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

using RequestContent content = RequestContent.Create(new
{
    enumDefs = Array.Empty<object>(),
    structDefs = Array.Empty<object>(),
    classificationDefs = Array.Empty<object>(),
    entityDefs = new object[]
    {
        new
        {
            name = "azure_sql_server",
            superTypes = new object[]
            {
                "azure_resource"
            },
            typeVersion = "1.0",
            attributeDefs = new object[]
            {
                new
                {
                    name = "databases",
                    typeName = "array<azure_sql_db>",
                    cardinality = "SET",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                }
            },
        },
        new
        {
            name = "azure_sql_db",
            superTypes = new object[]
            {
                "azure_resource"
            },
            typeVersion = "1.0",
            attributeDefs = new object[]
            {
                new
                {
                    name = "server",
                    typeName = "azure_sql_server",
                    cardinality = "SINGLE",
                    constraints = new object[]
                    {
                        new Dictionary<string, object>
                        {
                            ["type"] = "inverseRef",
                            ["params"] = new
                            {
                                attribute = "databases",
                            }
                        }
                    },
                    isIndexable = false,
                    isOptional = false,
                    isUnique = false,
                },
                new
                {
                    name = "schemas",
                    typeName = "array<azure_sql_schema>",
                    cardinality = "SET",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                },
                new
                {
                    name = "collation",
                    typeName = "string",
                    cardinality = "SINGLE",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                },
                new
                {
                    name = "compatibilityLevel",
                    typeName = "int",
                    cardinality = "SINGLE",
                    isIndexable = false,
                    isOptional = true,
                    isUnique = false,
                }
            },
        }
    },
    relationshipDefs = new object[]
    {
        new
        {
            name = "azure_sql_server_databases",
            typeVersion = "1.0",
            relationshipCategory = "COMPOSITION",
            endDef1 = new
            {
                type = "azure_sql_server",
                name = "databases",
                isContainer = true,
                cardinality = "SET",
                isLegacyAttribute = true,
            },
            endDef2 = new
            {
                type = "azure_sql_db",
                name = "server",
                isContainer = false,
                cardinality = "SINGLE",
                isLegacyAttribute = true,
            },
        },
        new
        {
            name = "azure_sql_db_schemas",
            typeVersion = "1.0",
            relationshipCategory = "COMPOSITION",
            endDef1 = new
            {
                type = "azure_sql_db",
                name = "schemas",
                isContainer = true,
                cardinality = "SET",
                isLegacyAttribute = true,
            },
            endDef2 = new
            {
                type = "azure_sql_schema",
                name = "db",
                isContainer = false,
                cardinality = "SINGLE",
                isLegacyAttribute = true,
            },
        }
    },
});
Response response = await client.BatchUpdateAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public virtual Azure.Response Delete (string name, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response Delete(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.Delete(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Delete (name As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member Delete : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.Delete : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.Delete (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the type. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete API for type identified by its name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call Delete.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.Delete("hive_order");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteAsync (string name, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.DeleteAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteAsync (name As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.DeleteAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the type. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete API for type identified by its name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.DeleteAsync("hive_order");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetBusinessMetadataById (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetBusinessMetadataById(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataById(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataById (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataById : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetBusinessMetadataById : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetBusinessMetadataById (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> businessMetadata guid. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the businessMetadata definition for the given guid.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataById(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetBusinessMetadataById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetBusinessMetadataById("d8757510-c866-61ba-486f-1afca09f43b8", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt; GetBusinessMetadataById (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt; GetBusinessMetadataById(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataById(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataById (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasBusinessMetadataDef)" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&#xA;override this.GetBusinessMetadataById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;" Usage="typeDefinition.GetBusinessMetadataById (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> businessMetadata guid. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the businessMetadata definition for the given guid. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetBusinessMetadataById.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasBusinessMetadataDef> response = client.GetBusinessMetadataById("d8757510-c866-61ba-486f-1afca09f43b8");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetBusinessMetadataByIdAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetBusinessMetadataByIdAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByIdAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataByIdAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetBusinessMetadataByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetBusinessMetadataByIdAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> businessMetadata guid. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the businessMetadata definition for the given guid.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByIdAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetBusinessMetadataByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetBusinessMetadataByIdAsync("d8757510-c866-61ba-486f-1afca09f43b8", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt; GetBusinessMetadataByIdAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt; GetBusinessMetadataByIdAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByIdAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataByIdAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasBusinessMetadataDef))" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt;&#xA;override this.GetBusinessMetadataByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt;" Usage="typeDefinition.GetBusinessMetadataByIdAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> businessMetadata guid. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the businessMetadata definition for the given guid. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetBusinessMetadataByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasBusinessMetadataDef> response = await client.GetBusinessMetadataByIdAsync("d8757510-c866-61ba-486f-1afca09f43b8");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetBusinessMetadataByName (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetBusinessMetadataByName(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByName(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataByName (name As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataByName : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetBusinessMetadataByName : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetBusinessMetadataByName (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> businessMetadata name. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the businessMetadata definition by it's name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByName(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetBusinessMetadataByName and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetBusinessMetadataByName("Business_Metadata_Type_Name", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt; GetBusinessMetadataByName (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt; GetBusinessMetadataByName(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByName(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataByName (name As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasBusinessMetadataDef)" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&#xA;override this.GetBusinessMetadataByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;" Usage="typeDefinition.GetBusinessMetadataByName (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> businessMetadata name. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the businessMetadata definition by it's name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetBusinessMetadataByName.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasBusinessMetadataDef> response = client.GetBusinessMetadataByName("Business_Metadata_Type_Name");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetBusinessMetadataByNameAsync (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetBusinessMetadataByNameAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByNameAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataByNameAsync (name As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetBusinessMetadataByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetBusinessMetadataByNameAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> businessMetadata name. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the businessMetadata definition by it's name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByNameAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetBusinessMetadataByNameAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetBusinessMetadataByNameAsync("Business_Metadata_Type_Name", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt; GetBusinessMetadataByNameAsync (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt; GetBusinessMetadataByNameAsync(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetBusinessMetadataByNameAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataByNameAsync (name As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasBusinessMetadataDef))" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt;&#xA;override this.GetBusinessMetadataByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt;" Usage="typeDefinition.GetBusinessMetadataByNameAsync (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasBusinessMetadataDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> businessMetadata name. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the businessMetadata definition by it's name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetBusinessMetadataByNameAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasBusinessMetadataDef> response = await client.GetBusinessMetadataByNameAsync("Business_Metadata_Type_Name");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetById (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetById(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetById(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetById (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetById : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetById : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetById (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the type. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the type definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetById(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetById("0ddc2fcf-ad17-4d06-984a-ffb2ffb2a941", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt; GetById (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt; GetById(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetById(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetById (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasTypeDef)" />
      <MemberSignature Language="F#" Value="abstract member GetById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&#xA;override this.GetById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;" Usage="typeDefinition.GetById (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the type. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the type definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetById.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasTypeDef> response = client.GetById("0ddc2fcf-ad17-4d06-984a-ffb2ffb2a941");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetByIdAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetByIdAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByIdAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIdAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetByIdAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the type. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the type definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByIdAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetByIdAsync("0ddc2fcf-ad17-4d06-984a-ffb2ffb2a941", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt; GetByIdAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt; GetByIdAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByIdAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIdAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasTypeDef))" />
      <MemberSignature Language="F#" Value="abstract member GetByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt;&#xA;override this.GetByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt;" Usage="typeDefinition.GetByIdAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the type. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the type definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasTypeDef> response = await client.GetByIdAsync("0ddc2fcf-ad17-4d06-984a-ffb2ffb2a941");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetByName (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetByName(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByName(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByName (name As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetByName : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetByName : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetByName (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the type. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the type definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByName(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByName and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetByName("glossary_term_status_value", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt; GetByName (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt; GetByName(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByName(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByName (name As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasTypeDef)" />
      <MemberSignature Language="F#" Value="abstract member GetByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&#xA;override this.GetByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;" Usage="typeDefinition.GetByName (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the type. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the type definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetByName.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasTypeDef> response = client.GetByName("glossary_term_status_value");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetByNameAsync (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetByNameAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByNameAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByNameAsync (name As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetByNameAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the type. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the type definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByNameAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByNameAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetByNameAsync("glossary_term_status_value", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt; GetByNameAsync (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt; GetByNameAsync(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetByNameAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByNameAsync (name As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasTypeDef))" />
      <MemberSignature Language="F#" Value="abstract member GetByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt;&#xA;override this.GetByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt;" Usage="typeDefinition.GetByNameAsync (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the type. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the type definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetByNameAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasTypeDef> response = await client.GetByNameAsync("glossary_term_status_value");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetClassificationById (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetClassificationById(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationById(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationById (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationById : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetClassificationById : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetClassificationById (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the classification. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the classification definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationById(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetClassificationById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetClassificationById("e79878fa-adba-4ee5-adc5-328d8841cd49", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt; GetClassificationById (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt; GetClassificationById(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationById(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationById (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasClassificationDef)" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&#xA;override this.GetClassificationById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;" Usage="typeDefinition.GetClassificationById (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the classification. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the classification definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetClassificationById.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasClassificationDef> response = client.GetClassificationById("e79878fa-adba-4ee5-adc5-328d8841cd49");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetClassificationByIdAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetClassificationByIdAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByIdAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationByIdAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetClassificationByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetClassificationByIdAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the classification. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the classification definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByIdAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetClassificationByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetClassificationByIdAsync("e79878fa-adba-4ee5-adc5-328d8841cd49", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt; GetClassificationByIdAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt; GetClassificationByIdAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByIdAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationByIdAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasClassificationDef))" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt;&#xA;override this.GetClassificationByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt;" Usage="typeDefinition.GetClassificationByIdAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the classification. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the classification definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetClassificationByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasClassificationDef> response = await client.GetClassificationByIdAsync("e79878fa-adba-4ee5-adc5-328d8841cd49");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetClassificationByName (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetClassificationByName(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByName(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationByName (name As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationByName : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetClassificationByName : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetClassificationByName (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the classification. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the classification definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByName(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetClassificationByName and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetClassificationByName("MICROSOFT.GOVERNMENT.CANADA.SOCIAL_INSURANCE_NUMBER", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt; GetClassificationByName (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt; GetClassificationByName(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByName(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationByName (name As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasClassificationDef)" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&#xA;override this.GetClassificationByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;" Usage="typeDefinition.GetClassificationByName (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the classification. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the classification definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetClassificationByName.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasClassificationDef> response = client.GetClassificationByName("MICROSOFT.GOVERNMENT.CANADA.SOCIAL_INSURANCE_NUMBER");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetClassificationByNameAsync (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetClassificationByNameAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByNameAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationByNameAsync (name As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetClassificationByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetClassificationByNameAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the classification. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the classification definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByNameAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetClassificationByNameAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetClassificationByNameAsync("MICROSOFT.GOVERNMENT.CANADA.SOCIAL_INSURANCE_NUMBER", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt; GetClassificationByNameAsync (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt; GetClassificationByNameAsync(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetClassificationByNameAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationByNameAsync (name As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasClassificationDef))" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt;&#xA;override this.GetClassificationByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt;" Usage="typeDefinition.GetClassificationByNameAsync (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassificationDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the classification. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the classification definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetClassificationByNameAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasClassificationDef> response = await client.GetClassificationByNameAsync("MICROSOFT.GOVERNMENT.CANADA.SOCIAL_INSURANCE_NUMBER");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetEntityById (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetEntityById(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityById(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityById (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetEntityById : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetEntityById : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetEntityById (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the Entity definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityById(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEntityById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetEntityById("4bc54c37-98a8-4de8-9ee8-182610859d43", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt; GetEntityById (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt; GetEntityById(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityById(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityById (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEntityDef)" />
      <MemberSignature Language="F#" Value="abstract member GetEntityById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&#xA;override this.GetEntityById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;" Usage="typeDefinition.GetEntityById (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the Entity definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEntityById.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasEntityDef> response = client.GetEntityById("4bc54c37-98a8-4de8-9ee8-182610859d43");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetEntityByIdAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetEntityByIdAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByIdAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityByIdAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetEntityByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetEntityByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetEntityByIdAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the Entity definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByIdAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEntityByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetEntityByIdAsync("4bc54c37-98a8-4de8-9ee8-182610859d43", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt; GetEntityByIdAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt; GetEntityByIdAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByIdAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityByIdAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEntityDef))" />
      <MemberSignature Language="F#" Value="abstract member GetEntityByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt;&#xA;override this.GetEntityByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt;" Usage="typeDefinition.GetEntityByIdAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the Entity definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEntityByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasEntityDef> response = await client.GetEntityByIdAsync("4bc54c37-98a8-4de8-9ee8-182610859d43");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetEntityByName (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetEntityByName(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByName(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityByName (name As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetEntityByName : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetEntityByName : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetEntityByName (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the entity definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByName(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEntityByName and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetEntityByName("DataSet", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt; GetEntityByName (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt; GetEntityByName(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByName(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityByName (name As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEntityDef)" />
      <MemberSignature Language="F#" Value="abstract member GetEntityByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&#xA;override this.GetEntityByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;" Usage="typeDefinition.GetEntityByName (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the entity definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEntityByName.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasEntityDef> response = client.GetEntityByName("DataSet");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetEntityByNameAsync (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetEntityByNameAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByNameAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityByNameAsync (name As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetEntityByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetEntityByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetEntityByNameAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the entity definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByNameAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEntityByNameAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetEntityByNameAsync("DataSet", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt; GetEntityByNameAsync (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt; GetEntityByNameAsync(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEntityByNameAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityByNameAsync (name As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEntityDef))" />
      <MemberSignature Language="F#" Value="abstract member GetEntityByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt;&#xA;override this.GetEntityByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt;" Usage="typeDefinition.GetEntityByNameAsync (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the entity definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEntityByNameAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasEntityDef> response = await client.GetEntityByNameAsync("DataSet");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnumById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetEnumById (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetEnumById(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumById(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumById (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetEnumById : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetEnumById : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetEnumById (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the enum. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the enum definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumById(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEnumById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetEnumById("644ab9c7-893a-4a4d-8e0a-591a6556d1a0", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnumById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt; GetEnumById (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt; GetEnumById(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumById(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumById (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEnumDef)" />
      <MemberSignature Language="F#" Value="abstract member GetEnumById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&#xA;override this.GetEnumById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;" Usage="typeDefinition.GetEnumById (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the enum. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the enum definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEnumById.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasEnumDef> response = client.GetEnumById("644ab9c7-893a-4a4d-8e0a-591a6556d1a0");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnumByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetEnumByIdAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetEnumByIdAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByIdAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumByIdAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetEnumByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetEnumByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetEnumByIdAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the enum. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the enum definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByIdAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEnumByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetEnumByIdAsync("644ab9c7-893a-4a4d-8e0a-591a6556d1a0", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnumByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt; GetEnumByIdAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt; GetEnumByIdAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByIdAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumByIdAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEnumDef))" />
      <MemberSignature Language="F#" Value="abstract member GetEnumByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt;&#xA;override this.GetEnumByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt;" Usage="typeDefinition.GetEnumByIdAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the enum. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the enum definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEnumByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasEnumDef> response = await client.GetEnumByIdAsync("644ab9c7-893a-4a4d-8e0a-591a6556d1a0");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnumByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetEnumByName (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetEnumByName(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByName(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumByName (name As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetEnumByName : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetEnumByName : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetEnumByName (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the enum. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the enum definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByName(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEnumByName and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetEnumByName("hive_principal_type", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnumByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt; GetEnumByName (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt; GetEnumByName(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByName(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumByName (name As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEnumDef)" />
      <MemberSignature Language="F#" Value="abstract member GetEnumByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&#xA;override this.GetEnumByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;" Usage="typeDefinition.GetEnumByName (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the enum. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the enum definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEnumByName.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasEnumDef> response = client.GetEnumByName("hive_principal_type");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnumByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetEnumByNameAsync (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetEnumByNameAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByNameAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumByNameAsync (name As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetEnumByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetEnumByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetEnumByNameAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the enum. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the enum definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByNameAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEnumByNameAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetEnumByNameAsync("hive_principal_type", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnumByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt; GetEnumByNameAsync (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt; GetEnumByNameAsync(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetEnumByNameAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumByNameAsync (name As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEnumDef))" />
      <MemberSignature Language="F#" Value="abstract member GetEnumByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt;&#xA;override this.GetEnumByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt;" Usage="typeDefinition.GetEnumByNameAsync (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEnumDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the enum. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the enum definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEnumByNameAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasEnumDef> response = await client.GetEnumByNameAsync("hive_principal_type");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetHeaders">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt; GetHeaders (bool? includeTermTemplate = default, Azure.Analytics.Purview.DataMap.TypeCategory? type = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class System.Collections.Generic.IReadOnlyList`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt; GetHeaders(valuetype System.Nullable`1&lt;bool&gt; includeTermTemplate, valuetype System.Nullable`1&lt;valuetype Azure.Analytics.Purview.DataMap.TypeCategory&gt; type, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetHeaders(System.Nullable{System.Boolean},System.Nullable{Azure.Analytics.Purview.DataMap.TypeCategory},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHeaders (Optional includeTermTemplate As Nullable(Of Boolean) = Nothing, Optional type As Nullable(Of TypeCategory) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of IReadOnlyList(Of AtlasTypeDefHeader))" />
      <MemberSignature Language="F#" Value="abstract member GetHeaders : Nullable&lt;bool&gt; * Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt;&#xA;override this.GetHeaders : Nullable&lt;bool&gt; * Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt;" Usage="typeDefinition.GetHeaders (includeTermTemplate, type, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeTermTemplate" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="type" Type="System.Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="includeTermTemplate">
            Whether include termtemplatedef when return all typedefs.
            This is always true
            when search filter type=term_template
            </param>
        <param name="type"> Typedef name as search filter when get typedefs. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List all type definitions returned as a list of minimal information header. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetHeaders.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<IReadOnlyList<AtlasTypeDefHeader>> response = client.GetHeaders();
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetHeaders">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetHeaders (bool? includeTermTemplate, string type, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetHeaders(valuetype System.Nullable`1&lt;bool&gt; includeTermTemplate, string type, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetHeaders(System.Nullable{System.Boolean},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHeaders (includeTermTemplate As Nullable(Of Boolean), type As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetHeaders : Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetHeaders : Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetHeaders (includeTermTemplate, type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeTermTemplate" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="includeTermTemplate">
            Whether include termtemplatedef when return all typedefs.
            This is always true
            when search filter type=term_template
            </param>
        <param name="type"> Typedef name as search filter when get typedefs. Allowed values: "PRIMITIVE" | "OBJECT_ID_TYPE" | "ENUM" | "STRUCT" | "CLASSIFICATION" | "ENTITY" | "ARRAY" | "MAP" | "RELATIONSHIP" | "TERM_TEMPLATE". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List all type definitions returned as a list of minimal information header.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetHeaders(System.Nullable{System.Boolean},System.Nullable{Azure.Analytics.Purview.DataMap.TypeCategory},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetHeaders and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetHeaders(true, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetHeadersAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt;&gt; GetHeadersAsync (bool? includeTermTemplate = default, Azure.Analytics.Purview.DataMap.TypeCategory? type = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class System.Collections.Generic.IReadOnlyList`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt;&gt; GetHeadersAsync(valuetype System.Nullable`1&lt;bool&gt; includeTermTemplate, valuetype System.Nullable`1&lt;valuetype Azure.Analytics.Purview.DataMap.TypeCategory&gt; type, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetHeadersAsync(System.Nullable{System.Boolean},System.Nullable{Azure.Analytics.Purview.DataMap.TypeCategory},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHeadersAsync (Optional includeTermTemplate As Nullable(Of Boolean) = Nothing, Optional type As Nullable(Of TypeCategory) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of IReadOnlyList(Of AtlasTypeDefHeader)))" />
      <MemberSignature Language="F#" Value="abstract member GetHeadersAsync : Nullable&lt;bool&gt; * Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt;&gt;&#xA;override this.GetHeadersAsync : Nullable&lt;bool&gt; * Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt;&gt;" Usage="typeDefinition.GetHeadersAsync (includeTermTemplate, type, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;Azure.Analytics.Purview.DataMap.AtlasTypeDefHeader&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeTermTemplate" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="type" Type="System.Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="includeTermTemplate">
            Whether include termtemplatedef when return all typedefs.
            This is always true
            when search filter type=term_template
            </param>
        <param name="type"> Typedef name as search filter when get typedefs. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List all type definitions returned as a list of minimal information header. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetHeadersAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<IReadOnlyList<AtlasTypeDefHeader>> response = await client.GetHeadersAsync();
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetHeadersAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetHeadersAsync (bool? includeTermTemplate, string type, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetHeadersAsync(valuetype System.Nullable`1&lt;bool&gt; includeTermTemplate, string type, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetHeadersAsync(System.Nullable{System.Boolean},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHeadersAsync (includeTermTemplate As Nullable(Of Boolean), type As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetHeadersAsync : Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetHeadersAsync : Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetHeadersAsync (includeTermTemplate, type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeTermTemplate" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="includeTermTemplate">
            Whether include termtemplatedef when return all typedefs.
            This is always true
            when search filter type=term_template
            </param>
        <param name="type"> Typedef name as search filter when get typedefs. Allowed values: "PRIMITIVE" | "OBJECT_ID_TYPE" | "ENUM" | "STRUCT" | "CLASSIFICATION" | "ENTITY" | "ARRAY" | "MAP" | "RELATIONSHIP" | "TERM_TEMPLATE". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List all type definitions returned as a list of minimal information header.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetHeadersAsync(System.Nullable{System.Boolean},System.Nullable{Azure.Analytics.Purview.DataMap.TypeCategory},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetHeadersAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetHeadersAsync(true, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetRelationshipById (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetRelationshipById(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipById(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelationshipById (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetRelationshipById : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetRelationshipById : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetRelationshipById (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the relationship. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the relationship definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipById(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetRelationshipById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetRelationshipById("695edde1-2782-4a3c-841b-0b3aba25fe45", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt; GetRelationshipById (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt; GetRelationshipById(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipById(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelationshipById (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasRelationshipDef)" />
      <MemberSignature Language="F#" Value="abstract member GetRelationshipById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&#xA;override this.GetRelationshipById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;" Usage="typeDefinition.GetRelationshipById (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the relationship. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the relationship definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetRelationshipById.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasRelationshipDef> response = client.GetRelationshipById("695edde1-2782-4a3c-841b-0b3aba25fe45");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetRelationshipByIdAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetRelationshipByIdAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByIdAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelationshipByIdAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetRelationshipByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetRelationshipByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetRelationshipByIdAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the relationship. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the relationship definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByIdAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetRelationshipByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetRelationshipByIdAsync("695edde1-2782-4a3c-841b-0b3aba25fe45", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt; GetRelationshipByIdAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt; GetRelationshipByIdAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByIdAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelationshipByIdAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasRelationshipDef))" />
      <MemberSignature Language="F#" Value="abstract member GetRelationshipByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt;&#xA;override this.GetRelationshipByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt;" Usage="typeDefinition.GetRelationshipByIdAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the relationship. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the relationship definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetRelationshipByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasRelationshipDef> response = await client.GetRelationshipByIdAsync("695edde1-2782-4a3c-841b-0b3aba25fe45");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetRelationshipByName (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetRelationshipByName(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByName(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelationshipByName (name As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetRelationshipByName : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetRelationshipByName : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetRelationshipByName (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the relationship. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the relationship definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByName(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetRelationshipByName and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetRelationshipByName("storm_topology_nodes", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt; GetRelationshipByName (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt; GetRelationshipByName(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByName(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelationshipByName (name As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasRelationshipDef)" />
      <MemberSignature Language="F#" Value="abstract member GetRelationshipByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&#xA;override this.GetRelationshipByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;" Usage="typeDefinition.GetRelationshipByName (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the relationship. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the relationship definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetRelationshipByName.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasRelationshipDef> response = client.GetRelationshipByName("storm_topology_nodes");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetRelationshipByNameAsync (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetRelationshipByNameAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByNameAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelationshipByNameAsync (name As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetRelationshipByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetRelationshipByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetRelationshipByNameAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the relationship. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the relationship definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByNameAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetRelationshipByNameAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetRelationshipByNameAsync("storm_topology_nodes", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt; GetRelationshipByNameAsync (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt; GetRelationshipByNameAsync(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetRelationshipByNameAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelationshipByNameAsync (name As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasRelationshipDef))" />
      <MemberSignature Language="F#" Value="abstract member GetRelationshipByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt;&#xA;override this.GetRelationshipByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt;" Usage="typeDefinition.GetRelationshipByNameAsync (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasRelationshipDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the relationship. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the relationship definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetRelationshipByNameAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasRelationshipDef> response = await client.GetRelationshipByNameAsync("storm_topology_nodes");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetStructById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetStructById (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetStructById(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructById(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStructById (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetStructById : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetStructById : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetStructById (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the struct. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the struct definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructById(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetStructById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetStructById("f1571b6e-ad08-4040-a9a7-c30ed935d437", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetStructById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt; GetStructById (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasStructDef&gt; GetStructById(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructById(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStructById (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasStructDef)" />
      <MemberSignature Language="F#" Value="abstract member GetStructById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&#xA;override this.GetStructById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;" Usage="typeDefinition.GetStructById (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the struct. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the struct definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetStructById.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasStructDef> response = client.GetStructById("f1571b6e-ad08-4040-a9a7-c30ed935d437");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetStructByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetStructByIdAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetStructByIdAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByIdAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStructByIdAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetStructByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetStructByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetStructByIdAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the struct. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the struct definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByIdAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetStructByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetStructByIdAsync("f1571b6e-ad08-4040-a9a7-c30ed935d437", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetStructByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt; GetStructByIdAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt; GetStructByIdAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByIdAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStructByIdAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasStructDef))" />
      <MemberSignature Language="F#" Value="abstract member GetStructByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt;&#xA;override this.GetStructByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt;" Usage="typeDefinition.GetStructByIdAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the struct. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the struct definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetStructByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasStructDef> response = await client.GetStructByIdAsync("f1571b6e-ad08-4040-a9a7-c30ed935d437");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetStructByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetStructByName (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetStructByName(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByName(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStructByName (name As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetStructByName : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetStructByName : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetStructByName (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the struct. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the struct definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByName(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetStructByName and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = client.GetStructByName("hive_order", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetStructByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt; GetStructByName (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasStructDef&gt; GetStructByName(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByName(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStructByName (name As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasStructDef)" />
      <MemberSignature Language="F#" Value="abstract member GetStructByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&#xA;override this.GetStructByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;" Usage="typeDefinition.GetStructByName (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the struct. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the struct definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetStructByName.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasStructDef> response = client.GetStructByName("hive_order");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetStructByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetStructByNameAsync (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetStructByNameAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByNameAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStructByNameAsync (name As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetStructByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetStructByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetStructByNameAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the struct. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the struct definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByNameAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetStructByNameAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response response = await client.GetStructByNameAsync("hive_order", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetStructByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt; GetStructByNameAsync (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt; GetStructByNameAsync(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetStructByNameAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStructByNameAsync (name As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasStructDef))" />
      <MemberSignature Language="F#" Value="abstract member GetStructByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt;&#xA;override this.GetStructByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt;" Usage="typeDefinition.GetStructByNameAsync (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasStructDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The name of the struct. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the struct definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetStructByNameAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient();

Response<AtlasStructDef> response = await client.GetStructByNameAsync("hive_order");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTermTemplateById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTermTemplateById (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTermTemplateById(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateById(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTermTemplateById (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTermTemplateById : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTermTemplateById : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetTermTemplateById (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the term template. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the term template definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateById(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTermTemplateById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = client.GetTermTemplateById("d776af9c-985c-4168-abb2-477523dbfc70", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTermTemplateById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt; GetTermTemplateById (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.TermTemplateDef&gt; GetTermTemplateById(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateById(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTermTemplateById (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of TermTemplateDef)" />
      <MemberSignature Language="F#" Value="abstract member GetTermTemplateById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&#xA;override this.GetTermTemplateById : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;" Usage="typeDefinition.GetTermTemplateById (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the term template. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the term template definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTermTemplateById.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<TermTemplateDef> response = client.GetTermTemplateById("d776af9c-985c-4168-abb2-477523dbfc70");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTermTemplateByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTermTemplateByIdAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTermTemplateByIdAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByIdAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTermTemplateByIdAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTermTemplateByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTermTemplateByIdAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetTermTemplateByIdAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the term template. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the term template definition for the given GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByIdAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTermTemplateByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = await client.GetTermTemplateByIdAsync("d776af9c-985c-4168-abb2-477523dbfc70", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTermTemplateByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt; GetTermTemplateByIdAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt; GetTermTemplateByIdAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByIdAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTermTemplateByIdAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of TermTemplateDef))" />
      <MemberSignature Language="F#" Value="abstract member GetTermTemplateByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt;&#xA;override this.GetTermTemplateByIdAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt;" Usage="typeDefinition.GetTermTemplateByIdAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the term template. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the term template definition for the given GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTermTemplateByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<TermTemplateDef> response = await client.GetTermTemplateByIdAsync("d776af9c-985c-4168-abb2-477523dbfc70");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTermTemplateByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTermTemplateByName (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTermTemplateByName(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByName(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTermTemplateByName (name As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTermTemplateByName : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTermTemplateByName : string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetTermTemplateByName (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The unique name of the term template. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the term template definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByName(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTermTemplateByName and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = client.GetTermTemplateByName("MS KPI", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTermTemplateByName">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt; GetTermTemplateByName (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.TermTemplateDef&gt; GetTermTemplateByName(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByName(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTermTemplateByName (name As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of TermTemplateDef)" />
      <MemberSignature Language="F#" Value="abstract member GetTermTemplateByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&#xA;override this.GetTermTemplateByName : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;" Usage="typeDefinition.GetTermTemplateByName (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The unique name of the term template. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the term template definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTermTemplateByName.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<TermTemplateDef> response = client.GetTermTemplateByName("MS KPI");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTermTemplateByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTermTemplateByNameAsync (string name, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTermTemplateByNameAsync(string name, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByNameAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTermTemplateByNameAsync (name As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTermTemplateByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTermTemplateByNameAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetTermTemplateByNameAsync (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="name"> The unique name of the term template. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the term template definition by its name (unique).
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByNameAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTermTemplateByNameAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = await client.GetTermTemplateByNameAsync("MS KPI", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTermTemplateByNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt; GetTermTemplateByNameAsync (string name, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt; GetTermTemplateByNameAsync(string name, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTermTemplateByNameAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTermTemplateByNameAsync (name As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of TermTemplateDef))" />
      <MemberSignature Language="F#" Value="abstract member GetTermTemplateByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt;&#xA;override this.GetTermTemplateByNameAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt;" Usage="typeDefinition.GetTermTemplateByNameAsync (name, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.TermTemplateDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name"> The unique name of the term template. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the term template definition by its name (unique). </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTermTemplateByNameAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<TermTemplateDef> response = await client.GetTermTemplateByNameAsync("MS KPI");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt; GetTypeDefinition (bool? includeTermTemplate = default, Azure.Analytics.Purview.DataMap.TypeCategory? type = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt; GetTypeDefinition(valuetype System.Nullable`1&lt;bool&gt; includeTermTemplate, valuetype System.Nullable`1&lt;valuetype Azure.Analytics.Purview.DataMap.TypeCategory&gt; type, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTypeDefinition(System.Nullable{System.Boolean},System.Nullable{Azure.Analytics.Purview.DataMap.TypeCategory},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeDefinition (Optional includeTermTemplate As Nullable(Of Boolean) = Nothing, Optional type As Nullable(Of TypeCategory) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasTypesDef)" />
      <MemberSignature Language="F#" Value="abstract member GetTypeDefinition : Nullable&lt;bool&gt; * Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&#xA;override this.GetTypeDefinition : Nullable&lt;bool&gt; * Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;" Usage="typeDefinition.GetTypeDefinition (includeTermTemplate, type, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeTermTemplate" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="type" Type="System.Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="includeTermTemplate">
            Whether include termtemplatedef when return all typedefs.
            This is always true
            when search filter type=term_template
            </param>
        <param name="type"> Typedef name as search filter when get typedefs. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List all type definitions in bulk. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetTypeDefinition.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<AtlasTypesDef> response = client.GetTypeDefinition();
]]></code>
This sample shows how to call GetTypeDefinition.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<AtlasTypesDef> response = client.GetTypeDefinition();
]]></code>
This sample shows how to call GetTypeDefinition.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<AtlasTypesDef> response = client.GetTypeDefinition();
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTypeDefinition (bool? includeTermTemplate, string type, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTypeDefinition(valuetype System.Nullable`1&lt;bool&gt; includeTermTemplate, string type, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTypeDefinition(System.Nullable{System.Boolean},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeDefinition (includeTermTemplate As Nullable(Of Boolean), type As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTypeDefinition : Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTypeDefinition : Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; Azure.Response" Usage="typeDefinition.GetTypeDefinition (includeTermTemplate, type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeTermTemplate" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="includeTermTemplate">
            Whether include termtemplatedef when return all typedefs.
            This is always true
            when search filter type=term_template
            </param>
        <param name="type"> Typedef name as search filter when get typedefs. Allowed values: "PRIMITIVE" | "OBJECT_ID_TYPE" | "ENUM" | "STRUCT" | "CLASSIFICATION" | "ENTITY" | "ARRAY" | "MAP" | "RELATIONSHIP" | "TERM_TEMPLATE". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List all type definitions in bulk.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTypeDefinition(System.Nullable{System.Boolean},System.Nullable{Azure.Analytics.Purview.DataMap.TypeCategory},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTypeDefinition and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = client.GetTypeDefinition(true, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTypeDefinition and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = client.GetTypeDefinition(null, "ENUM", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTypeDefinition and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = client.GetTypeDefinition(null, "TERM_TEMPLATE", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTypeDefinitionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt; GetTypeDefinitionAsync (bool? includeTermTemplate = default, Azure.Analytics.Purview.DataMap.TypeCategory? type = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt; GetTypeDefinitionAsync(valuetype System.Nullable`1&lt;bool&gt; includeTermTemplate, valuetype System.Nullable`1&lt;valuetype Azure.Analytics.Purview.DataMap.TypeCategory&gt; type, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTypeDefinitionAsync(System.Nullable{System.Boolean},System.Nullable{Azure.Analytics.Purview.DataMap.TypeCategory},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeDefinitionAsync (Optional includeTermTemplate As Nullable(Of Boolean) = Nothing, Optional type As Nullable(Of TypeCategory) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasTypesDef))" />
      <MemberSignature Language="F#" Value="abstract member GetTypeDefinitionAsync : Nullable&lt;bool&gt; * Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;&#xA;override this.GetTypeDefinitionAsync : Nullable&lt;bool&gt; * Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;" Usage="typeDefinition.GetTypeDefinitionAsync (includeTermTemplate, type, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasTypesDef&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeTermTemplate" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="type" Type="System.Nullable&lt;Azure.Analytics.Purview.DataMap.TypeCategory&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="includeTermTemplate">
            Whether include termtemplatedef when return all typedefs.
            This is always true
            when search filter type=term_template
            </param>
        <param name="type"> Typedef name as search filter when get typedefs. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List all type definitions in bulk. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetTypeDefinitionAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<AtlasTypesDef> response = await client.GetTypeDefinitionAsync();
]]></code>
This sample shows how to call GetTypeDefinitionAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<AtlasTypesDef> response = await client.GetTypeDefinitionAsync();
]]></code>
This sample shows how to call GetTypeDefinitionAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response<AtlasTypesDef> response = await client.GetTypeDefinitionAsync();
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTypeDefinitionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTypeDefinitionAsync (bool? includeTermTemplate, string type, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTypeDefinitionAsync(valuetype System.Nullable`1&lt;bool&gt; includeTermTemplate, string type, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTypeDefinitionAsync(System.Nullable{System.Boolean},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeDefinitionAsync (includeTermTemplate As Nullable(Of Boolean), type As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTypeDefinitionAsync : Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTypeDefinitionAsync : Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="typeDefinition.GetTypeDefinitionAsync (includeTermTemplate, type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeTermTemplate" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="includeTermTemplate">
            Whether include termtemplatedef when return all typedefs.
            This is always true
            when search filter type=term_template
            </param>
        <param name="type"> Typedef name as search filter when get typedefs. Allowed values: "PRIMITIVE" | "OBJECT_ID_TYPE" | "ENUM" | "STRUCT" | "CLASSIFICATION" | "ENTITY" | "ARRAY" | "MAP" | "RELATIONSHIP" | "TERM_TEMPLATE". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List all type definitions in bulk.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.TypeDefinition.GetTypeDefinitionAsync(System.Nullable{System.Boolean},System.Nullable{Azure.Analytics.Purview.DataMap.TypeCategory},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTypeDefinitionAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = await client.GetTypeDefinitionAsync(true, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTypeDefinitionAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = await client.GetTypeDefinitionAsync(null, "ENUM", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTypeDefinitionAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
TypeDefinition client = new DataMapClient(endpoint, credential).GetTypeDefinitionClient(apiVersion: "2023-09-01");

Response response = await client.GetTypeDefinitionAsync(null, "TERM_TEMPLATE", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Analytics.Purview.DataMap.TypeDefinition.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Analytics.Purview.DataMap.TypeDefinition.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
