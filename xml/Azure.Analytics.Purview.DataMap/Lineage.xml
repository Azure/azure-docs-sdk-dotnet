<Type Name="Lineage" FullName="Azure.Analytics.Purview.DataMap.Lineage">
  <TypeSignature Language="C#" Value="public class Lineage" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Lineage extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Analytics.Purview.DataMap.Lineage" />
  <TypeSignature Language="VB.NET" Value="Public Class Lineage" />
  <TypeSignature Language="F#" Value="type Lineage = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The Lineage sub-client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Lineage ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of Lineage for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt; GetByUniqueAttribute (string typeName, Azure.Analytics.Purview.DataMap.LineageDirection direction, int? depth = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt; GetByUniqueAttribute(string typeName, valuetype Azure.Analytics.Purview.DataMap.LineageDirection direction, valuetype System.Nullable`1&lt;int32&gt; depth, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetByUniqueAttribute(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByUniqueAttribute (typeName As String, direction As LineageDirection, Optional depth As Nullable(Of Integer) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasLineageInfo)" />
      <MemberSignature Language="F#" Value="abstract member GetByUniqueAttribute : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&#xA;override this.GetByUniqueAttribute : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;" Usage="lineage.GetByUniqueAttribute (typeName, direction, depth, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="direction" Type="Azure.Analytics.Purview.DataMap.LineageDirection" />
        <Parameter Name="depth" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. </param>
        <param name="depth"> The number of hops for lineage. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Return lineage info about entity.
            
             In addition to the typeName path parameter,
             attribute key-value pair(s) can be provided in the following
             format
            
             attr:[attrName]=[attrValue]
            
             NOTE: The attrName and attrValue should be
             unique across entities, eg. qualifiedName.
            
             The REST request would look
             something like this:
            
             GET
             /v2/lineage/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response<AtlasLineageInfo> response = client.GetByUniqueAttribute("<typeName>", LineageDirection.Input);
]]></code>
This sample shows how to call GetByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response<AtlasLineageInfo> response = client.GetByUniqueAttribute("<typeName>", LineageDirection.Input, depth: 1234, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetByUniqueAttribute (string typeName, string direction, int? depth = default, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetByUniqueAttribute(string typeName, string direction, valuetype System.Nullable`1&lt;int32&gt; depth, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetByUniqueAttribute(System.String,System.String,System.Nullable{System.Int32},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByUniqueAttribute (typeName As String, direction As String, Optional depth As Nullable(Of Integer) = Nothing, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetByUniqueAttribute : string * string * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetByUniqueAttribute : string * string * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.Response" Usage="lineage.GetByUniqueAttribute (typeName, direction, depth, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="direction" Type="System.String" />
        <Parameter Name="depth" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Allowed values: "INPUT" | "OUTPUT" | "BOTH". </param>
        <param name="depth"> The number of hops for lineage. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Return lineage info about entity.
            
             In addition to the typeName path parameter,
             attribute key-value pair(s) can be provided in the following
             format
            
             attr:[attrName]=[attrValue]
            
             NOTE: The attrName and attrValue should be
             unique across entities, eg. qualifiedName.
            
             The REST request would look
             something like this:
            
             GET
             /v2/lineage/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Lineage.GetByUniqueAttribute(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="direction" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByUniqueAttribute and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response response = client.GetByUniqueAttribute("<typeName>", "INPUT");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetByUniqueAttribute with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response response = client.GetByUniqueAttribute("<typeName>", "INPUT", depth: 1234, attribute: "<attribute>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("baseEntityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("widthCounts").GetProperty("<key>").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("lineageDepth").ToString());
Console.WriteLine(result.GetProperty("lineageWidth").ToString());
Console.WriteLine(result.GetProperty("childrenCount").ToString());
Console.WriteLine(result.GetProperty("lineageDirection").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("childEntityId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("parentEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("fromEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("toEntityId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt; GetByUniqueAttributeAsync (string typeName, Azure.Analytics.Purview.DataMap.LineageDirection direction, int? depth = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt; GetByUniqueAttributeAsync(string typeName, valuetype Azure.Analytics.Purview.DataMap.LineageDirection direction, valuetype System.Nullable`1&lt;int32&gt; depth, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetByUniqueAttributeAsync(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByUniqueAttributeAsync (typeName As String, direction As LineageDirection, Optional depth As Nullable(Of Integer) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasLineageInfo))" />
      <MemberSignature Language="F#" Value="abstract member GetByUniqueAttributeAsync : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;&#xA;override this.GetByUniqueAttributeAsync : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;" Usage="lineage.GetByUniqueAttributeAsync (typeName, direction, depth, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="direction" Type="Azure.Analytics.Purview.DataMap.LineageDirection" />
        <Parameter Name="depth" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. </param>
        <param name="depth"> The number of hops for lineage. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Return lineage info about entity.
            
             In addition to the typeName path parameter,
             attribute key-value pair(s) can be provided in the following
             format
            
             attr:[attrName]=[attrValue]
            
             NOTE: The attrName and attrValue should be
             unique across entities, eg. qualifiedName.
            
             The REST request would look
             something like this:
            
             GET
             /v2/lineage/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response<AtlasLineageInfo> response = await client.GetByUniqueAttributeAsync("<typeName>", LineageDirection.Input);
]]></code>
This sample shows how to call GetByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response<AtlasLineageInfo> response = await client.GetByUniqueAttributeAsync("<typeName>", LineageDirection.Input, depth: 1234, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetByUniqueAttributeAsync (string typeName, string direction, int? depth = default, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetByUniqueAttributeAsync(string typeName, string direction, valuetype System.Nullable`1&lt;int32&gt; depth, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetByUniqueAttributeAsync(System.String,System.String,System.Nullable{System.Int32},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByUniqueAttributeAsync (typeName As String, direction As String, Optional depth As Nullable(Of Integer) = Nothing, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetByUniqueAttributeAsync : string * string * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetByUniqueAttributeAsync : string * string * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="lineage.GetByUniqueAttributeAsync (typeName, direction, depth, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="direction" Type="System.String" />
        <Parameter Name="depth" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Allowed values: "INPUT" | "OUTPUT" | "BOTH". </param>
        <param name="depth"> The number of hops for lineage. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Return lineage info about entity.
            
             In addition to the typeName path parameter,
             attribute key-value pair(s) can be provided in the following
             format
            
             attr:[attrName]=[attrValue]
            
             NOTE: The attrName and attrValue should be
             unique across entities, eg. qualifiedName.
            
             The REST request would look
             something like this:
            
             GET
             /v2/lineage/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Lineage.GetByUniqueAttributeAsync(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="direction" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByUniqueAttributeAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response response = await client.GetByUniqueAttributeAsync("<typeName>", "INPUT");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetByUniqueAttributeAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response response = await client.GetByUniqueAttributeAsync("<typeName>", "INPUT", depth: 1234, attribute: "<attribute>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("baseEntityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("widthCounts").GetProperty("<key>").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("lineageDepth").ToString());
Console.WriteLine(result.GetProperty("lineageWidth").ToString());
Console.WriteLine(result.GetProperty("childrenCount").ToString());
Console.WriteLine(result.GetProperty("lineageDirection").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("childEntityId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("parentEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("fromEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("toEntityId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLineage">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt; GetLineage (string guid, Azure.Analytics.Purview.DataMap.LineageDirection direction, int? depth = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt; GetLineage(string guid, valuetype Azure.Analytics.Purview.DataMap.LineageDirection direction, valuetype System.Nullable`1&lt;int32&gt; depth, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetLineage(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLineage (guid As String, direction As LineageDirection, Optional depth As Nullable(Of Integer) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasLineageInfo)" />
      <MemberSignature Language="F#" Value="abstract member GetLineage : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&#xA;override this.GetLineage : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;" Usage="lineage.GetLineage (guid, direction, depth, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="direction" Type="Azure.Analytics.Purview.DataMap.LineageDirection" />
        <Parameter Name="depth" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. </param>
        <param name="depth"> The number of hops for lineage. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get lineage info of the entity specified by GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetLineage.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response<AtlasLineageInfo> response = client.GetLineage("<guid>", LineageDirection.Input);
]]></code>
This sample shows how to call GetLineage with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response<AtlasLineageInfo> response = client.GetLineage("<guid>", LineageDirection.Input, depth: 1234);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLineage">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetLineage (string guid, string direction, int? depth = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetLineage(string guid, string direction, valuetype System.Nullable`1&lt;int32&gt; depth, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetLineage(System.String,System.String,System.Nullable{System.Int32},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLineage (guid As String, direction As String, Optional depth As Nullable(Of Integer) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetLineage : string * string * Nullable&lt;int&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetLineage : string * string * Nullable&lt;int&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="lineage.GetLineage (guid, direction, depth, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="direction" Type="System.String" />
        <Parameter Name="depth" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Allowed values: "INPUT" | "OUTPUT" | "BOTH". </param>
        <param name="depth"> The number of hops for lineage. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get lineage info of the entity specified by GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Lineage.GetLineage(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="direction" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLineage and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response response = client.GetLineage("<guid>", "INPUT");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetLineage with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response response = client.GetLineage("<guid>", "INPUT", depth: 1234);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("baseEntityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("widthCounts").GetProperty("<key>").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("lineageDepth").ToString());
Console.WriteLine(result.GetProperty("lineageWidth").ToString());
Console.WriteLine(result.GetProperty("childrenCount").ToString());
Console.WriteLine(result.GetProperty("lineageDirection").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("childEntityId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("parentEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("fromEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("toEntityId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLineageAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt; GetLineageAsync (string guid, Azure.Analytics.Purview.DataMap.LineageDirection direction, int? depth = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt; GetLineageAsync(string guid, valuetype Azure.Analytics.Purview.DataMap.LineageDirection direction, valuetype System.Nullable`1&lt;int32&gt; depth, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetLineageAsync(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLineageAsync (guid As String, direction As LineageDirection, Optional depth As Nullable(Of Integer) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasLineageInfo))" />
      <MemberSignature Language="F#" Value="abstract member GetLineageAsync : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;&#xA;override this.GetLineageAsync : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;" Usage="lineage.GetLineageAsync (guid, direction, depth, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="direction" Type="Azure.Analytics.Purview.DataMap.LineageDirection" />
        <Parameter Name="depth" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. </param>
        <param name="depth"> The number of hops for lineage. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get lineage info of the entity specified by GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetLineageAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response<AtlasLineageInfo> response = await client.GetLineageAsync("<guid>", LineageDirection.Input);
]]></code>
This sample shows how to call GetLineageAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response<AtlasLineageInfo> response = await client.GetLineageAsync("<guid>", LineageDirection.Input, depth: 1234);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLineageAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetLineageAsync (string guid, string direction, int? depth = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetLineageAsync(string guid, string direction, valuetype System.Nullable`1&lt;int32&gt; depth, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetLineageAsync(System.String,System.String,System.Nullable{System.Int32},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLineageAsync (guid As String, direction As String, Optional depth As Nullable(Of Integer) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetLineageAsync : string * string * Nullable&lt;int&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetLineageAsync : string * string * Nullable&lt;int&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="lineage.GetLineageAsync (guid, direction, depth, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="direction" Type="System.String" />
        <Parameter Name="depth" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Allowed values: "INPUT" | "OUTPUT" | "BOTH". </param>
        <param name="depth"> The number of hops for lineage. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get lineage info of the entity specified by GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Lineage.GetLineageAsync(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="direction" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLineageAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response response = await client.GetLineageAsync("<guid>", "INPUT");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetLineageAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient();

Response response = await client.GetLineageAsync("<guid>", "INPUT", depth: 1234);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("baseEntityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("widthCounts").GetProperty("<key>").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("lineageDepth").ToString());
Console.WriteLine(result.GetProperty("lineageWidth").ToString());
Console.WriteLine(result.GetProperty("childrenCount").ToString());
Console.WriteLine(result.GetProperty("lineageDirection").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("childEntityId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("parentEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("fromEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("toEntityId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNextPage">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt; GetNextPage (string guid, Azure.Analytics.Purview.DataMap.LineageDirection direction, int? offset = default, int? limit = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt; GetNextPage(string guid, valuetype Azure.Analytics.Purview.DataMap.LineageDirection direction, valuetype System.Nullable`1&lt;int32&gt; offset, valuetype System.Nullable`1&lt;int32&gt; limit, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetNextPage(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNextPage (guid As String, direction As LineageDirection, Optional offset As Nullable(Of Integer) = Nothing, Optional limit As Nullable(Of Integer) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasLineageInfo)" />
      <MemberSignature Language="F#" Value="abstract member GetNextPage : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&#xA;override this.GetNextPage : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;" Usage="lineage.GetNextPage (guid, direction, offset, limit, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="direction" Type="Azure.Analytics.Purview.DataMap.LineageDirection" />
        <Parameter Name="offset" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="limit" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. </param>
        <param name="offset"> The offset for pagination purpose. </param>
        <param name="limit"> The page size - by default there is no paging. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Return immediate next page lineage info about entity with pagination. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNextPage.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient(apiVersion: "2023-09-01");

Response<AtlasLineageInfo> response = client.GetNextPage("<guid>", LineageDirection.Input);
]]></code>
This sample shows how to call GetNextPage with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient(apiVersion: "2023-09-01");

Response<AtlasLineageInfo> response = client.GetNextPage("<guid>", LineageDirection.Input, offset: 1234, limit: 1234);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNextPage">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetNextPage (string guid, string direction, int? offset = default, int? limit = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetNextPage(string guid, string direction, valuetype System.Nullable`1&lt;int32&gt; offset, valuetype System.Nullable`1&lt;int32&gt; limit, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetNextPage(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNextPage (guid As String, direction As String, Optional offset As Nullable(Of Integer) = Nothing, Optional limit As Nullable(Of Integer) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetNextPage : string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetNextPage : string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="lineage.GetNextPage (guid, direction, offset, limit, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="direction" Type="System.String" />
        <Parameter Name="offset" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="limit" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Allowed values: "INPUT" | "OUTPUT" | "BOTH". </param>
        <param name="offset"> The offset for pagination purpose. </param>
        <param name="limit"> The page size - by default there is no paging. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Return immediate next page lineage info about entity with pagination
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Lineage.GetNextPage(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="direction" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNextPage and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient(apiVersion: "2023-09-01");

Response response = client.GetNextPage("<guid>", "INPUT");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetNextPage with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient(apiVersion: "2023-09-01");

Response response = client.GetNextPage("<guid>", "INPUT", offset: 1234, limit: 1234);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("baseEntityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("widthCounts").GetProperty("<key>").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("lineageDepth").ToString());
Console.WriteLine(result.GetProperty("lineageWidth").ToString());
Console.WriteLine(result.GetProperty("childrenCount").ToString());
Console.WriteLine(result.GetProperty("lineageDirection").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("childEntityId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("parentEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("fromEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("toEntityId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNextPageAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt; GetNextPageAsync (string guid, Azure.Analytics.Purview.DataMap.LineageDirection direction, int? offset = default, int? limit = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt; GetNextPageAsync(string guid, valuetype Azure.Analytics.Purview.DataMap.LineageDirection direction, valuetype System.Nullable`1&lt;int32&gt; offset, valuetype System.Nullable`1&lt;int32&gt; limit, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetNextPageAsync(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNextPageAsync (guid As String, direction As LineageDirection, Optional offset As Nullable(Of Integer) = Nothing, Optional limit As Nullable(Of Integer) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasLineageInfo))" />
      <MemberSignature Language="F#" Value="abstract member GetNextPageAsync : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;&#xA;override this.GetNextPageAsync : string * Azure.Analytics.Purview.DataMap.LineageDirection * Nullable&lt;int&gt; * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;" Usage="lineage.GetNextPageAsync (guid, direction, offset, limit, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasLineageInfo&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="direction" Type="Azure.Analytics.Purview.DataMap.LineageDirection" />
        <Parameter Name="offset" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="limit" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. </param>
        <param name="offset"> The offset for pagination purpose. </param>
        <param name="limit"> The page size - by default there is no paging. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Return immediate next page lineage info about entity with pagination. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNextPageAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient(apiVersion: "2023-09-01");

Response<AtlasLineageInfo> response = await client.GetNextPageAsync("<guid>", LineageDirection.Input);
]]></code>
This sample shows how to call GetNextPageAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient(apiVersion: "2023-09-01");

Response<AtlasLineageInfo> response = await client.GetNextPageAsync("<guid>", LineageDirection.Input, offset: 1234, limit: 1234);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNextPageAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetNextPageAsync (string guid, string direction, int? offset = default, int? limit = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetNextPageAsync(string guid, string direction, valuetype System.Nullable`1&lt;int32&gt; offset, valuetype System.Nullable`1&lt;int32&gt; limit, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Lineage.GetNextPageAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNextPageAsync (guid As String, direction As String, Optional offset As Nullable(Of Integer) = Nothing, Optional limit As Nullable(Of Integer) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetNextPageAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetNextPageAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="lineage.GetNextPageAsync (guid, direction, offset, limit, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="direction" Type="System.String" />
        <Parameter Name="offset" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="limit" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="direction"> The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Allowed values: "INPUT" | "OUTPUT" | "BOTH". </param>
        <param name="offset"> The offset for pagination purpose. </param>
        <param name="limit"> The page size - by default there is no paging. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Return immediate next page lineage info about entity with pagination
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Lineage.GetNextPageAsync(System.String,Azure.Analytics.Purview.DataMap.LineageDirection,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="direction" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNextPageAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient(apiVersion: "2023-09-01");

Response response = await client.GetNextPageAsync("<guid>", "INPUT");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetNextPageAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Lineage client = new DataMapClient(endpoint, credential).GetLineageClient(apiVersion: "2023-09-01");

Response response = await client.GetNextPageAsync("<guid>", "INPUT", offset: 1234, limit: 1234);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("baseEntityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("guidEntityMap").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("widthCounts").GetProperty("<key>").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("lineageDepth").ToString());
Console.WriteLine(result.GetProperty("lineageWidth").ToString());
Console.WriteLine(result.GetProperty("childrenCount").ToString());
Console.WriteLine(result.GetProperty("lineageDirection").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("childEntityId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("parentRelations")[0].GetProperty("parentEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("fromEntityId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("relationshipId").ToString());
Console.WriteLine(result.GetProperty("relations")[0].GetProperty("toEntityId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Analytics.Purview.DataMap.Lineage.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Analytics.Purview.DataMap.Lineage.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
