<Type Name="Entity" FullName="Azure.Analytics.Purview.DataMap.Entity">
  <TypeSignature Language="C#" Value="public class Entity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Entity extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Analytics.Purview.DataMap.Entity" />
  <TypeSignature Language="VB.NET" Value="Public Class Entity" />
  <TypeSignature Language="F#" Value="type Entity = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The Entity sub-client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Entity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of Entity for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClassification">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddClassification (Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig classificationAssociateConfig, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddClassification(class Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig classificationAssociateConfig, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassification(Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassification (classificationAssociateConfig As ClassificationAssociateConfig, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddClassification : Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.AddClassification : Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.AddClassification (classificationAssociateConfig, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classificationAssociateConfig" Type="Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="classificationAssociateConfig"> The request payload for classification association. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Associate a classification to multiple entities in bulk. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="classificationAssociateConfig" /> is null. </exception>
        <example>
This sample shows how to call AddClassification.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

ClassificationAssociateConfig classificationAssociateConfig = new ClassificationAssociateConfig();
Response response = client.AddClassification(classificationAssociateConfig);
]]></code>
This sample shows how to call AddClassification with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

ClassificationAssociateConfig classificationAssociateConfig = new ClassificationAssociateConfig
{
    Classification = new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    },
    EntityGuids = { "<entityGuids>" },
};
Response response = client.AddClassification(classificationAssociateConfig);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassification">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddClassification (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddClassification(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassification(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassification (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddClassification : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.AddClassification : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.AddClassification (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Associate a classification to multiple entities in bulk.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddClassification(Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddClassification.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = client.AddClassification(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddClassification with all request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    classification = new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    },
    entityGuids = new object[]
    {
        "<entityGuids>"
    },
});
Response response = client.AddClassification(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassificationAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddClassificationAsync (Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig classificationAssociateConfig, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddClassificationAsync(class Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig classificationAssociateConfig, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationAsync(Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassificationAsync (classificationAssociateConfig As ClassificationAssociateConfig, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddClassificationAsync : Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddClassificationAsync : Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddClassificationAsync (classificationAssociateConfig, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classificationAssociateConfig" Type="Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="classificationAssociateConfig"> The request payload for classification association. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Associate a classification to multiple entities in bulk. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="classificationAssociateConfig" /> is null. </exception>
        <example>
This sample shows how to call AddClassificationAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

ClassificationAssociateConfig classificationAssociateConfig = new ClassificationAssociateConfig();
Response response = await client.AddClassificationAsync(classificationAssociateConfig);
]]></code>
This sample shows how to call AddClassificationAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

ClassificationAssociateConfig classificationAssociateConfig = new ClassificationAssociateConfig
{
    Classification = new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    },
    EntityGuids = { "<entityGuids>" },
};
Response response = await client.AddClassificationAsync(classificationAssociateConfig);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassificationAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddClassificationAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddClassificationAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassificationAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddClassificationAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddClassificationAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddClassificationAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Associate a classification to multiple entities in bulk.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationAsync(Azure.Analytics.Purview.DataMap.ClassificationAssociateConfig,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddClassificationAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = await client.AddClassificationAsync(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddClassificationAsync with all request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    classification = new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    },
    entityGuids = new object[]
    {
        "<entityGuids>"
    },
});
Response response = await client.AddClassificationAsync(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassifications">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddClassifications (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddClassifications(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassifications(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassifications (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddClassifications : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.AddClassifications : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.AddClassifications (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add classifications to an existing entity represented by a GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddClassifications(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddClassifications.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = client.AddClassifications("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddClassifications with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    }
});
Response response = client.AddClassifications("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassifications">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddClassifications (string guid, System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddClassifications(string guid, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassifications(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassifications (guid As String, body As IEnumerable(Of AtlasClassification), Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddClassifications : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.AddClassifications : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.AddClassifications (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> An array of classifications to be added. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add classifications to an existing entity represented by a GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddClassifications.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddClassifications("<guid>", new AtlasClassification[]
{
    new AtlasClassification()
});
]]></code>
This sample shows how to call AddClassifications with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddClassifications("<guid>", new AtlasClassification[]
{
    new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    }
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassificationsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddClassificationsAsync (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddClassificationsAsync(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassificationsAsync (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddClassificationsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddClassificationsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddClassificationsAsync (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add classifications to an existing entity represented by a GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsAsync(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddClassificationsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = await client.AddClassificationsAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddClassificationsAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    }
});
Response response = await client.AddClassificationsAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassificationsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddClassificationsAsync (string guid, System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddClassificationsAsync(string guid, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsAsync(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassificationsAsync (guid As String, body As IEnumerable(Of AtlasClassification), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddClassificationsAsync : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddClassificationsAsync : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddClassificationsAsync (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> An array of classifications to be added. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add classifications to an existing entity represented by a GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddClassificationsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddClassificationsAsync("<guid>", new AtlasClassification[]
{
    new AtlasClassification()
});
]]></code>
This sample shows how to call AddClassificationsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddClassificationsAsync("<guid>", new AtlasClassification[]
{
    new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    }
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassificationsByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddClassificationsByUniqueAttribute (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddClassificationsByUniqueAttribute(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsByUniqueAttribute(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassificationsByUniqueAttribute (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddClassificationsByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.AddClassificationsByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.AddClassificationsByUniqueAttribute (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add classification to the entity identified by its type and unique attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsByUniqueAttribute(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddClassificationsByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = client.AddClassificationsByUniqueAttribute("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddClassificationsByUniqueAttribute with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    }
});
Response response = client.AddClassificationsByUniqueAttribute("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassificationsByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddClassificationsByUniqueAttribute (string typeName, System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddClassificationsByUniqueAttribute(string typeName, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsByUniqueAttribute(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassificationsByUniqueAttribute (typeName As String, body As IEnumerable(Of AtlasClassification), Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddClassificationsByUniqueAttribute : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.AddClassificationsByUniqueAttribute : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.AddClassificationsByUniqueAttribute (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> An array of classification to be added. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add classification to the entity identified by its type and unique attributes. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddClassificationsByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddClassificationsByUniqueAttribute("<typeName>", new AtlasClassification[]
{
    new AtlasClassification()
});
]]></code>
This sample shows how to call AddClassificationsByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddClassificationsByUniqueAttribute("<typeName>", new AtlasClassification[]
{
    new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    }
}, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassificationsByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddClassificationsByUniqueAttributeAsync (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddClassificationsByUniqueAttributeAsync(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsByUniqueAttributeAsync(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassificationsByUniqueAttributeAsync (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddClassificationsByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddClassificationsByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddClassificationsByUniqueAttributeAsync (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add classification to the entity identified by its type and unique attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsByUniqueAttributeAsync(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddClassificationsByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = await client.AddClassificationsByUniqueAttributeAsync("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddClassificationsByUniqueAttributeAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    }
});
Response response = await client.AddClassificationsByUniqueAttributeAsync("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddClassificationsByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddClassificationsByUniqueAttributeAsync (string typeName, System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddClassificationsByUniqueAttributeAsync(string typeName, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddClassificationsByUniqueAttributeAsync(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddClassificationsByUniqueAttributeAsync (typeName As String, body As IEnumerable(Of AtlasClassification), Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddClassificationsByUniqueAttributeAsync : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddClassificationsByUniqueAttributeAsync : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddClassificationsByUniqueAttributeAsync (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> An array of classification to be added. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add classification to the entity identified by its type and unique attributes. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddClassificationsByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddClassificationsByUniqueAttributeAsync("<typeName>", new AtlasClassification[]
{
    new AtlasClassification()
});
]]></code>
This sample shows how to call AddClassificationsByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddClassificationsByUniqueAttributeAsync("<typeName>", new AtlasClassification[]
{
    new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    }
}, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddLabel">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddLabel (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddLabel(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddLabel(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddLabel (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddLabel : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.AddLabel : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.AddLabel (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add given labels to a given entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddLabel(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddLabel.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = client.AddLabel("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddLabel with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = client.AddLabel("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddLabel">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddLabel (string guid, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddLabel(string guid, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddLabel(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddLabel (guid As String, Optional body As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddLabel : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.AddLabel : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.AddLabel (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> set of labels to be added. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add given labels to a given entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddLabel.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddLabel("<guid>");
]]></code>
This sample shows how to call AddLabel with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddLabel("<guid>", body: new string[] { "<body>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddLabelAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddLabelAsync (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddLabelAsync(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddLabelAsync (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddLabelAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddLabelAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddLabelAsync (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add given labels to a given entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddLabelAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = await client.AddLabelAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddLabelAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = await client.AddLabelAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddLabelAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddLabelAsync (string guid, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddLabelAsync(string guid, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddLabelAsync (guid As String, Optional body As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddLabelAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddLabelAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddLabelAsync (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> set of labels to be added. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add given labels to a given entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddLabelAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddLabelAsync("<guid>");
]]></code>
This sample shows how to call AddLabelAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddLabelAsync("<guid>", body: new string[] { "<body>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddLabelsByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddLabelsByUniqueAttribute (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddLabelsByUniqueAttribute(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelsByUniqueAttribute(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddLabelsByUniqueAttribute (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddLabelsByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.AddLabelsByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.AddLabelsByUniqueAttribute (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Add given labels to a given entity identified by its type and unique
             attributes.
            
             If labels is null/empty, no labels will be added.
            
             In addition to
             the typeName path parameter, attribute key-value pair(s) can be provided in the
             following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this: PUT
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelsByUniqueAttribute(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddLabelsByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = client.AddLabelsByUniqueAttribute("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddLabelsByUniqueAttribute with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = client.AddLabelsByUniqueAttribute("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddLabelsByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddLabelsByUniqueAttribute (string typeName, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddLabelsByUniqueAttribute(string typeName, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelsByUniqueAttribute(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddLabelsByUniqueAttribute (typeName As String, Optional body As IEnumerable(Of String) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddLabelsByUniqueAttribute : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.AddLabelsByUniqueAttribute : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.AddLabelsByUniqueAttribute (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> set of labels to be added. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Add given labels to a given entity identified by its type and unique
             attributes.
            
             If labels is null/empty, no labels will be added.
            
             In addition to
             the typeName path parameter, attribute key-value pair(s) can be provided in the
             following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this: PUT
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddLabelsByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddLabelsByUniqueAttribute("<typeName>");
]]></code>
This sample shows how to call AddLabelsByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddLabelsByUniqueAttribute("<typeName>", body: new string[] { "<body>" }, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddLabelsByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddLabelsByUniqueAttributeAsync (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddLabelsByUniqueAttributeAsync(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelsByUniqueAttributeAsync(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddLabelsByUniqueAttributeAsync (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddLabelsByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddLabelsByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddLabelsByUniqueAttributeAsync (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Add given labels to a given entity identified by its type and unique
             attributes.
            
             If labels is null/empty, no labels will be added.
            
             In addition to
             the typeName path parameter, attribute key-value pair(s) can be provided in the
             following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this: PUT
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelsByUniqueAttributeAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddLabelsByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = await client.AddLabelsByUniqueAttributeAsync("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddLabelsByUniqueAttributeAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = await client.AddLabelsByUniqueAttributeAsync("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddLabelsByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddLabelsByUniqueAttributeAsync (string typeName, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddLabelsByUniqueAttributeAsync(string typeName, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddLabelsByUniqueAttributeAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddLabelsByUniqueAttributeAsync (typeName As String, Optional body As IEnumerable(Of String) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddLabelsByUniqueAttributeAsync : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddLabelsByUniqueAttributeAsync : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddLabelsByUniqueAttributeAsync (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> set of labels to be added. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Add given labels to a given entity identified by its type and unique
             attributes.
            
             If labels is null/empty, no labels will be added.
            
             In addition to
             the typeName path parameter, attribute key-value pair(s) can be provided in the
             following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this: PUT
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddLabelsByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddLabelsByUniqueAttributeAsync("<typeName>");
]]></code>
This sample shows how to call AddLabelsByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddLabelsByUniqueAttributeAsync("<typeName>", body: new string[] { "<body>" }, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdateBusinessMetadata">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddOrUpdateBusinessMetadata (string guid, Azure.Core.RequestContent content, bool? overwrite = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddOrUpdateBusinessMetadata(string guid, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;bool&gt; overwrite, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadata(System.String,Azure.Core.RequestContent,System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOrUpdateBusinessMetadata (guid As String, content As RequestContent, Optional overwrite As Nullable(Of Boolean) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddOrUpdateBusinessMetadata : string * Azure.Core.RequestContent * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.AddOrUpdateBusinessMetadata : string * Azure.Core.RequestContent * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="entity.AddOrUpdateBusinessMetadata (guid, content, overwrite, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="overwrite" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="overwrite">
            Whether to overwrite the existing business metadata on the entity or not,
            default is false.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add business metadata to an entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadata(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData}},System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddOrUpdateBusinessMetadata.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new
    {
        key = new object(),
    },
});
Response response = client.AddOrUpdateBusinessMetadata("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddOrUpdateBusinessMetadata with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new
    {
        key = new object(),
    },
});
Response response = client.AddOrUpdateBusinessMetadata("<guid>", content, overwrite: true);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdateBusinessMetadata">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddOrUpdateBusinessMetadata (string guid, System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.IDictionary&lt;string,BinaryData&gt;&gt; body, bool? overwrite = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddOrUpdateBusinessMetadata(string guid, class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.IDictionary`2&lt;string, class System.BinaryData&gt;&gt; body, valuetype System.Nullable`1&lt;bool&gt; overwrite, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadata(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData}},System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOrUpdateBusinessMetadata (guid As String, body As IDictionary(Of String, IDictionary(Of String, BinaryData)), Optional overwrite As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddOrUpdateBusinessMetadata : string * System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IDictionary&lt;string, BinaryData&gt;&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.AddOrUpdateBusinessMetadata : string * System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IDictionary&lt;string, BinaryData&gt;&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.AddOrUpdateBusinessMetadata (guid, body, overwrite, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.IDictionary&lt;System.String,System.BinaryData&gt;&gt;" />
        <Parameter Name="overwrite" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> BusinessMetadata payload. </param>
        <param name="overwrite">
            Whether to overwrite the existing business metadata on the entity or not,
            default is false.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add business metadata to an entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddOrUpdateBusinessMetadata.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddOrUpdateBusinessMetadata("<guid>", new Dictionary<string, IDictionary<string, BinaryData>>
{
    ["key"] = new Dictionary<string, BinaryData>
    {
        ["key"] = BinaryData.FromObjectAsJson(new object())
    }
});
]]></code>
This sample shows how to call AddOrUpdateBusinessMetadata with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddOrUpdateBusinessMetadata("<guid>", new Dictionary<string, IDictionary<string, BinaryData>>
{
    ["key"] = new Dictionary<string, BinaryData>
    {
        ["key"] = BinaryData.FromObjectAsJson(new object())
    }
}, overwrite: true);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdateBusinessMetadataAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddOrUpdateBusinessMetadataAsync (string guid, Azure.Core.RequestContent content, bool? overwrite = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddOrUpdateBusinessMetadataAsync(string guid, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;bool&gt; overwrite, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOrUpdateBusinessMetadataAsync (guid As String, content As RequestContent, Optional overwrite As Nullable(Of Boolean) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddOrUpdateBusinessMetadataAsync : string * Azure.Core.RequestContent * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddOrUpdateBusinessMetadataAsync : string * Azure.Core.RequestContent * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddOrUpdateBusinessMetadataAsync (guid, content, overwrite, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="overwrite" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="overwrite">
            Whether to overwrite the existing business metadata on the entity or not,
            default is false.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add business metadata to an entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAsync(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData}},System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddOrUpdateBusinessMetadataAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new
    {
        key = new object(),
    },
});
Response response = await client.AddOrUpdateBusinessMetadataAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddOrUpdateBusinessMetadataAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new
    {
        key = new object(),
    },
});
Response response = await client.AddOrUpdateBusinessMetadataAsync("<guid>", content, overwrite: true);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdateBusinessMetadataAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddOrUpdateBusinessMetadataAsync (string guid, System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.IDictionary&lt;string,BinaryData&gt;&gt; body, bool? overwrite = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddOrUpdateBusinessMetadataAsync(string guid, class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.IDictionary`2&lt;string, class System.BinaryData&gt;&gt; body, valuetype System.Nullable`1&lt;bool&gt; overwrite, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAsync(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData}},System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOrUpdateBusinessMetadataAsync (guid As String, body As IDictionary(Of String, IDictionary(Of String, BinaryData)), Optional overwrite As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddOrUpdateBusinessMetadataAsync : string * System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IDictionary&lt;string, BinaryData&gt;&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddOrUpdateBusinessMetadataAsync : string * System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IDictionary&lt;string, BinaryData&gt;&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddOrUpdateBusinessMetadataAsync (guid, body, overwrite, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.IDictionary&lt;System.String,System.BinaryData&gt;&gt;" />
        <Parameter Name="overwrite" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> BusinessMetadata payload. </param>
        <param name="overwrite">
            Whether to overwrite the existing business metadata on the entity or not,
            default is false.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add business metadata to an entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddOrUpdateBusinessMetadataAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddOrUpdateBusinessMetadataAsync("<guid>", new Dictionary<string, IDictionary<string, BinaryData>>
{
    ["key"] = new Dictionary<string, BinaryData>
    {
        ["key"] = BinaryData.FromObjectAsJson(new object())
    }
});
]]></code>
This sample shows how to call AddOrUpdateBusinessMetadataAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddOrUpdateBusinessMetadataAsync("<guid>", new Dictionary<string, IDictionary<string, BinaryData>>
{
    ["key"] = new Dictionary<string, BinaryData>
    {
        ["key"] = BinaryData.FromObjectAsJson(new object())
    }
}, overwrite: true);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdateBusinessMetadataAttributes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddOrUpdateBusinessMetadataAttributes (string guid, string businessMetadataName, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddOrUpdateBusinessMetadataAttributes(string guid, string businessMetadataName, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAttributes(System.String,System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOrUpdateBusinessMetadataAttributes (guid As String, businessMetadataName As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddOrUpdateBusinessMetadataAttributes : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.AddOrUpdateBusinessMetadataAttributes : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.AddOrUpdateBusinessMetadataAttributes (guid, businessMetadataName, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="businessMetadataName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="businessMetadataName"> BusinessMetadata name. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add or update business metadata attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAttributes(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="businessMetadataName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="businessMetadataName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddOrUpdateBusinessMetadataAttributes.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new object(),
});
Response response = client.AddOrUpdateBusinessMetadataAttributes("<guid>", "<businessMetadataName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddOrUpdateBusinessMetadataAttributes with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new object(),
});
Response response = client.AddOrUpdateBusinessMetadataAttributes("<guid>", "<businessMetadataName>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdateBusinessMetadataAttributes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response AddOrUpdateBusinessMetadataAttributes (string guid, string businessMetadataName, System.Collections.Generic.IDictionary&lt;string,BinaryData&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response AddOrUpdateBusinessMetadataAttributes(string guid, string businessMetadataName, class System.Collections.Generic.IDictionary`2&lt;string, class System.BinaryData&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAttributes(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOrUpdateBusinessMetadataAttributes (guid As String, businessMetadataName As String, body As IDictionary(Of String, BinaryData), Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member AddOrUpdateBusinessMetadataAttributes : string * string * System.Collections.Generic.IDictionary&lt;string, BinaryData&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.AddOrUpdateBusinessMetadataAttributes : string * string * System.Collections.Generic.IDictionary&lt;string, BinaryData&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.AddOrUpdateBusinessMetadataAttributes (guid, businessMetadataName, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="businessMetadataName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IDictionary&lt;System.String,System.BinaryData&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="businessMetadataName"> BusinessMetadata name. </param>
        <param name="body"> Business metadata attribute payload. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add or update business metadata attributes. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="businessMetadataName" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="businessMetadataName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddOrUpdateBusinessMetadataAttributes.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddOrUpdateBusinessMetadataAttributes("<guid>", "<businessMetadataName>", new Dictionary<string, BinaryData>
{
    ["key"] = BinaryData.FromObjectAsJson(new object())
});
]]></code>
This sample shows how to call AddOrUpdateBusinessMetadataAttributes with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.AddOrUpdateBusinessMetadataAttributes("<guid>", "<businessMetadataName>", new Dictionary<string, BinaryData>
{
    ["key"] = BinaryData.FromObjectAsJson(new object())
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdateBusinessMetadataAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddOrUpdateBusinessMetadataAttributesAsync (string guid, string businessMetadataName, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddOrUpdateBusinessMetadataAttributesAsync(string guid, string businessMetadataName, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAttributesAsync(System.String,System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOrUpdateBusinessMetadataAttributesAsync (guid As String, businessMetadataName As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddOrUpdateBusinessMetadataAttributesAsync : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddOrUpdateBusinessMetadataAttributesAsync : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddOrUpdateBusinessMetadataAttributesAsync (guid, businessMetadataName, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="businessMetadataName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="businessMetadataName"> BusinessMetadata name. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add or update business metadata attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAttributesAsync(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="businessMetadataName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="businessMetadataName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call AddOrUpdateBusinessMetadataAttributesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new object(),
});
Response response = await client.AddOrUpdateBusinessMetadataAttributesAsync("<guid>", "<businessMetadataName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call AddOrUpdateBusinessMetadataAttributesAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new object(),
});
Response response = await client.AddOrUpdateBusinessMetadataAttributesAsync("<guid>", "<businessMetadataName>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdateBusinessMetadataAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; AddOrUpdateBusinessMetadataAttributesAsync (string guid, string businessMetadataName, System.Collections.Generic.IDictionary&lt;string,BinaryData&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; AddOrUpdateBusinessMetadataAttributesAsync(string guid, string businessMetadataName, class System.Collections.Generic.IDictionary`2&lt;string, class System.BinaryData&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.AddOrUpdateBusinessMetadataAttributesAsync(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOrUpdateBusinessMetadataAttributesAsync (guid As String, businessMetadataName As String, body As IDictionary(Of String, BinaryData), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member AddOrUpdateBusinessMetadataAttributesAsync : string * string * System.Collections.Generic.IDictionary&lt;string, BinaryData&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.AddOrUpdateBusinessMetadataAttributesAsync : string * string * System.Collections.Generic.IDictionary&lt;string, BinaryData&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.AddOrUpdateBusinessMetadataAttributesAsync (guid, businessMetadataName, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="businessMetadataName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IDictionary&lt;System.String,System.BinaryData&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="businessMetadataName"> BusinessMetadata name. </param>
        <param name="body"> Business metadata attribute payload. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Add or update business metadata attributes. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="businessMetadataName" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="businessMetadataName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call AddOrUpdateBusinessMetadataAttributesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddOrUpdateBusinessMetadataAttributesAsync("<guid>", "<businessMetadataName>", new Dictionary<string, BinaryData>
{
    ["key"] = BinaryData.FromObjectAsJson(new object())
});
]]></code>
This sample shows how to call AddOrUpdateBusinessMetadataAttributesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.AddOrUpdateBusinessMetadataAttributesAsync("<guid>", "<businessMetadataName>", new Dictionary<string, BinaryData>
{
    ["key"] = BinaryData.FromObjectAsJson(new object())
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchCreateOrUpdate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; BatchCreateOrUpdate (Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo atlasEntitiesWithExtInfo, string collectionId = default, Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; BatchCreateOrUpdate(class Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo atlasEntitiesWithExtInfo, string collectionId, valuetype System.Nullable`1&lt;valuetype Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; businessAttributeUpdateBehavior, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchCreateOrUpdate(Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo,System.String,System.Nullable{Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchCreateOrUpdate (atlasEntitiesWithExtInfo As AtlasEntitiesWithExtInfo, Optional collectionId As String = Nothing, Optional businessAttributeUpdateBehavior As Nullable(Of BusinessAttributeUpdateBehavior) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of EntityMutationResult)" />
      <MemberSignature Language="F#" Value="abstract member BatchCreateOrUpdate : Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo * string * Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&#xA;override this.BatchCreateOrUpdate : Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo * string * Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;" Usage="entity.BatchCreateOrUpdate (atlasEntitiesWithExtInfo, collectionId, businessAttributeUpdateBehavior, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atlasEntitiesWithExtInfo" Type="Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="businessAttributeUpdateBehavior" Type="System.Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="atlasEntitiesWithExtInfo">
            An instance of an entity along with extended info - like hive_table,
            hive_database.
            </param>
        <param name="collectionId">
            The collection where entities will be moved to. Only specify a value if you
            need to move an entity to another collection.
            </param>
        <param name="businessAttributeUpdateBehavior">
            Used to define the update behavior for business attributes when updating
            entities.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Create or update entities in bulk.
            Existing entity is matched using its unique
            guid if supplied or by its unique attributes eg: qualifiedName.
            Map and array
            of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
            array&lt;map&lt;string, int&gt;&gt;.
            For each contact type, the maximum number of contacts
            is 20.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="atlasEntitiesWithExtInfo" /> is null. </exception>
        <example>
This sample shows how to call BatchCreateOrUpdate.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntitiesWithExtInfo atlasEntitiesWithExtInfo = new AtlasEntitiesWithExtInfo();
Response<EntityMutationResult> response = client.BatchCreateOrUpdate(atlasEntitiesWithExtInfo);
]]></code>
This sample shows how to call BatchCreateOrUpdate with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

AtlasEntitiesWithExtInfo atlasEntitiesWithExtInfo = new AtlasEntitiesWithExtInfo
{
    ReferredEntities =
    {
        ["key"] = new AtlasEntity
        {
            Attributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            TypeName = "<typeName>",
            LastModifiedTS = "<lastModifiedTS>",
            BusinessAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Classifications = {new AtlasClassification
            {
                Attributes =
                {
                    ["key"] = BinaryData.FromObjectAsJson(new object())
                },
                TypeName = "<typeName>",
                LastModifiedTS = "<lastModifiedTS>",
                EntityGuid = "<entityGuid>",
                EntityStatus = EntityStatus.Active,
                RemovePropagationsOnEntityDelete = true,
                ValidityPeriods = {new TimeBoundary
                {
                    EndTime = "<endTime>",
                    StartTime = "<startTime>",
                    TimeZone = "<timeZone>",
                }},
            }},
            CreateTime = 1234L,
            CreatedBy = "<createdBy>",
            CustomAttributes =
            {
                ["key"] = "<customAttributes>"
            },
            Guid = "<guid>",
            HomeId = "<homeId>",
            IsIncomplete = true,
            Labels = {"<labels>"},
            Meanings = {new AtlasTermAssignmentHeader
            {
                Confidence = 1234,
                CreatedBy = "<createdBy>",
                Description = "<description>",
                DisplayText = "<displayText>",
                Expression = "<expression>",
                RelationGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
                Status = AtlasTermAssignmentStatus.Discovered,
                Steward = "<steward>",
                TermGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
            }},
            ProvenanceType = 1234,
            Proxy = true,
            RelationshipAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Status = EntityStatus.Active,
            UpdateTime = 1234L,
            UpdatedBy = "<updatedBy>",
            Version = 1234L,
            Contacts =
            {
                ["key"] = {new ContactInfo
                {
                    Id = "<id>",
                    Info = "<info>",
                }}
            },
        }
    },
    Entities = { default },
};
Response<EntityMutationResult> response = client.BatchCreateOrUpdate(atlasEntitiesWithExtInfo, collectionId: "<collectionId>", businessAttributeUpdateBehavior: BusinessAttributeUpdateBehavior.Ignore);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchCreateOrUpdate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response BatchCreateOrUpdate (Azure.Core.RequestContent content, string collectionId = default, string businessAttributeUpdateBehavior = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response BatchCreateOrUpdate(class Azure.Core.RequestContent content, string collectionId, string businessAttributeUpdateBehavior, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchCreateOrUpdate(Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchCreateOrUpdate (content As RequestContent, Optional collectionId As String = Nothing, Optional businessAttributeUpdateBehavior As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member BatchCreateOrUpdate : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.BatchCreateOrUpdate : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.BatchCreateOrUpdate (content, collectionId, businessAttributeUpdateBehavior, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="businessAttributeUpdateBehavior" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId">
            The collection where entities will be moved to. Only specify a value if you
            need to move an entity to another collection.
            </param>
        <param name="businessAttributeUpdateBehavior">
            Used to define the update behavior for business attributes when updating
            entities. Allowed values: "ignore" | "replace" | "merge"
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Create or update entities in bulk.
            Existing entity is matched using its unique
            guid if supplied or by its unique attributes eg: qualifiedName.
            Map and array
            of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
            array&lt;map&lt;string, int&gt;&gt;.
            For each contact type, the maximum number of contacts
            is 20.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.BatchCreateOrUpdate(Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo,System.String,System.Nullable{Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchCreateOrUpdate and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = client.BatchCreateOrUpdate(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call BatchCreateOrUpdate with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

using RequestContent content = RequestContent.Create(new
{
    referredEntities = new
    {
        key = new
        {
            attributes = new
            {
                key = new object(),
            },
            typeName = "<typeName>",
            lastModifiedTS = "<lastModifiedTS>",
            businessAttributes = new
            {
                key = new object(),
            },
            classifications = new object[]
            {
                new
                {
                    attributes = new
                    {
                        key = new object(),
                    },
                    typeName = "<typeName>",
                    lastModifiedTS = "<lastModifiedTS>",
                    entityGuid = "<entityGuid>",
                    entityStatus = "ACTIVE",
                    removePropagationsOnEntityDelete = true,
                    validityPeriods = new object[]
                    {
                        new
                        {
                            endTime = "<endTime>",
                            startTime = "<startTime>",
                            timeZone = "<timeZone>",
                        }
                    },
                }
            },
            createTime = 1234L,
            createdBy = "<createdBy>",
            customAttributes = new
            {
                key = "<customAttributes>",
            },
            guid = "<guid>",
            homeId = "<homeId>",
            isIncomplete = true,
            labels = new object[]
            {
                "<labels>"
            },
            meanings = new object[]
            {
                new
                {
                    confidence = 1234,
                    createdBy = "<createdBy>",
                    description = "<description>",
                    displayText = "<displayText>",
                    expression = "<expression>",
                    relationGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                    status = "DISCOVERED",
                    steward = "<steward>",
                    termGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                }
            },
            provenanceType = 1234,
            proxy = true,
            relationshipAttributes = new
            {
                key = new object(),
            },
            status = "ACTIVE",
            updateTime = 1234L,
            updatedBy = "<updatedBy>",
            version = 1234L,
            contacts = new
            {
                key = new object[]
                {
                    new
                    {
                        id = "<id>",
                        info = "<info>",
                    }
                },
            },
        },
    },
    entities = new object[]
    {
        null
    },
});
Response response = client.BatchCreateOrUpdate(content, collectionId: "<collectionId>", businessAttributeUpdateBehavior: "ignore");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchCreateOrUpdateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; BatchCreateOrUpdateAsync (Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo atlasEntitiesWithExtInfo, string collectionId = default, Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; BatchCreateOrUpdateAsync(class Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo atlasEntitiesWithExtInfo, string collectionId, valuetype System.Nullable`1&lt;valuetype Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; businessAttributeUpdateBehavior, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchCreateOrUpdateAsync(Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo,System.String,System.Nullable{Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchCreateOrUpdateAsync (atlasEntitiesWithExtInfo As AtlasEntitiesWithExtInfo, Optional collectionId As String = Nothing, Optional businessAttributeUpdateBehavior As Nullable(Of BusinessAttributeUpdateBehavior) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of EntityMutationResult))" />
      <MemberSignature Language="F#" Value="abstract member BatchCreateOrUpdateAsync : Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo * string * Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;&#xA;override this.BatchCreateOrUpdateAsync : Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo * string * Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;" Usage="entity.BatchCreateOrUpdateAsync (atlasEntitiesWithExtInfo, collectionId, businessAttributeUpdateBehavior, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atlasEntitiesWithExtInfo" Type="Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="businessAttributeUpdateBehavior" Type="System.Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="atlasEntitiesWithExtInfo">
            An instance of an entity along with extended info - like hive_table,
            hive_database.
            </param>
        <param name="collectionId">
            The collection where entities will be moved to. Only specify a value if you
            need to move an entity to another collection.
            </param>
        <param name="businessAttributeUpdateBehavior">
            Used to define the update behavior for business attributes when updating
            entities.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Create or update entities in bulk.
            Existing entity is matched using its unique
            guid if supplied or by its unique attributes eg: qualifiedName.
            Map and array
            of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
            array&lt;map&lt;string, int&gt;&gt;.
            For each contact type, the maximum number of contacts
            is 20.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="atlasEntitiesWithExtInfo" /> is null. </exception>
        <example>
This sample shows how to call BatchCreateOrUpdateAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntitiesWithExtInfo atlasEntitiesWithExtInfo = new AtlasEntitiesWithExtInfo();
Response<EntityMutationResult> response = await client.BatchCreateOrUpdateAsync(atlasEntitiesWithExtInfo);
]]></code>
This sample shows how to call BatchCreateOrUpdateAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

AtlasEntitiesWithExtInfo atlasEntitiesWithExtInfo = new AtlasEntitiesWithExtInfo
{
    ReferredEntities =
    {
        ["key"] = new AtlasEntity
        {
            Attributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            TypeName = "<typeName>",
            LastModifiedTS = "<lastModifiedTS>",
            BusinessAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Classifications = {new AtlasClassification
            {
                Attributes =
                {
                    ["key"] = BinaryData.FromObjectAsJson(new object())
                },
                TypeName = "<typeName>",
                LastModifiedTS = "<lastModifiedTS>",
                EntityGuid = "<entityGuid>",
                EntityStatus = EntityStatus.Active,
                RemovePropagationsOnEntityDelete = true,
                ValidityPeriods = {new TimeBoundary
                {
                    EndTime = "<endTime>",
                    StartTime = "<startTime>",
                    TimeZone = "<timeZone>",
                }},
            }},
            CreateTime = 1234L,
            CreatedBy = "<createdBy>",
            CustomAttributes =
            {
                ["key"] = "<customAttributes>"
            },
            Guid = "<guid>",
            HomeId = "<homeId>",
            IsIncomplete = true,
            Labels = {"<labels>"},
            Meanings = {new AtlasTermAssignmentHeader
            {
                Confidence = 1234,
                CreatedBy = "<createdBy>",
                Description = "<description>",
                DisplayText = "<displayText>",
                Expression = "<expression>",
                RelationGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
                Status = AtlasTermAssignmentStatus.Discovered,
                Steward = "<steward>",
                TermGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
            }},
            ProvenanceType = 1234,
            Proxy = true,
            RelationshipAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Status = EntityStatus.Active,
            UpdateTime = 1234L,
            UpdatedBy = "<updatedBy>",
            Version = 1234L,
            Contacts =
            {
                ["key"] = {new ContactInfo
                {
                    Id = "<id>",
                    Info = "<info>",
                }}
            },
        }
    },
    Entities = { default },
};
Response<EntityMutationResult> response = await client.BatchCreateOrUpdateAsync(atlasEntitiesWithExtInfo, collectionId: "<collectionId>", businessAttributeUpdateBehavior: BusinessAttributeUpdateBehavior.Ignore);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchCreateOrUpdateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; BatchCreateOrUpdateAsync (Azure.Core.RequestContent content, string collectionId = default, string businessAttributeUpdateBehavior = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; BatchCreateOrUpdateAsync(class Azure.Core.RequestContent content, string collectionId, string businessAttributeUpdateBehavior, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchCreateOrUpdateAsync(Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchCreateOrUpdateAsync (content As RequestContent, Optional collectionId As String = Nothing, Optional businessAttributeUpdateBehavior As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member BatchCreateOrUpdateAsync : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.BatchCreateOrUpdateAsync : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.BatchCreateOrUpdateAsync (content, collectionId, businessAttributeUpdateBehavior, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="businessAttributeUpdateBehavior" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId">
            The collection where entities will be moved to. Only specify a value if you
            need to move an entity to another collection.
            </param>
        <param name="businessAttributeUpdateBehavior">
            Used to define the update behavior for business attributes when updating
            entities. Allowed values: "ignore" | "replace" | "merge"
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Create or update entities in bulk.
            Existing entity is matched using its unique
            guid if supplied or by its unique attributes eg: qualifiedName.
            Map and array
            of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
            array&lt;map&lt;string, int&gt;&gt;.
            For each contact type, the maximum number of contacts
            is 20.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.BatchCreateOrUpdateAsync(Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo,System.String,System.Nullable{Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchCreateOrUpdateAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = await client.BatchCreateOrUpdateAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call BatchCreateOrUpdateAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

using RequestContent content = RequestContent.Create(new
{
    referredEntities = new
    {
        key = new
        {
            attributes = new
            {
                key = new object(),
            },
            typeName = "<typeName>",
            lastModifiedTS = "<lastModifiedTS>",
            businessAttributes = new
            {
                key = new object(),
            },
            classifications = new object[]
            {
                new
                {
                    attributes = new
                    {
                        key = new object(),
                    },
                    typeName = "<typeName>",
                    lastModifiedTS = "<lastModifiedTS>",
                    entityGuid = "<entityGuid>",
                    entityStatus = "ACTIVE",
                    removePropagationsOnEntityDelete = true,
                    validityPeriods = new object[]
                    {
                        new
                        {
                            endTime = "<endTime>",
                            startTime = "<startTime>",
                            timeZone = "<timeZone>",
                        }
                    },
                }
            },
            createTime = 1234L,
            createdBy = "<createdBy>",
            customAttributes = new
            {
                key = "<customAttributes>",
            },
            guid = "<guid>",
            homeId = "<homeId>",
            isIncomplete = true,
            labels = new object[]
            {
                "<labels>"
            },
            meanings = new object[]
            {
                new
                {
                    confidence = 1234,
                    createdBy = "<createdBy>",
                    description = "<description>",
                    displayText = "<displayText>",
                    expression = "<expression>",
                    relationGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                    status = "DISCOVERED",
                    steward = "<steward>",
                    termGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                }
            },
            provenanceType = 1234,
            proxy = true,
            relationshipAttributes = new
            {
                key = new object(),
            },
            status = "ACTIVE",
            updateTime = 1234L,
            updatedBy = "<updatedBy>",
            version = 1234L,
            contacts = new
            {
                key = new object[]
                {
                    new
                    {
                        id = "<id>",
                        info = "<info>",
                    }
                },
            },
        },
    },
    entities = new object[]
    {
        null
    },
});
Response response = await client.BatchCreateOrUpdateAsync(content, collectionId: "<collectionId>", businessAttributeUpdateBehavior: "ignore");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchDelete">
      <MemberSignature Language="C#" Value="public virtual Azure.Response BatchDelete (System.Collections.Generic.IEnumerable&lt;string&gt; guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response BatchDelete(class System.Collections.Generic.IEnumerable`1&lt;string&gt; guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchDelete(System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchDelete (guid As IEnumerable(Of String), context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member BatchDelete : seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.BatchDelete : seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="entity.BatchDelete (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> An array of GUIDs of entities to delete. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete a list of entities in bulk identified by their GUIDs or unique
            attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.BatchDelete(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchDelete and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.BatchDelete(new string[] { "<guid>" }, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call BatchDelete with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.BatchDelete(new string[] { "<guid>" }, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchDelete">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; BatchDelete (System.Collections.Generic.IEnumerable&lt;string&gt; guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; BatchDelete(class System.Collections.Generic.IEnumerable`1&lt;string&gt; guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchDelete(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchDelete (guid As IEnumerable(Of String), Optional cancellationToken As CancellationToken = Nothing) As Response(Of EntityMutationResult)" />
      <MemberSignature Language="F#" Value="abstract member BatchDelete : seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&#xA;override this.BatchDelete : seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;" Usage="entity.BatchDelete (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> An array of GUIDs of entities to delete. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Delete a list of entities in bulk identified by their GUIDs or unique
            attributes.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <example>
This sample shows how to call BatchDelete.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = client.BatchDelete(new string[] { "<guid>" });
]]></code>
This sample shows how to call BatchDelete with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = client.BatchDelete(new string[] { "<guid>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchDeleteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; BatchDeleteAsync (System.Collections.Generic.IEnumerable&lt;string&gt; guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; BatchDeleteAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchDeleteAsync(System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchDeleteAsync (guid As IEnumerable(Of String), context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member BatchDeleteAsync : seq&lt;string&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.BatchDeleteAsync : seq&lt;string&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.BatchDeleteAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> An array of GUIDs of entities to delete. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete a list of entities in bulk identified by their GUIDs or unique
            attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.BatchDeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchDeleteAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.BatchDeleteAsync(new string[] { "<guid>" }, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call BatchDeleteAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.BatchDeleteAsync(new string[] { "<guid>" }, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchDeleteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; BatchDeleteAsync (System.Collections.Generic.IEnumerable&lt;string&gt; guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; BatchDeleteAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchDeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchDeleteAsync (guid As IEnumerable(Of String), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of EntityMutationResult))" />
      <MemberSignature Language="F#" Value="abstract member BatchDeleteAsync : seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;&#xA;override this.BatchDeleteAsync : seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;" Usage="entity.BatchDeleteAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> An array of GUIDs of entities to delete. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Delete a list of entities in bulk identified by their GUIDs or unique
            attributes.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <example>
This sample shows how to call BatchDeleteAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = await client.BatchDeleteAsync(new string[] { "<guid>" });
]]></code>
This sample shows how to call BatchDeleteAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = await client.BatchDeleteAsync(new string[] { "<guid>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchGetByUniqueAttributes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response BatchGetByUniqueAttributes (string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrNQualifiedName, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response BatchGetByUniqueAttributes(string typeName, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, string attrNQualifiedName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchGetByUniqueAttributes(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchGetByUniqueAttributes (typeName As String, minExtInfo As Nullable(Of Boolean), ignoreRelationships As Nullable(Of Boolean), attrNQualifiedName As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member BatchGetByUniqueAttributes : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.BatchGetByUniqueAttributes : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.BatchGetByUniqueAttributes (typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="attrNQualifiedName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="attrNQualifiedName">
             Qualified name of an entity. E.g. to find 2 entities you can set
             attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
             example. qualifiedName can be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Bulk API to retrieve list of entities identified by its unique attributes.
             In
             addition to the typeName path parameter, attribute key-value pair(s) can be
             provided in the following
             format
            
             typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
            
             NOTE:
             The attrName should be an unique attribute for the given entity-type.
             The REST
             request would look something like this
            
             GET
             /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
            
             Note:
             at least one unique attribute must be provided.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.BatchGetByUniqueAttributes(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchGetByUniqueAttributes and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.BatchGetByUniqueAttributes("<typeName>", null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call BatchGetByUniqueAttributes with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.BatchGetByUniqueAttributes("<typeName>", true, true, "<attr_N:qualifiedName>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchGetByUniqueAttributes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt; BatchGetByUniqueAttributes (string typeName, bool? minExtInfo = default, bool? ignoreRelationships = default, string attrNQualifiedName = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt; BatchGetByUniqueAttributes(string typeName, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, string attrNQualifiedName, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchGetByUniqueAttributes(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchGetByUniqueAttributes (typeName As String, Optional minExtInfo As Nullable(Of Boolean) = Nothing, Optional ignoreRelationships As Nullable(Of Boolean) = Nothing, Optional attrNQualifiedName As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEntitiesWithExtInfo)" />
      <MemberSignature Language="F#" Value="abstract member BatchGetByUniqueAttributes : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&#xA;override this.BatchGetByUniqueAttributes : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;" Usage="entity.BatchGetByUniqueAttributes (typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="attrNQualifiedName" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="attrNQualifiedName">
             Qualified name of an entity. E.g. to find 2 entities you can set
             attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
             example. qualifiedName can be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Bulk API to retrieve list of entities identified by its unique attributes.
             In
             addition to the typeName path parameter, attribute key-value pair(s) can be
             provided in the following
             format
            
             typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
            
             NOTE:
             The attrName should be an unique attribute for the given entity-type.
             The REST
             request would look something like this
            
             GET
             /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
            
             Note:
             at least one unique attribute must be provided.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call BatchGetByUniqueAttributes.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntitiesWithExtInfo> response = client.BatchGetByUniqueAttributes("<typeName>");
]]></code>
This sample shows how to call BatchGetByUniqueAttributes with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntitiesWithExtInfo> response = client.BatchGetByUniqueAttributes("<typeName>", minExtInfo: true, ignoreRelationships: true, attrNQualifiedName: "<attr_N:qualifiedName>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchGetByUniqueAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; BatchGetByUniqueAttributesAsync (string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrNQualifiedName, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; BatchGetByUniqueAttributesAsync(string typeName, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, string attrNQualifiedName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchGetByUniqueAttributesAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchGetByUniqueAttributesAsync (typeName As String, minExtInfo As Nullable(Of Boolean), ignoreRelationships As Nullable(Of Boolean), attrNQualifiedName As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member BatchGetByUniqueAttributesAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.BatchGetByUniqueAttributesAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.BatchGetByUniqueAttributesAsync (typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="attrNQualifiedName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="attrNQualifiedName">
             Qualified name of an entity. E.g. to find 2 entities you can set
             attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
             example. qualifiedName can be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Bulk API to retrieve list of entities identified by its unique attributes.
             In
             addition to the typeName path parameter, attribute key-value pair(s) can be
             provided in the following
             format
            
             typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
            
             NOTE:
             The attrName should be an unique attribute for the given entity-type.
             The REST
             request would look something like this
            
             GET
             /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
            
             Note:
             at least one unique attribute must be provided.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.BatchGetByUniqueAttributesAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchGetByUniqueAttributesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.BatchGetByUniqueAttributesAsync("<typeName>", null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call BatchGetByUniqueAttributesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.BatchGetByUniqueAttributesAsync("<typeName>", true, true, "<attr_N:qualifiedName>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchGetByUniqueAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt; BatchGetByUniqueAttributesAsync (string typeName, bool? minExtInfo = default, bool? ignoreRelationships = default, string attrNQualifiedName = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt; BatchGetByUniqueAttributesAsync(string typeName, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, string attrNQualifiedName, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchGetByUniqueAttributesAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchGetByUniqueAttributesAsync (typeName As String, Optional minExtInfo As Nullable(Of Boolean) = Nothing, Optional ignoreRelationships As Nullable(Of Boolean) = Nothing, Optional attrNQualifiedName As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEntitiesWithExtInfo))" />
      <MemberSignature Language="F#" Value="abstract member BatchGetByUniqueAttributesAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt;&#xA;override this.BatchGetByUniqueAttributesAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt;" Usage="entity.BatchGetByUniqueAttributesAsync (typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="attrNQualifiedName" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="attrNQualifiedName">
             Qualified name of an entity. E.g. to find 2 entities you can set
             attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
             example. qualifiedName can be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Bulk API to retrieve list of entities identified by its unique attributes.
             In
             addition to the typeName path parameter, attribute key-value pair(s) can be
             provided in the following
             format
            
             typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
            
             NOTE:
             The attrName should be an unique attribute for the given entity-type.
             The REST
             request would look something like this
            
             GET
             /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
            
             Note:
             at least one unique attribute must be provided.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call BatchGetByUniqueAttributesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntitiesWithExtInfo> response = await client.BatchGetByUniqueAttributesAsync("<typeName>");
]]></code>
This sample shows how to call BatchGetByUniqueAttributesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntitiesWithExtInfo> response = await client.BatchGetByUniqueAttributesAsync("<typeName>", minExtInfo: true, ignoreRelationships: true, attrNQualifiedName: "<attr_N:qualifiedName>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchSetClassifications">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;string&gt;&gt; BatchSetClassifications (Azure.Analytics.Purview.DataMap.AtlasEntityHeaders atlasEntityHeaders, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class System.Collections.Generic.IReadOnlyList`1&lt;string&gt;&gt; BatchSetClassifications(class Azure.Analytics.Purview.DataMap.AtlasEntityHeaders atlasEntityHeaders, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchSetClassifications(Azure.Analytics.Purview.DataMap.AtlasEntityHeaders,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchSetClassifications (atlasEntityHeaders As AtlasEntityHeaders, Optional cancellationToken As CancellationToken = Nothing) As Response(Of IReadOnlyList(Of String))" />
      <MemberSignature Language="F#" Value="abstract member BatchSetClassifications : Azure.Analytics.Purview.DataMap.AtlasEntityHeaders * System.Threading.CancellationToken -&gt; Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;string&gt;&gt;&#xA;override this.BatchSetClassifications : Azure.Analytics.Purview.DataMap.AtlasEntityHeaders * System.Threading.CancellationToken -&gt; Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;string&gt;&gt;" Usage="entity.BatchSetClassifications (atlasEntityHeaders, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;System.String&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atlasEntityHeaders" Type="Azure.Analytics.Purview.DataMap.AtlasEntityHeaders" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="atlasEntityHeaders"> An instance of an entity header map. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Set classifications on entities in bulk. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="atlasEntityHeaders" /> is null. </exception>
        <example>
This sample shows how to call BatchSetClassifications.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityHeaders atlasEntityHeaders = new AtlasEntityHeaders();
Response<IReadOnlyList<string>> response = client.BatchSetClassifications(atlasEntityHeaders);
]]></code>
This sample shows how to call BatchSetClassifications with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityHeaders atlasEntityHeaders = new AtlasEntityHeaders
{
    GuidHeaderMap =
    {
        ["key"] = new AtlasEntityHeader
        {
            Attributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            TypeName = "<typeName>",
            LastModifiedTS = "<lastModifiedTS>",
            ClassificationNames = {"<classificationNames>"},
            Classifications = {new AtlasClassification
            {
                Attributes =
                {
                    ["key"] = BinaryData.FromObjectAsJson(new object())
                },
                TypeName = "<typeName>",
                LastModifiedTS = "<lastModifiedTS>",
                EntityGuid = "<entityGuid>",
                EntityStatus = EntityStatus.Active,
                RemovePropagationsOnEntityDelete = true,
                ValidityPeriods = {new TimeBoundary
                {
                    EndTime = "<endTime>",
                    StartTime = "<startTime>",
                    TimeZone = "<timeZone>",
                }},
            }},
            DisplayText = "<displayText>",
            Guid = "<guid>",
            IsIncomplete = true,
            Labels = {"<labels>"},
            MeaningNames = {"<meaningNames>"},
            Meanings = {new AtlasTermAssignmentHeader
            {
                Confidence = 1234,
                CreatedBy = "<createdBy>",
                Description = "<description>",
                DisplayText = "<displayText>",
                Expression = "<expression>",
                RelationGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
                Status = AtlasTermAssignmentStatus.Discovered,
                Steward = "<steward>",
                TermGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
            }},
            Status = EntityStatus.Active,
        }
    },
};
Response<IReadOnlyList<string>> response = client.BatchSetClassifications(atlasEntityHeaders);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchSetClassifications">
      <MemberSignature Language="C#" Value="public virtual Azure.Response BatchSetClassifications (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response BatchSetClassifications(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchSetClassifications(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchSetClassifications (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member BatchSetClassifications : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.BatchSetClassifications : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.BatchSetClassifications (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Set classifications on entities in bulk.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.BatchSetClassifications(Azure.Analytics.Purview.DataMap.AtlasEntityHeaders,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchSetClassifications and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = client.BatchSetClassifications(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code>
This sample shows how to call BatchSetClassifications with all request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    guidHeaderMap = new
    {
        key = new
        {
            attributes = new
            {
                key = new object(),
            },
            typeName = "<typeName>",
            lastModifiedTS = "<lastModifiedTS>",
            classificationNames = new object[]
            {
                "<classificationNames>"
            },
            classifications = new object[]
            {
                new
                {
                    attributes = new
                    {
                        key = new object(),
                    },
                    typeName = "<typeName>",
                    lastModifiedTS = "<lastModifiedTS>",
                    entityGuid = "<entityGuid>",
                    entityStatus = "ACTIVE",
                    removePropagationsOnEntityDelete = true,
                    validityPeriods = new object[]
                    {
                        new
                        {
                            endTime = "<endTime>",
                            startTime = "<startTime>",
                            timeZone = "<timeZone>",
                        }
                    },
                }
            },
            displayText = "<displayText>",
            guid = "<guid>",
            isIncomplete = true,
            labels = new object[]
            {
                "<labels>"
            },
            meaningNames = new object[]
            {
                "<meaningNames>"
            },
            meanings = new object[]
            {
                new
                {
                    confidence = 1234,
                    createdBy = "<createdBy>",
                    description = "<description>",
                    displayText = "<displayText>",
                    expression = "<expression>",
                    relationGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                    status = "DISCOVERED",
                    steward = "<steward>",
                    termGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                }
            },
            status = "ACTIVE",
        },
    },
});
Response response = client.BatchSetClassifications(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchSetClassificationsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;string&gt;&gt;&gt; BatchSetClassificationsAsync (Azure.Analytics.Purview.DataMap.AtlasEntityHeaders atlasEntityHeaders, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class System.Collections.Generic.IReadOnlyList`1&lt;string&gt;&gt;&gt; BatchSetClassificationsAsync(class Azure.Analytics.Purview.DataMap.AtlasEntityHeaders atlasEntityHeaders, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchSetClassificationsAsync(Azure.Analytics.Purview.DataMap.AtlasEntityHeaders,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchSetClassificationsAsync (atlasEntityHeaders As AtlasEntityHeaders, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of IReadOnlyList(Of String)))" />
      <MemberSignature Language="F#" Value="abstract member BatchSetClassificationsAsync : Azure.Analytics.Purview.DataMap.AtlasEntityHeaders * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;string&gt;&gt;&gt;&#xA;override this.BatchSetClassificationsAsync : Azure.Analytics.Purview.DataMap.AtlasEntityHeaders * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;string&gt;&gt;&gt;" Usage="entity.BatchSetClassificationsAsync (atlasEntityHeaders, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Collections.Generic.IReadOnlyList&lt;System.String&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atlasEntityHeaders" Type="Azure.Analytics.Purview.DataMap.AtlasEntityHeaders" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="atlasEntityHeaders"> An instance of an entity header map. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Set classifications on entities in bulk. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="atlasEntityHeaders" /> is null. </exception>
        <example>
This sample shows how to call BatchSetClassificationsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityHeaders atlasEntityHeaders = new AtlasEntityHeaders();
Response<IReadOnlyList<string>> response = await client.BatchSetClassificationsAsync(atlasEntityHeaders);
]]></code>
This sample shows how to call BatchSetClassificationsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityHeaders atlasEntityHeaders = new AtlasEntityHeaders
{
    GuidHeaderMap =
    {
        ["key"] = new AtlasEntityHeader
        {
            Attributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            TypeName = "<typeName>",
            LastModifiedTS = "<lastModifiedTS>",
            ClassificationNames = {"<classificationNames>"},
            Classifications = {new AtlasClassification
            {
                Attributes =
                {
                    ["key"] = BinaryData.FromObjectAsJson(new object())
                },
                TypeName = "<typeName>",
                LastModifiedTS = "<lastModifiedTS>",
                EntityGuid = "<entityGuid>",
                EntityStatus = EntityStatus.Active,
                RemovePropagationsOnEntityDelete = true,
                ValidityPeriods = {new TimeBoundary
                {
                    EndTime = "<endTime>",
                    StartTime = "<startTime>",
                    TimeZone = "<timeZone>",
                }},
            }},
            DisplayText = "<displayText>",
            Guid = "<guid>",
            IsIncomplete = true,
            Labels = {"<labels>"},
            MeaningNames = {"<meaningNames>"},
            Meanings = {new AtlasTermAssignmentHeader
            {
                Confidence = 1234,
                CreatedBy = "<createdBy>",
                Description = "<description>",
                DisplayText = "<displayText>",
                Expression = "<expression>",
                RelationGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
                Status = AtlasTermAssignmentStatus.Discovered,
                Steward = "<steward>",
                TermGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
            }},
            Status = EntityStatus.Active,
        }
    },
};
Response<IReadOnlyList<string>> response = await client.BatchSetClassificationsAsync(atlasEntityHeaders);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="BatchSetClassificationsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; BatchSetClassificationsAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; BatchSetClassificationsAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.BatchSetClassificationsAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BatchSetClassificationsAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member BatchSetClassificationsAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.BatchSetClassificationsAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.BatchSetClassificationsAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Set classifications on entities in bulk.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.BatchSetClassificationsAsync(Azure.Analytics.Purview.DataMap.AtlasEntityHeaders,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call BatchSetClassificationsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = await client.BatchSetClassificationsAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code>
This sample shows how to call BatchSetClassificationsAsync with all request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    guidHeaderMap = new
    {
        key = new
        {
            attributes = new
            {
                key = new object(),
            },
            typeName = "<typeName>",
            lastModifiedTS = "<lastModifiedTS>",
            classificationNames = new object[]
            {
                "<classificationNames>"
            },
            classifications = new object[]
            {
                new
                {
                    attributes = new
                    {
                        key = new object(),
                    },
                    typeName = "<typeName>",
                    lastModifiedTS = "<lastModifiedTS>",
                    entityGuid = "<entityGuid>",
                    entityStatus = "ACTIVE",
                    removePropagationsOnEntityDelete = true,
                    validityPeriods = new object[]
                    {
                        new
                        {
                            endTime = "<endTime>",
                            startTime = "<startTime>",
                            timeZone = "<timeZone>",
                        }
                    },
                }
            },
            displayText = "<displayText>",
            guid = "<guid>",
            isIncomplete = true,
            labels = new object[]
            {
                "<labels>"
            },
            meaningNames = new object[]
            {
                "<meaningNames>"
            },
            meanings = new object[]
            {
                new
                {
                    confidence = 1234,
                    createdBy = "<createdBy>",
                    description = "<description>",
                    displayText = "<displayText>",
                    expression = "<expression>",
                    relationGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                    status = "DISCOVERED",
                    steward = "<steward>",
                    termGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                }
            },
            status = "ACTIVE",
        },
    },
});
Response response = await client.BatchSetClassificationsAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; CreateOrUpdate (Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo atlasEntityWithExtInfo, Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = default, string collectionId = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; CreateOrUpdate(class Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo atlasEntityWithExtInfo, valuetype System.Nullable`1&lt;valuetype Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; businessAttributeUpdateBehavior, string collectionId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.CreateOrUpdate(Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo,System.Nullable{Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdate (atlasEntityWithExtInfo As AtlasEntityWithExtInfo, Optional businessAttributeUpdateBehavior As Nullable(Of BusinessAttributeUpdateBehavior) = Nothing, Optional collectionId As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of EntityMutationResult)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdate : Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo * Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&#xA;override this.CreateOrUpdate : Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo * Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;" Usage="entity.CreateOrUpdate (atlasEntityWithExtInfo, businessAttributeUpdateBehavior, collectionId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atlasEntityWithExtInfo" Type="Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo" />
        <Parameter Name="businessAttributeUpdateBehavior" Type="System.Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt;" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="atlasEntityWithExtInfo">
            An instance of an entity along with extended info - like hive_table,
            hive_database.
            </param>
        <param name="businessAttributeUpdateBehavior">
            Used to define the update behavior for business attributes when updating
            entities.
            </param>
        <param name="collectionId">
            The collection where entities will be moved to. Only specify a value if you
            need to move an entity to another collection.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Create or update an entity.
            Existing entity is matched using its unique guid if
            supplied or by its unique attributes eg: qualifiedName.
            Map and array of
            collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
            int&gt;&gt;.
            For each contact type, the maximum number of contacts is 20.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="atlasEntityWithExtInfo" /> is null. </exception>
        <example>
This sample shows how to call CreateOrUpdate.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityWithExtInfo atlasEntityWithExtInfo = new AtlasEntityWithExtInfo();
Response<EntityMutationResult> response = client.CreateOrUpdate(atlasEntityWithExtInfo);
]]></code>
This sample shows how to call CreateOrUpdate with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

AtlasEntityWithExtInfo atlasEntityWithExtInfo = new AtlasEntityWithExtInfo
{
    ReferredEntities =
    {
        ["key"] = new AtlasEntity
        {
            Attributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            TypeName = "<typeName>",
            LastModifiedTS = "<lastModifiedTS>",
            BusinessAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Classifications = {new AtlasClassification
            {
                Attributes =
                {
                    ["key"] = BinaryData.FromObjectAsJson(new object())
                },
                TypeName = "<typeName>",
                LastModifiedTS = "<lastModifiedTS>",
                EntityGuid = "<entityGuid>",
                EntityStatus = EntityStatus.Active,
                RemovePropagationsOnEntityDelete = true,
                ValidityPeriods = {new TimeBoundary
                {
                    EndTime = "<endTime>",
                    StartTime = "<startTime>",
                    TimeZone = "<timeZone>",
                }},
            }},
            CreateTime = 1234L,
            CreatedBy = "<createdBy>",
            CustomAttributes =
            {
                ["key"] = "<customAttributes>"
            },
            Guid = "<guid>",
            HomeId = "<homeId>",
            IsIncomplete = true,
            Labels = {"<labels>"},
            Meanings = {new AtlasTermAssignmentHeader
            {
                Confidence = 1234,
                CreatedBy = "<createdBy>",
                Description = "<description>",
                DisplayText = "<displayText>",
                Expression = "<expression>",
                RelationGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
                Status = AtlasTermAssignmentStatus.Discovered,
                Steward = "<steward>",
                TermGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
            }},
            ProvenanceType = 1234,
            Proxy = true,
            RelationshipAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Status = EntityStatus.Active,
            UpdateTime = 1234L,
            UpdatedBy = "<updatedBy>",
            Version = 1234L,
            Contacts =
            {
                ["key"] = {new ContactInfo
                {
                    Id = "<id>",
                    Info = "<info>",
                }}
            },
        }
    },
    Entity = default,
};
Response<EntityMutationResult> response = client.CreateOrUpdate(atlasEntityWithExtInfo, businessAttributeUpdateBehavior: BusinessAttributeUpdateBehavior.Ignore, collectionId: "<collectionId>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdate (Azure.Core.RequestContent content, string businessAttributeUpdateBehavior = default, string collectionId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdate(class Azure.Core.RequestContent content, string businessAttributeUpdateBehavior, string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.CreateOrUpdate(Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdate (content As RequestContent, Optional businessAttributeUpdateBehavior As String = Nothing, Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdate : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdate : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.CreateOrUpdate (content, businessAttributeUpdateBehavior, collectionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="businessAttributeUpdateBehavior" Type="System.String" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="businessAttributeUpdateBehavior">
            Used to define the update behavior for business attributes when updating
            entities. Allowed values: "ignore" | "replace" | "merge"
            </param>
        <param name="collectionId">
            The collection where entities will be moved to. Only specify a value if you
            need to move an entity to another collection.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Create or update an entity.
            Existing entity is matched using its unique guid if
            supplied or by its unique attributes eg: qualifiedName.
            Map and array of
            collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
            int&gt;&gt;.
            For each contact type, the maximum number of contacts is 20.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.CreateOrUpdate(Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo,System.Nullable{Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdate and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = client.CreateOrUpdate(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdate with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

using RequestContent content = RequestContent.Create(new
{
    referredEntities = new
    {
        key = new
        {
            attributes = new
            {
                key = new object(),
            },
            typeName = "<typeName>",
            lastModifiedTS = "<lastModifiedTS>",
            businessAttributes = new
            {
                key = new object(),
            },
            classifications = new object[]
            {
                new
                {
                    attributes = new
                    {
                        key = new object(),
                    },
                    typeName = "<typeName>",
                    lastModifiedTS = "<lastModifiedTS>",
                    entityGuid = "<entityGuid>",
                    entityStatus = "ACTIVE",
                    removePropagationsOnEntityDelete = true,
                    validityPeriods = new object[]
                    {
                        new
                        {
                            endTime = "<endTime>",
                            startTime = "<startTime>",
                            timeZone = "<timeZone>",
                        }
                    },
                }
            },
            createTime = 1234L,
            createdBy = "<createdBy>",
            customAttributes = new
            {
                key = "<customAttributes>",
            },
            guid = "<guid>",
            homeId = "<homeId>",
            isIncomplete = true,
            labels = new object[]
            {
                "<labels>"
            },
            meanings = new object[]
            {
                new
                {
                    confidence = 1234,
                    createdBy = "<createdBy>",
                    description = "<description>",
                    displayText = "<displayText>",
                    expression = "<expression>",
                    relationGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                    status = "DISCOVERED",
                    steward = "<steward>",
                    termGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                }
            },
            provenanceType = 1234,
            proxy = true,
            relationshipAttributes = new
            {
                key = new object(),
            },
            status = "ACTIVE",
            updateTime = 1234L,
            updatedBy = "<updatedBy>",
            version = 1234L,
            contacts = new
            {
                key = new object[]
                {
                    new
                    {
                        id = "<id>",
                        info = "<info>",
                    }
                },
            },
        },
    },
});
Response response = client.CreateOrUpdate(content, businessAttributeUpdateBehavior: "ignore", collectionId: "<collectionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; CreateOrUpdateAsync (Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo atlasEntityWithExtInfo, Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = default, string collectionId = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; CreateOrUpdateAsync(class Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo atlasEntityWithExtInfo, valuetype System.Nullable`1&lt;valuetype Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; businessAttributeUpdateBehavior, string collectionId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.CreateOrUpdateAsync(Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo,System.Nullable{Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateAsync (atlasEntityWithExtInfo As AtlasEntityWithExtInfo, Optional businessAttributeUpdateBehavior As Nullable(Of BusinessAttributeUpdateBehavior) = Nothing, Optional collectionId As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of EntityMutationResult))" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateAsync : Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo * Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;&#xA;override this.CreateOrUpdateAsync : Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo * Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;" Usage="entity.CreateOrUpdateAsync (atlasEntityWithExtInfo, businessAttributeUpdateBehavior, collectionId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atlasEntityWithExtInfo" Type="Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo" />
        <Parameter Name="businessAttributeUpdateBehavior" Type="System.Nullable&lt;Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior&gt;" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="atlasEntityWithExtInfo">
            An instance of an entity along with extended info - like hive_table,
            hive_database.
            </param>
        <param name="businessAttributeUpdateBehavior">
            Used to define the update behavior for business attributes when updating
            entities.
            </param>
        <param name="collectionId">
            The collection where entities will be moved to. Only specify a value if you
            need to move an entity to another collection.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Create or update an entity.
            Existing entity is matched using its unique guid if
            supplied or by its unique attributes eg: qualifiedName.
            Map and array of
            collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
            int&gt;&gt;.
            For each contact type, the maximum number of contacts is 20.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="atlasEntityWithExtInfo" /> is null. </exception>
        <example>
This sample shows how to call CreateOrUpdateAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityWithExtInfo atlasEntityWithExtInfo = new AtlasEntityWithExtInfo();
Response<EntityMutationResult> response = await client.CreateOrUpdateAsync(atlasEntityWithExtInfo);
]]></code>
This sample shows how to call CreateOrUpdateAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

AtlasEntityWithExtInfo atlasEntityWithExtInfo = new AtlasEntityWithExtInfo
{
    ReferredEntities =
    {
        ["key"] = new AtlasEntity
        {
            Attributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            TypeName = "<typeName>",
            LastModifiedTS = "<lastModifiedTS>",
            BusinessAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Classifications = {new AtlasClassification
            {
                Attributes =
                {
                    ["key"] = BinaryData.FromObjectAsJson(new object())
                },
                TypeName = "<typeName>",
                LastModifiedTS = "<lastModifiedTS>",
                EntityGuid = "<entityGuid>",
                EntityStatus = EntityStatus.Active,
                RemovePropagationsOnEntityDelete = true,
                ValidityPeriods = {new TimeBoundary
                {
                    EndTime = "<endTime>",
                    StartTime = "<startTime>",
                    TimeZone = "<timeZone>",
                }},
            }},
            CreateTime = 1234L,
            CreatedBy = "<createdBy>",
            CustomAttributes =
            {
                ["key"] = "<customAttributes>"
            },
            Guid = "<guid>",
            HomeId = "<homeId>",
            IsIncomplete = true,
            Labels = {"<labels>"},
            Meanings = {new AtlasTermAssignmentHeader
            {
                Confidence = 1234,
                CreatedBy = "<createdBy>",
                Description = "<description>",
                DisplayText = "<displayText>",
                Expression = "<expression>",
                RelationGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
                Status = AtlasTermAssignmentStatus.Discovered,
                Steward = "<steward>",
                TermGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
            }},
            ProvenanceType = 1234,
            Proxy = true,
            RelationshipAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Status = EntityStatus.Active,
            UpdateTime = 1234L,
            UpdatedBy = "<updatedBy>",
            Version = 1234L,
            Contacts =
            {
                ["key"] = {new ContactInfo
                {
                    Id = "<id>",
                    Info = "<info>",
                }}
            },
        }
    },
    Entity = default,
};
Response<EntityMutationResult> response = await client.CreateOrUpdateAsync(atlasEntityWithExtInfo, businessAttributeUpdateBehavior: BusinessAttributeUpdateBehavior.Ignore, collectionId: "<collectionId>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateAsync (Azure.Core.RequestContent content, string businessAttributeUpdateBehavior = default, string collectionId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateAsync(class Azure.Core.RequestContent content, string businessAttributeUpdateBehavior, string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.CreateOrUpdateAsync(Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateAsync (content As RequestContent, Optional businessAttributeUpdateBehavior As String = Nothing, Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateAsync : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateAsync : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.CreateOrUpdateAsync (content, businessAttributeUpdateBehavior, collectionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="businessAttributeUpdateBehavior" Type="System.String" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="businessAttributeUpdateBehavior">
            Used to define the update behavior for business attributes when updating
            entities. Allowed values: "ignore" | "replace" | "merge"
            </param>
        <param name="collectionId">
            The collection where entities will be moved to. Only specify a value if you
            need to move an entity to another collection.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Create or update an entity.
            Existing entity is matched using its unique guid if
            supplied or by its unique attributes eg: qualifiedName.
            Map and array of
            collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
            int&gt;&gt;.
            For each contact type, the maximum number of contacts is 20.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.CreateOrUpdateAsync(Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo,System.Nullable{Azure.Analytics.Purview.DataMap.BusinessAttributeUpdateBehavior},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = await client.CreateOrUpdateAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

using RequestContent content = RequestContent.Create(new
{
    referredEntities = new
    {
        key = new
        {
            attributes = new
            {
                key = new object(),
            },
            typeName = "<typeName>",
            lastModifiedTS = "<lastModifiedTS>",
            businessAttributes = new
            {
                key = new object(),
            },
            classifications = new object[]
            {
                new
                {
                    attributes = new
                    {
                        key = new object(),
                    },
                    typeName = "<typeName>",
                    lastModifiedTS = "<lastModifiedTS>",
                    entityGuid = "<entityGuid>",
                    entityStatus = "ACTIVE",
                    removePropagationsOnEntityDelete = true,
                    validityPeriods = new object[]
                    {
                        new
                        {
                            endTime = "<endTime>",
                            startTime = "<startTime>",
                            timeZone = "<timeZone>",
                        }
                    },
                }
            },
            createTime = 1234L,
            createdBy = "<createdBy>",
            customAttributes = new
            {
                key = "<customAttributes>",
            },
            guid = "<guid>",
            homeId = "<homeId>",
            isIncomplete = true,
            labels = new object[]
            {
                "<labels>"
            },
            meanings = new object[]
            {
                new
                {
                    confidence = 1234,
                    createdBy = "<createdBy>",
                    description = "<description>",
                    displayText = "<displayText>",
                    expression = "<expression>",
                    relationGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                    status = "DISCOVERED",
                    steward = "<steward>",
                    termGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                }
            },
            provenanceType = 1234,
            proxy = true,
            relationshipAttributes = new
            {
                key = new object(),
            },
            status = "ACTIVE",
            updateTime = 1234L,
            updatedBy = "<updatedBy>",
            version = 1234L,
            contacts = new
            {
                key = new object[]
                {
                    new
                    {
                        id = "<id>",
                        info = "<info>",
                    }
                },
            },
        },
    },
});
Response response = await client.CreateOrUpdateAsync(content, businessAttributeUpdateBehavior: "ignore", collectionId: "<collectionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public virtual Azure.Response Delete (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response Delete(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.Delete(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Delete (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member Delete : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.Delete : string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.Delete (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete an entity identified by its GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.Delete(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call Delete and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.Delete("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call Delete with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.Delete("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; Delete (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; Delete(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.Delete(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Delete (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of EntityMutationResult)" />
      <MemberSignature Language="F#" Value="abstract member Delete : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&#xA;override this.Delete : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;" Usage="entity.Delete (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Delete an entity identified by its GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call Delete.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = client.Delete("<guid>");
]]></code>
This sample shows how to call Delete with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = client.Delete("<guid>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.DeleteAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.DeleteAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete an entity identified by its GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.DeleteAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.DeleteAsync("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call DeleteAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.DeleteAsync("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; DeleteAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; DeleteAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.DeleteAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of EntityMutationResult))" />
      <MemberSignature Language="F#" Value="abstract member DeleteAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;&#xA;override this.DeleteAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;" Usage="entity.DeleteAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Delete an entity identified by its GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call DeleteAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = await client.DeleteAsync("<guid>");
]]></code>
This sample shows how to call DeleteAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = await client.DeleteAsync("<guid>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteByUniqueAttribute (string typeName, string attribute, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteByUniqueAttribute(string typeName, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.DeleteByUniqueAttribute(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteByUniqueAttribute (typeName As String, attribute As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteByUniqueAttribute : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteByUniqueAttribute : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.DeleteByUniqueAttribute (typeName, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Delete an entity identified by its type and unique attributes.
             In addition to
             the typeName path parameter, attribute key-value pair(s) can be provided in the
             following format:
             attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this:
             DELETE
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.DeleteByUniqueAttribute(System.String,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteByUniqueAttribute and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.DeleteByUniqueAttribute("<typeName>", null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call DeleteByUniqueAttribute with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.DeleteByUniqueAttribute("<typeName>", "<attribute>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; DeleteByUniqueAttribute (string typeName, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; DeleteByUniqueAttribute(string typeName, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.DeleteByUniqueAttribute(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteByUniqueAttribute (typeName As String, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of EntityMutationResult)" />
      <MemberSignature Language="F#" Value="abstract member DeleteByUniqueAttribute : string * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&#xA;override this.DeleteByUniqueAttribute : string * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;" Usage="entity.DeleteByUniqueAttribute (typeName, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Delete an entity identified by its type and unique attributes.
             In addition to
             the typeName path parameter, attribute key-value pair(s) can be provided in the
             following format:
             attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this:
             DELETE
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call DeleteByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = client.DeleteByUniqueAttribute("<typeName>");
]]></code>
This sample shows how to call DeleteByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = client.DeleteByUniqueAttribute("<typeName>", attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteByUniqueAttributeAsync (string typeName, string attribute, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteByUniqueAttributeAsync(string typeName, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.DeleteByUniqueAttributeAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteByUniqueAttributeAsync (typeName As String, attribute As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteByUniqueAttributeAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteByUniqueAttributeAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.DeleteByUniqueAttributeAsync (typeName, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Delete an entity identified by its type and unique attributes.
             In addition to
             the typeName path parameter, attribute key-value pair(s) can be provided in the
             following format:
             attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this:
             DELETE
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.DeleteByUniqueAttributeAsync(System.String,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteByUniqueAttributeAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.DeleteByUniqueAttributeAsync("<typeName>", null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call DeleteByUniqueAttributeAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.DeleteByUniqueAttributeAsync("<typeName>", "<attribute>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; DeleteByUniqueAttributeAsync (string typeName, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; DeleteByUniqueAttributeAsync(string typeName, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.DeleteByUniqueAttributeAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteByUniqueAttributeAsync (typeName As String, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of EntityMutationResult))" />
      <MemberSignature Language="F#" Value="abstract member DeleteByUniqueAttributeAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;&#xA;override this.DeleteByUniqueAttributeAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;" Usage="entity.DeleteByUniqueAttributeAsync (typeName, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Delete an entity identified by its type and unique attributes.
             In addition to
             the typeName path parameter, attribute key-value pair(s) can be provided in the
             following format:
             attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this:
             DELETE
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call DeleteByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = await client.DeleteByUniqueAttributeAsync("<typeName>");
]]></code>
This sample shows how to call DeleteByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = await client.DeleteByUniqueAttributeAsync("<typeName>", attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataTemplate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetBusinessMetadataTemplate (Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetBusinessMetadataTemplate(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetBusinessMetadataTemplate(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataTemplate (context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataTemplate : Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetBusinessMetadataTemplate : Azure.RequestContext -&gt; Azure.Response" Usage="entity.GetBusinessMetadataTemplate context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the sample Template for uploading/creating bulk BusinessMetaData
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetBusinessMetadataTemplate(System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetBusinessMetadataTemplate and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetBusinessMetadataTemplate(null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetBusinessMetadataTemplate with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetBusinessMetadataTemplate(null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataTemplate">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;BinaryData&gt; GetBusinessMetadataTemplate (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class System.BinaryData&gt; GetBusinessMetadataTemplate(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetBusinessMetadataTemplate(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataTemplate (Optional cancellationToken As CancellationToken = Nothing) As Response(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataTemplate : System.Threading.CancellationToken -&gt; Azure.Response&lt;BinaryData&gt;&#xA;override this.GetBusinessMetadataTemplate : System.Threading.CancellationToken -&gt; Azure.Response&lt;BinaryData&gt;" Usage="entity.GetBusinessMetadataTemplate cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the sample Template for uploading/creating bulk BusinessMetaData. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetBusinessMetadataTemplate.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<BinaryData> response = client.GetBusinessMetadataTemplate();
]]></code>
This sample shows how to call GetBusinessMetadataTemplate with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<BinaryData> response = client.GetBusinessMetadataTemplate();
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataTemplateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetBusinessMetadataTemplateAsync (Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetBusinessMetadataTemplateAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetBusinessMetadataTemplateAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataTemplateAsync (context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataTemplateAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetBusinessMetadataTemplateAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.GetBusinessMetadataTemplateAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get the sample Template for uploading/creating bulk BusinessMetaData
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetBusinessMetadataTemplateAsync(System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetBusinessMetadataTemplateAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetBusinessMetadataTemplateAsync(null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetBusinessMetadataTemplateAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetBusinessMetadataTemplateAsync(null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetBusinessMetadataTemplateAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt; GetBusinessMetadataTemplateAsync (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class System.BinaryData&gt;&gt; GetBusinessMetadataTemplateAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetBusinessMetadataTemplateAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBusinessMetadataTemplateAsync (Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BinaryData))" />
      <MemberSignature Language="F#" Value="abstract member GetBusinessMetadataTemplateAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt;&#xA;override this.GetBusinessMetadataTemplateAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt;" Usage="entity.GetBusinessMetadataTemplateAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;System.BinaryData&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get the sample Template for uploading/creating bulk BusinessMetaData. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetBusinessMetadataTemplateAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<BinaryData> response = await client.GetBusinessMetadataTemplateAsync();
]]></code>
This sample shows how to call GetBusinessMetadataTemplateAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<BinaryData> response = await client.GetBusinessMetadataTemplateAsync();
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByIds">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetByIds (System.Collections.Generic.IEnumerable&lt;string&gt; guid, bool? minExtInfo, bool? ignoreRelationships, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetByIds(class System.Collections.Generic.IEnumerable`1&lt;string&gt; guid, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetByIds(System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIds (guid As IEnumerable(Of String), minExtInfo As Nullable(Of Boolean), ignoreRelationships As Nullable(Of Boolean), context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetByIds : seq&lt;string&gt; * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetByIds : seq&lt;string&gt; * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="entity.GetByIds (guid, minExtInfo, ignoreRelationships, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> An array of GUIDs of entities to list. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List entities in bulk identified by its GUIDs.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetByIds(System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByIds and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetByIds(new string[] { "<guid>" }, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetByIds with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

Response response = client.GetByIds(new string[] { "<guid>" }, true, true, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByIds">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt; GetByIds (System.Collections.Generic.IEnumerable&lt;string&gt; guid, bool? minExtInfo = default, bool? ignoreRelationships = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt; GetByIds(class System.Collections.Generic.IEnumerable`1&lt;string&gt; guid, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetByIds(System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIds (guid As IEnumerable(Of String), Optional minExtInfo As Nullable(Of Boolean) = Nothing, Optional ignoreRelationships As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEntitiesWithExtInfo)" />
      <MemberSignature Language="F#" Value="abstract member GetByIds : seq&lt;string&gt; * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&#xA;override this.GetByIds : seq&lt;string&gt; * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;" Usage="entity.GetByIds (guid, minExtInfo, ignoreRelationships, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> An array of GUIDs of entities to list. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List entities in bulk identified by its GUIDs. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <example>
This sample shows how to call GetByIds.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntitiesWithExtInfo> response = client.GetByIds(new string[] { "<guid>" });
]]></code>
This sample shows how to call GetByIds with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

Response<AtlasEntitiesWithExtInfo> response = client.GetByIds(new string[] { "<guid>" }, minExtInfo: true, ignoreRelationships: true);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByIdsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetByIdsAsync (System.Collections.Generic.IEnumerable&lt;string&gt; guid, bool? minExtInfo, bool? ignoreRelationships, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetByIdsAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; guid, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetByIdsAsync(System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIdsAsync (guid As IEnumerable(Of String), minExtInfo As Nullable(Of Boolean), ignoreRelationships As Nullable(Of Boolean), context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetByIdsAsync : seq&lt;string&gt; * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetByIdsAsync : seq&lt;string&gt; * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.GetByIdsAsync (guid, minExtInfo, ignoreRelationships, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> An array of GUIDs of entities to list. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List entities in bulk identified by its GUIDs.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetByIdsAsync(System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByIdsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetByIdsAsync(new string[] { "<guid>" }, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetByIdsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

Response response = await client.GetByIdsAsync(new string[] { "<guid>" }, true, true, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entities")[0].GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByIdsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt; GetByIdsAsync (System.Collections.Generic.IEnumerable&lt;string&gt; guid, bool? minExtInfo = default, bool? ignoreRelationships = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt; GetByIdsAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; guid, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetByIdsAsync(System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIdsAsync (guid As IEnumerable(Of String), Optional minExtInfo As Nullable(Of Boolean) = Nothing, Optional ignoreRelationships As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEntitiesWithExtInfo))" />
      <MemberSignature Language="F#" Value="abstract member GetByIdsAsync : seq&lt;string&gt; * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt;&#xA;override this.GetByIdsAsync : seq&lt;string&gt; * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt;" Usage="entity.GetByIdsAsync (guid, minExtInfo, ignoreRelationships, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntitiesWithExtInfo&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> An array of GUIDs of entities to list. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List entities in bulk identified by its GUIDs. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <example>
This sample shows how to call GetByIdsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntitiesWithExtInfo> response = await client.GetByIdsAsync(new string[] { "<guid>" });
]]></code>
This sample shows how to call GetByIdsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

Response<AtlasEntitiesWithExtInfo> response = await client.GetByIdsAsync(new string[] { "<guid>" }, minExtInfo: true, ignoreRelationships: true);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetByUniqueAttribute (string typeName, bool? minExtInfo, bool? ignoreRelationships, string attribute, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetByUniqueAttribute(string typeName, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetByUniqueAttribute(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByUniqueAttribute (typeName As String, minExtInfo As Nullable(Of Boolean), ignoreRelationships As Nullable(Of Boolean), attribute As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetByUniqueAttribute : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetByUniqueAttribute : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.GetByUniqueAttribute (typeName, minExtInfo, ignoreRelationships, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Get complete definition of an entity given its type and unique attribute.
            
             In
             addition to the typeName path parameter, attribute key-value pair(s) can be
             provided in the following format:
             attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The
             attrName and attrValue should be unique across entities, eg.
             qualifiedName.
            
             The REST request would look something like this:
             GET
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetByUniqueAttribute(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByUniqueAttribute and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetByUniqueAttribute("<typeName>", null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetByUniqueAttribute with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetByUniqueAttribute("<typeName>", true, true, "<attribute>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt; GetByUniqueAttribute (string typeName, bool? minExtInfo = default, bool? ignoreRelationships = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt; GetByUniqueAttribute(string typeName, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetByUniqueAttribute(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByUniqueAttribute (typeName As String, Optional minExtInfo As Nullable(Of Boolean) = Nothing, Optional ignoreRelationships As Nullable(Of Boolean) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEntityWithExtInfo)" />
      <MemberSignature Language="F#" Value="abstract member GetByUniqueAttribute : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&#xA;override this.GetByUniqueAttribute : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;" Usage="entity.GetByUniqueAttribute (typeName, minExtInfo, ignoreRelationships, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Get complete definition of an entity given its type and unique attribute.
            
             In
             addition to the typeName path parameter, attribute key-value pair(s) can be
             provided in the following format:
             attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The
             attrName and attrValue should be unique across entities, eg.
             qualifiedName.
            
             The REST request would look something like this:
             GET
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityWithExtInfo> response = client.GetByUniqueAttribute("<typeName>");
]]></code>
This sample shows how to call GetByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityWithExtInfo> response = client.GetByUniqueAttribute("<typeName>", minExtInfo: true, ignoreRelationships: true, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetByUniqueAttributeAsync (string typeName, bool? minExtInfo, bool? ignoreRelationships, string attribute, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetByUniqueAttributeAsync(string typeName, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetByUniqueAttributeAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByUniqueAttributeAsync (typeName As String, minExtInfo As Nullable(Of Boolean), ignoreRelationships As Nullable(Of Boolean), attribute As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetByUniqueAttributeAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetByUniqueAttributeAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.GetByUniqueAttributeAsync (typeName, minExtInfo, ignoreRelationships, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Get complete definition of an entity given its type and unique attribute.
            
             In
             addition to the typeName path parameter, attribute key-value pair(s) can be
             provided in the following format:
             attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The
             attrName and attrValue should be unique across entities, eg.
             qualifiedName.
            
             The REST request would look something like this:
             GET
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetByUniqueAttributeAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetByUniqueAttributeAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetByUniqueAttributeAsync("<typeName>", null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetByUniqueAttributeAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetByUniqueAttributeAsync("<typeName>", true, true, "<attribute>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt; GetByUniqueAttributeAsync (string typeName, bool? minExtInfo = default, bool? ignoreRelationships = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt; GetByUniqueAttributeAsync(string typeName, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetByUniqueAttributeAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByUniqueAttributeAsync (typeName As String, Optional minExtInfo As Nullable(Of Boolean) = Nothing, Optional ignoreRelationships As Nullable(Of Boolean) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEntityWithExtInfo))" />
      <MemberSignature Language="F#" Value="abstract member GetByUniqueAttributeAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt;&#xA;override this.GetByUniqueAttributeAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt;" Usage="entity.GetByUniqueAttributeAsync (typeName, minExtInfo, ignoreRelationships, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Get complete definition of an entity given its type and unique attribute.
            
             In
             addition to the typeName path parameter, attribute key-value pair(s) can be
             provided in the following format:
             attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The
             attrName and attrValue should be unique across entities, eg.
             qualifiedName.
            
             The REST request would look something like this:
             GET
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityWithExtInfo> response = await client.GetByUniqueAttributeAsync("<typeName>");
]]></code>
This sample shows how to call GetByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityWithExtInfo> response = await client.GetByUniqueAttributeAsync("<typeName>", minExtInfo: true, ignoreRelationships: true, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassification">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetClassification (string guid, string classificationName, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetClassification(string guid, string classificationName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetClassification(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassification (guid As String, classificationName As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetClassification : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetClassification : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.GetClassification (guid, classificationName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="classificationName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="classificationName"> The name of the classification. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get classification for a given entity represented by a GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetClassification(System.String,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetClassification and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetClassification("<guid>", "<classificationName>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetClassification with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetClassification("<guid>", "<classificationName>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassification">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; GetClassification (string guid, string classificationName, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; GetClassification(string guid, string classificationName, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetClassification(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassification (guid As String, classificationName As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasClassification)" />
      <MemberSignature Language="F#" Value="abstract member GetClassification : string * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;&#xA;override this.GetClassification : string * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" Usage="entity.GetClassification (guid, classificationName, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="classificationName" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="classificationName"> The name of the classification. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get classification for a given entity represented by a GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetClassification.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasClassification> response = client.GetClassification("<guid>", "<classificationName>");
]]></code>
This sample shows how to call GetClassification with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasClassification> response = client.GetClassification("<guid>", "<classificationName>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetClassificationAsync (string guid, string classificationName, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetClassificationAsync(string guid, string classificationName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetClassificationAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationAsync (guid As String, classificationName As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetClassificationAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.GetClassificationAsync (guid, classificationName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="classificationName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="classificationName"> The name of the classification. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get classification for a given entity represented by a GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetClassificationAsync(System.String,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetClassificationAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetClassificationAsync("<guid>", "<classificationName>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetClassificationAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetClassificationAsync("<guid>", "<classificationName>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;&gt; GetClassificationAsync (string guid, string classificationName, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt;&gt; GetClassificationAsync(string guid, string classificationName, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetClassificationAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationAsync (guid As String, classificationName As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasClassification))" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;&gt;&#xA;override this.GetClassificationAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;&gt;" Usage="entity.GetClassificationAsync (guid, classificationName, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="classificationName" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="classificationName"> The name of the classification. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get classification for a given entity represented by a GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetClassificationAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasClassification> response = await client.GetClassificationAsync("<guid>", "<classificationName>");
]]></code>
This sample shows how to call GetClassificationAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasClassification> response = await client.GetClassificationAsync("<guid>", "<classificationName>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassifications">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetClassifications (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetClassifications(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetClassifications(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassifications (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetClassifications : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetClassifications : string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.GetClassifications (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List classifications for a given entity represented by a GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetClassifications(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetClassifications and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetClassifications("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetClassifications with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetClassifications("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("list")[0].ToString());
Console.WriteLine(result.GetProperty("pageSize").ToString());
Console.WriteLine(result.GetProperty("sortBy").ToString());
Console.WriteLine(result.GetProperty("sortType").ToString());
Console.WriteLine(result.GetProperty("startIndex").ToString());
Console.WriteLine(result.GetProperty("totalCount").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassifications">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassifications&gt; GetClassifications (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassifications&gt; GetClassifications(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetClassifications(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassifications (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasClassifications)" />
      <MemberSignature Language="F#" Value="abstract member GetClassifications : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassifications&gt;&#xA;override this.GetClassifications : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassifications&gt;" Usage="entity.GetClassifications (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassifications&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List classifications for a given entity represented by a GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetClassifications.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasClassifications> response = client.GetClassifications("<guid>");
]]></code>
This sample shows how to call GetClassifications with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasClassifications> response = client.GetClassifications("<guid>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetClassificationsAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetClassificationsAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetClassificationsAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationsAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationsAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetClassificationsAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.GetClassificationsAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List classifications for a given entity represented by a GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetClassificationsAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetClassificationsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetClassificationsAsync("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetClassificationsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetClassificationsAsync("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("list")[0].ToString());
Console.WriteLine(result.GetProperty("pageSize").ToString());
Console.WriteLine(result.GetProperty("sortBy").ToString());
Console.WriteLine(result.GetProperty("sortType").ToString());
Console.WriteLine(result.GetProperty("startIndex").ToString());
Console.WriteLine(result.GetProperty("totalCount").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetClassificationsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassifications&gt;&gt; GetClassificationsAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassifications&gt;&gt; GetClassificationsAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetClassificationsAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetClassificationsAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasClassifications))" />
      <MemberSignature Language="F#" Value="abstract member GetClassificationsAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassifications&gt;&gt;&#xA;override this.GetClassificationsAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassifications&gt;&gt;" Usage="entity.GetClassificationsAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasClassifications&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List classifications for a given entity represented by a GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetClassificationsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasClassifications> response = await client.GetClassificationsAsync("<guid>");
]]></code>
This sample shows how to call GetClassificationsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasClassifications> response = await client.GetClassificationsAsync("<guid>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntity">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetEntity (string guid, bool? minExtInfo, bool? ignoreRelationships, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetEntity(string guid, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetEntity(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntity (guid As String, minExtInfo As Nullable(Of Boolean), ignoreRelationships As Nullable(Of Boolean), context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetEntity : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetEntity : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="entity.GetEntity (guid, minExtInfo, ignoreRelationships, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get complete definition of an entity given its GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetEntity(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEntity and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetEntity("<guid>", null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetEntity with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetEntity("<guid>", true, true, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntity">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt; GetEntity (string guid, bool? minExtInfo = default, bool? ignoreRelationships = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt; GetEntity(string guid, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetEntity(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntity (guid As String, Optional minExtInfo As Nullable(Of Boolean) = Nothing, Optional ignoreRelationships As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEntityWithExtInfo)" />
      <MemberSignature Language="F#" Value="abstract member GetEntity : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&#xA;override this.GetEntity : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;" Usage="entity.GetEntity (guid, minExtInfo, ignoreRelationships, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get complete definition of an entity given its GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEntity.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityWithExtInfo> response = client.GetEntity("<guid>");
]]></code>
This sample shows how to call GetEntity with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityWithExtInfo> response = client.GetEntity("<guid>", minExtInfo: true, ignoreRelationships: true);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetEntityAsync (string guid, bool? minExtInfo, bool? ignoreRelationships, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetEntityAsync(string guid, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetEntityAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityAsync (guid As String, minExtInfo As Nullable(Of Boolean), ignoreRelationships As Nullable(Of Boolean), context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetEntityAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetEntityAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.GetEntityAsync (guid, minExtInfo, ignoreRelationships, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get complete definition of an entity given its GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetEntityAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEntityAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetEntityAsync("<guid>", null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetEntityAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetEntityAsync("<guid>", true, true, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("referredEntities").GetProperty("<key>").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("businessAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("customAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("homeId").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("provenanceType").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("proxy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("relationshipAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entity").GetProperty("contacts").GetProperty("<key>")[0].GetProperty("info").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEntityAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt; GetEntityAsync (string guid, bool? minExtInfo = default, bool? ignoreRelationships = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt; GetEntityAsync(string guid, valuetype System.Nullable`1&lt;bool&gt; minExtInfo, valuetype System.Nullable`1&lt;bool&gt; ignoreRelationships, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetEntityAsync(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEntityAsync (guid As String, Optional minExtInfo As Nullable(Of Boolean) = Nothing, Optional ignoreRelationships As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEntityWithExtInfo))" />
      <MemberSignature Language="F#" Value="abstract member GetEntityAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt;&#xA;override this.GetEntityAsync : string * Nullable&lt;bool&gt; * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt;" Usage="entity.GetEntityAsync (guid, minExtInfo, ignoreRelationships, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="minExtInfo" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="ignoreRelationships" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get complete definition of an entity given its GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetEntityAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityWithExtInfo> response = await client.GetEntityAsync("<guid>");
]]></code>
This sample shows how to call GetEntityAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityWithExtInfo> response = await client.GetEntityAsync("<guid>", minExtInfo: true, ignoreRelationships: true);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetHeader">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetHeader (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetHeader(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetHeader(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHeader (guid As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetHeader : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetHeader : string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.GetHeader (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get entity header given its GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetHeader(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetHeader and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetHeader("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetHeader with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.GetHeader("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetHeader">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt; GetHeader (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt; GetHeader(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetHeader(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHeader (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AtlasEntityHeader)" />
      <MemberSignature Language="F#" Value="abstract member GetHeader : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt;&#xA;override this.GetHeader : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt;" Usage="entity.GetHeader (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get entity header given its GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetHeader.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityHeader> response = client.GetHeader("<guid>");
]]></code>
This sample shows how to call GetHeader with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityHeader> response = client.GetHeader("<guid>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetHeaderAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetHeaderAsync (string guid, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetHeaderAsync(string guid, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetHeaderAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHeaderAsync (guid As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetHeaderAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetHeaderAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.GetHeaderAsync (guid, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get entity header given its GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.GetHeaderAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetHeaderAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetHeaderAsync("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetHeaderAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.GetHeaderAsync("<guid>", null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetHeaderAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt;&gt; GetHeaderAsync (string guid, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt;&gt; GetHeaderAsync(string guid, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.GetHeaderAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHeaderAsync (guid As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AtlasEntityHeader))" />
      <MemberSignature Language="F#" Value="abstract member GetHeaderAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt;&gt;&#xA;override this.GetHeaderAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt;&gt;" Usage="entity.GetHeaderAsync (guid, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.AtlasEntityHeader&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get entity header given its GUID. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetHeaderAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityHeader> response = await client.GetHeaderAsync("<guid>");
]]></code>
This sample shows how to call GetHeaderAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<AtlasEntityHeader> response = await client.GetHeaderAsync("<guid>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ImportBusinessMetadata">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt; ImportBusinessMetadata (Azure.Analytics.Purview.DataMap.BusinessMetadataOptions businessMetadataOptions, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.BulkImportResult&gt; ImportBusinessMetadata(class Azure.Analytics.Purview.DataMap.BusinessMetadataOptions businessMetadataOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.ImportBusinessMetadata(Azure.Analytics.Purview.DataMap.BusinessMetadataOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportBusinessMetadata (businessMetadataOptions As BusinessMetadataOptions, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BulkImportResult)" />
      <MemberSignature Language="F#" Value="abstract member ImportBusinessMetadata : Azure.Analytics.Purview.DataMap.BusinessMetadataOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;&#xA;override this.ImportBusinessMetadata : Azure.Analytics.Purview.DataMap.BusinessMetadataOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;" Usage="entity.ImportBusinessMetadata (businessMetadataOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="businessMetadataOptions" Type="Azure.Analytics.Purview.DataMap.BusinessMetadataOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="businessMetadataOptions"> Business metadata to send to the service. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Upload the file for creating Business Metadata in BULK. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="businessMetadataOptions" /> is null. </exception>
        <example>
This sample shows how to call ImportBusinessMetadata.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

BusinessMetadataOptions businessMetadataOptions = new BusinessMetadataOptions(BinaryData.FromObjectAsJson(new object()));
Response<BulkImportResult> response = client.ImportBusinessMetadata(businessMetadataOptions);
]]></code>
This sample shows how to call ImportBusinessMetadata with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

BusinessMetadataOptions businessMetadataOptions = new BusinessMetadataOptions(BinaryData.FromObjectAsJson(new object()));
Response<BulkImportResult> response = client.ImportBusinessMetadata(businessMetadataOptions);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ImportBusinessMetadata">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ImportBusinessMetadata (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ImportBusinessMetadata(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.ImportBusinessMetadata(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportBusinessMetadata (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ImportBusinessMetadata : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ImportBusinessMetadata : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.ImportBusinessMetadata (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Upload the file for creating Business Metadata in BULK
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.ImportBusinessMetadata(Azure.Analytics.Purview.DataMap.BusinessMetadataOptions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ImportBusinessMetadata and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    file = new object(),
});
Response response = client.ImportBusinessMetadata(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call ImportBusinessMetadata with all request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    file = new object(),
});
Response response = client.ImportBusinessMetadata(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("failedImportInfoList")[0].GetProperty("childObjectName").ToString());
Console.WriteLine(result.GetProperty("failedImportInfoList")[0].GetProperty("importStatus").ToString());
Console.WriteLine(result.GetProperty("failedImportInfoList")[0].GetProperty("parentObjectName").ToString());
Console.WriteLine(result.GetProperty("failedImportInfoList")[0].GetProperty("remarks").ToString());
Console.WriteLine(result.GetProperty("successImportInfoList")[0].GetProperty("childObjectName").ToString());
Console.WriteLine(result.GetProperty("successImportInfoList")[0].GetProperty("importStatus").ToString());
Console.WriteLine(result.GetProperty("successImportInfoList")[0].GetProperty("parentObjectName").ToString());
Console.WriteLine(result.GetProperty("successImportInfoList")[0].GetProperty("remarks").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ImportBusinessMetadata">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt; ImportBusinessMetadata (BinaryData file, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.BulkImportResult&gt; ImportBusinessMetadata(class System.BinaryData file, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.ImportBusinessMetadata(System.BinaryData,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportBusinessMetadata (file As BinaryData, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BulkImportResult)" />
      <MemberSignature Language="F#" Value="abstract member ImportBusinessMetadata : BinaryData * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;&#xA;override this.ImportBusinessMetadata : BinaryData * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;" Usage="entity.ImportBusinessMetadata (file, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.BinaryData" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="file"> InputStream of file. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Upload the file for creating Business Metadata in BULK. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="ImportBusinessMetadataAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;&gt; ImportBusinessMetadataAsync (Azure.Analytics.Purview.DataMap.BusinessMetadataOptions businessMetadataOptions, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.BulkImportResult&gt;&gt; ImportBusinessMetadataAsync(class Azure.Analytics.Purview.DataMap.BusinessMetadataOptions businessMetadataOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.ImportBusinessMetadataAsync(Azure.Analytics.Purview.DataMap.BusinessMetadataOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportBusinessMetadataAsync (businessMetadataOptions As BusinessMetadataOptions, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BulkImportResult))" />
      <MemberSignature Language="F#" Value="abstract member ImportBusinessMetadataAsync : Azure.Analytics.Purview.DataMap.BusinessMetadataOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;&gt;&#xA;override this.ImportBusinessMetadataAsync : Azure.Analytics.Purview.DataMap.BusinessMetadataOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;&gt;" Usage="entity.ImportBusinessMetadataAsync (businessMetadataOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.BulkImportResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="businessMetadataOptions" Type="Azure.Analytics.Purview.DataMap.BusinessMetadataOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="businessMetadataOptions"> Business metadata to send to the service. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Upload the file for creating Business Metadata in BULK. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="businessMetadataOptions" /> is null. </exception>
        <example>
This sample shows how to call ImportBusinessMetadataAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

BusinessMetadataOptions businessMetadataOptions = new BusinessMetadataOptions(BinaryData.FromObjectAsJson(new object()));
Response<BulkImportResult> response = await client.ImportBusinessMetadataAsync(businessMetadataOptions);
]]></code>
This sample shows how to call ImportBusinessMetadataAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

BusinessMetadataOptions businessMetadataOptions = new BusinessMetadataOptions(BinaryData.FromObjectAsJson(new object()));
Response<BulkImportResult> response = await client.ImportBusinessMetadataAsync(businessMetadataOptions);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ImportBusinessMetadataAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ImportBusinessMetadataAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ImportBusinessMetadataAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.ImportBusinessMetadataAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportBusinessMetadataAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ImportBusinessMetadataAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ImportBusinessMetadataAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.ImportBusinessMetadataAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Upload the file for creating Business Metadata in BULK
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.ImportBusinessMetadataAsync(Azure.Analytics.Purview.DataMap.BusinessMetadataOptions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ImportBusinessMetadataAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    file = new object(),
});
Response response = await client.ImportBusinessMetadataAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call ImportBusinessMetadataAsync with all request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    file = new object(),
});
Response response = await client.ImportBusinessMetadataAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("failedImportInfoList")[0].GetProperty("childObjectName").ToString());
Console.WriteLine(result.GetProperty("failedImportInfoList")[0].GetProperty("importStatus").ToString());
Console.WriteLine(result.GetProperty("failedImportInfoList")[0].GetProperty("parentObjectName").ToString());
Console.WriteLine(result.GetProperty("failedImportInfoList")[0].GetProperty("remarks").ToString());
Console.WriteLine(result.GetProperty("successImportInfoList")[0].GetProperty("childObjectName").ToString());
Console.WriteLine(result.GetProperty("successImportInfoList")[0].GetProperty("importStatus").ToString());
Console.WriteLine(result.GetProperty("successImportInfoList")[0].GetProperty("parentObjectName").ToString());
Console.WriteLine(result.GetProperty("successImportInfoList")[0].GetProperty("remarks").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="MoveEntitiesToCollection">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; MoveEntitiesToCollection (string collectionId, Azure.Analytics.Purview.DataMap.MoveEntitiesConfig moveEntitiesConfig, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; MoveEntitiesToCollection(string collectionId, class Azure.Analytics.Purview.DataMap.MoveEntitiesConfig moveEntitiesConfig, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.MoveEntitiesToCollection(System.String,Azure.Analytics.Purview.DataMap.MoveEntitiesConfig,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveEntitiesToCollection (collectionId As String, moveEntitiesConfig As MoveEntitiesConfig, Optional cancellationToken As CancellationToken = Nothing) As Response(Of EntityMutationResult)" />
      <MemberSignature Language="F#" Value="abstract member MoveEntitiesToCollection : string * Azure.Analytics.Purview.DataMap.MoveEntitiesConfig * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&#xA;override this.MoveEntitiesToCollection : string * Azure.Analytics.Purview.DataMap.MoveEntitiesConfig * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;" Usage="entity.MoveEntitiesToCollection (collectionId, moveEntitiesConfig, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="moveEntitiesConfig" Type="Azure.Analytics.Purview.DataMap.MoveEntitiesConfig" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection where entities will be moved to. </param>
        <param name="moveEntitiesConfig"> MoveEntitiesOptions. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Move existing entities to the target collection. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collectionId" /> or <paramref name="moveEntitiesConfig" /> is null. </exception>
        <example>
This sample shows how to call MoveEntitiesToCollection.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

MoveEntitiesConfig moveEntitiesConfig = new MoveEntitiesConfig();
Response<EntityMutationResult> response = client.MoveEntitiesToCollection("<collectionId>", moveEntitiesConfig);
]]></code>
This sample shows how to call MoveEntitiesToCollection with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

MoveEntitiesConfig moveEntitiesConfig = new MoveEntitiesConfig
{
    EntityGuids = { "<entityGuids>" },
};
Response<EntityMutationResult> response = client.MoveEntitiesToCollection("<collectionId>", moveEntitiesConfig);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="MoveEntitiesToCollection">
      <MemberSignature Language="C#" Value="public virtual Azure.Response MoveEntitiesToCollection (string collectionId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response MoveEntitiesToCollection(string collectionId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.MoveEntitiesToCollection(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveEntitiesToCollection (collectionId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member MoveEntitiesToCollection : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.MoveEntitiesToCollection : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.MoveEntitiesToCollection (collectionId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection where entities will be moved to. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Move existing entities to the target collection.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.MoveEntitiesToCollection(System.String,Azure.Analytics.Purview.DataMap.MoveEntitiesConfig,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collectionId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call MoveEntitiesToCollection and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

using RequestContent content = RequestContent.Create(new object());
Response response = client.MoveEntitiesToCollection("<collectionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call MoveEntitiesToCollection with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

using RequestContent content = RequestContent.Create(new
{
    entityGuids = new object[]
    {
        "<entityGuids>"
    },
});
Response response = client.MoveEntitiesToCollection("<collectionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="MoveEntitiesToCollectionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; MoveEntitiesToCollectionAsync (string collectionId, Azure.Analytics.Purview.DataMap.MoveEntitiesConfig moveEntitiesConfig, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; MoveEntitiesToCollectionAsync(string collectionId, class Azure.Analytics.Purview.DataMap.MoveEntitiesConfig moveEntitiesConfig, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.MoveEntitiesToCollectionAsync(System.String,Azure.Analytics.Purview.DataMap.MoveEntitiesConfig,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveEntitiesToCollectionAsync (collectionId As String, moveEntitiesConfig As MoveEntitiesConfig, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of EntityMutationResult))" />
      <MemberSignature Language="F#" Value="abstract member MoveEntitiesToCollectionAsync : string * Azure.Analytics.Purview.DataMap.MoveEntitiesConfig * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;&#xA;override this.MoveEntitiesToCollectionAsync : string * Azure.Analytics.Purview.DataMap.MoveEntitiesConfig * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;" Usage="entity.MoveEntitiesToCollectionAsync (collectionId, moveEntitiesConfig, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="moveEntitiesConfig" Type="Azure.Analytics.Purview.DataMap.MoveEntitiesConfig" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection where entities will be moved to. </param>
        <param name="moveEntitiesConfig"> MoveEntitiesOptions. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Move existing entities to the target collection. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collectionId" /> or <paramref name="moveEntitiesConfig" /> is null. </exception>
        <example>
This sample shows how to call MoveEntitiesToCollectionAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

MoveEntitiesConfig moveEntitiesConfig = new MoveEntitiesConfig();
Response<EntityMutationResult> response = await client.MoveEntitiesToCollectionAsync("<collectionId>", moveEntitiesConfig);
]]></code>
This sample shows how to call MoveEntitiesToCollectionAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

MoveEntitiesConfig moveEntitiesConfig = new MoveEntitiesConfig
{
    EntityGuids = { "<entityGuids>" },
};
Response<EntityMutationResult> response = await client.MoveEntitiesToCollectionAsync("<collectionId>", moveEntitiesConfig);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="MoveEntitiesToCollectionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; MoveEntitiesToCollectionAsync (string collectionId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; MoveEntitiesToCollectionAsync(string collectionId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.MoveEntitiesToCollectionAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveEntitiesToCollectionAsync (collectionId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member MoveEntitiesToCollectionAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.MoveEntitiesToCollectionAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.MoveEntitiesToCollectionAsync (collectionId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection where entities will be moved to. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Move existing entities to the target collection.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.MoveEntitiesToCollectionAsync(System.String,Azure.Analytics.Purview.DataMap.MoveEntitiesConfig,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collectionId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call MoveEntitiesToCollectionAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

using RequestContent content = RequestContent.Create(new object());
Response response = await client.MoveEntitiesToCollectionAsync("<collectionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call MoveEntitiesToCollectionAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient(apiVersion: "2023-09-01");

using RequestContent content = RequestContent.Create(new
{
    entityGuids = new object[]
    {
        "<entityGuids>"
    },
});
Response response = await client.MoveEntitiesToCollectionAsync("<collectionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Analytics.Purview.DataMap.Entity.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Analytics.Purview.DataMap.Entity.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveBusinessMetadata">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveBusinessMetadata (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveBusinessMetadata(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadata(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveBusinessMetadata (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveBusinessMetadata : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.RemoveBusinessMetadata : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.RemoveBusinessMetadata (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Remove business metadata from an entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadata(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData}},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveBusinessMetadata.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new
    {
        key = new object(),
    },
});
Response response = client.RemoveBusinessMetadata("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveBusinessMetadata with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new
    {
        key = new object(),
    },
});
Response response = client.RemoveBusinessMetadata("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveBusinessMetadata">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveBusinessMetadata (string guid, System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.IDictionary&lt;string,BinaryData&gt;&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveBusinessMetadata(string guid, class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.IDictionary`2&lt;string, class System.BinaryData&gt;&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadata(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData}},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveBusinessMetadata (guid As String, body As IDictionary(Of String, IDictionary(Of String, BinaryData)), Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveBusinessMetadata : string * System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IDictionary&lt;string, BinaryData&gt;&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.RemoveBusinessMetadata : string * System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IDictionary&lt;string, BinaryData&gt;&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.RemoveBusinessMetadata (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.IDictionary&lt;System.String,System.BinaryData&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> Business metadata payload. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Remove business metadata from an entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveBusinessMetadata.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveBusinessMetadata("<guid>", new Dictionary<string, IDictionary<string, BinaryData>>
{
    ["key"] = new Dictionary<string, BinaryData>
    {
        ["key"] = BinaryData.FromObjectAsJson(new object())
    }
});
]]></code>
This sample shows how to call RemoveBusinessMetadata with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveBusinessMetadata("<guid>", new Dictionary<string, IDictionary<string, BinaryData>>
{
    ["key"] = new Dictionary<string, BinaryData>
    {
        ["key"] = BinaryData.FromObjectAsJson(new object())
    }
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveBusinessMetadataAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveBusinessMetadataAsync (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveBusinessMetadataAsync(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveBusinessMetadataAsync (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveBusinessMetadataAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveBusinessMetadataAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveBusinessMetadataAsync (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Remove business metadata from an entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAsync(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData}},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveBusinessMetadataAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new
    {
        key = new object(),
    },
});
Response response = await client.RemoveBusinessMetadataAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveBusinessMetadataAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new
    {
        key = new object(),
    },
});
Response response = await client.RemoveBusinessMetadataAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveBusinessMetadataAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveBusinessMetadataAsync (string guid, System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.IDictionary&lt;string,BinaryData&gt;&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveBusinessMetadataAsync(string guid, class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.IDictionary`2&lt;string, class System.BinaryData&gt;&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAsync(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData}},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveBusinessMetadataAsync (guid As String, body As IDictionary(Of String, IDictionary(Of String, BinaryData)), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveBusinessMetadataAsync : string * System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IDictionary&lt;string, BinaryData&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveBusinessMetadataAsync : string * System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.IDictionary&lt;string, BinaryData&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveBusinessMetadataAsync (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.IDictionary&lt;System.String,System.BinaryData&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> Business metadata payload. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Remove business metadata from an entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveBusinessMetadataAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveBusinessMetadataAsync("<guid>", new Dictionary<string, IDictionary<string, BinaryData>>
{
    ["key"] = new Dictionary<string, BinaryData>
    {
        ["key"] = BinaryData.FromObjectAsJson(new object())
    }
});
]]></code>
This sample shows how to call RemoveBusinessMetadataAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveBusinessMetadataAsync("<guid>", new Dictionary<string, IDictionary<string, BinaryData>>
{
    ["key"] = new Dictionary<string, BinaryData>
    {
        ["key"] = BinaryData.FromObjectAsJson(new object())
    }
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveBusinessMetadataAttributes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveBusinessMetadataAttributes (string guid, string businessMetadataName, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveBusinessMetadataAttributes(string guid, string businessMetadataName, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAttributes(System.String,System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveBusinessMetadataAttributes (guid As String, businessMetadataName As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveBusinessMetadataAttributes : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.RemoveBusinessMetadataAttributes : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.RemoveBusinessMetadataAttributes (guid, businessMetadataName, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="businessMetadataName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="businessMetadataName"> BusinessMetadata name. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete business metadata attributes from an entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAttributes(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="businessMetadataName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="businessMetadataName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveBusinessMetadataAttributes.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new object(),
});
Response response = client.RemoveBusinessMetadataAttributes("<guid>", "<businessMetadataName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveBusinessMetadataAttributes with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new object(),
});
Response response = client.RemoveBusinessMetadataAttributes("<guid>", "<businessMetadataName>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveBusinessMetadataAttributes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveBusinessMetadataAttributes (string guid, string businessMetadataName, System.Collections.Generic.IDictionary&lt;string,BinaryData&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveBusinessMetadataAttributes(string guid, string businessMetadataName, class System.Collections.Generic.IDictionary`2&lt;string, class System.BinaryData&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAttributes(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveBusinessMetadataAttributes (guid As String, businessMetadataName As String, body As IDictionary(Of String, BinaryData), Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveBusinessMetadataAttributes : string * string * System.Collections.Generic.IDictionary&lt;string, BinaryData&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.RemoveBusinessMetadataAttributes : string * string * System.Collections.Generic.IDictionary&lt;string, BinaryData&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.RemoveBusinessMetadataAttributes (guid, businessMetadataName, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="businessMetadataName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IDictionary&lt;System.String,System.BinaryData&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="businessMetadataName"> BusinessMetadata name. </param>
        <param name="body"> Business metadata attribute payload. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Delete business metadata attributes from an entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="businessMetadataName" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="businessMetadataName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveBusinessMetadataAttributes.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveBusinessMetadataAttributes("<guid>", "<businessMetadataName>", new Dictionary<string, BinaryData>
{
    ["key"] = BinaryData.FromObjectAsJson(new object())
});
]]></code>
This sample shows how to call RemoveBusinessMetadataAttributes with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveBusinessMetadataAttributes("<guid>", "<businessMetadataName>", new Dictionary<string, BinaryData>
{
    ["key"] = BinaryData.FromObjectAsJson(new object())
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveBusinessMetadataAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveBusinessMetadataAttributesAsync (string guid, string businessMetadataName, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveBusinessMetadataAttributesAsync(string guid, string businessMetadataName, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAttributesAsync(System.String,System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveBusinessMetadataAttributesAsync (guid As String, businessMetadataName As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveBusinessMetadataAttributesAsync : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveBusinessMetadataAttributesAsync : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveBusinessMetadataAttributesAsync (guid, businessMetadataName, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="businessMetadataName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="businessMetadataName"> BusinessMetadata name. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete business metadata attributes from an entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAttributesAsync(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="businessMetadataName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="businessMetadataName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveBusinessMetadataAttributesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new object(),
});
Response response = await client.RemoveBusinessMetadataAttributesAsync("<guid>", "<businessMetadataName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveBusinessMetadataAttributesAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    key = new object(),
});
Response response = await client.RemoveBusinessMetadataAttributesAsync("<guid>", "<businessMetadataName>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveBusinessMetadataAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveBusinessMetadataAttributesAsync (string guid, string businessMetadataName, System.Collections.Generic.IDictionary&lt;string,BinaryData&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveBusinessMetadataAttributesAsync(string guid, string businessMetadataName, class System.Collections.Generic.IDictionary`2&lt;string, class System.BinaryData&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveBusinessMetadataAttributesAsync(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.BinaryData},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveBusinessMetadataAttributesAsync (guid As String, businessMetadataName As String, body As IDictionary(Of String, BinaryData), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveBusinessMetadataAttributesAsync : string * string * System.Collections.Generic.IDictionary&lt;string, BinaryData&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveBusinessMetadataAttributesAsync : string * string * System.Collections.Generic.IDictionary&lt;string, BinaryData&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveBusinessMetadataAttributesAsync (guid, businessMetadataName, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="businessMetadataName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IDictionary&lt;System.String,System.BinaryData&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="businessMetadataName"> BusinessMetadata name. </param>
        <param name="body"> Business metadata attribute payload. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Delete business metadata attributes from an entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="businessMetadataName" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="businessMetadataName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveBusinessMetadataAttributesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveBusinessMetadataAttributesAsync("<guid>", "<businessMetadataName>", new Dictionary<string, BinaryData>
{
    ["key"] = BinaryData.FromObjectAsJson(new object())
});
]]></code>
This sample shows how to call RemoveBusinessMetadataAttributesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveBusinessMetadataAttributesAsync("<guid>", "<businessMetadataName>", new Dictionary<string, BinaryData>
{
    ["key"] = BinaryData.FromObjectAsJson(new object())
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveClassification">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveClassification (string guid, string classificationName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveClassification(string guid, string classificationName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveClassification(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveClassification (guid As String, classificationName As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveClassification : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.RemoveClassification : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.RemoveClassification (guid, classificationName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="classificationName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="classificationName"> The name of the classification. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete a given classification from an existing entity represented by a GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveClassification.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveClassification("<guid>", "<classificationName>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveClassification with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveClassification("<guid>", "<classificationName>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveClassificationAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveClassificationAsync (string guid, string classificationName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveClassificationAsync(string guid, string classificationName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveClassificationAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveClassificationAsync (guid As String, classificationName As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveClassificationAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveClassificationAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveClassificationAsync (guid, classificationName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="classificationName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="classificationName"> The name of the classification. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete a given classification from an existing entity represented by a GUID.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> or <paramref name="classificationName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveClassificationAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveClassificationAsync("<guid>", "<classificationName>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveClassificationAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveClassificationAsync("<guid>", "<classificationName>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveClassificationByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveClassificationByUniqueAttribute (string typeName, string classificationName, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveClassificationByUniqueAttribute(string typeName, string classificationName, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveClassificationByUniqueAttribute(System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveClassificationByUniqueAttribute (typeName As String, classificationName As String, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveClassificationByUniqueAttribute : string * string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.RemoveClassificationByUniqueAttribute : string * string * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.RemoveClassificationByUniqueAttribute (typeName, classificationName, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="classificationName" Type="System.String" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="classificationName"> The name of the classification. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete a given classification from an entity identified by its type and unique
            attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="classificationName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> or <paramref name="classificationName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveClassificationByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveClassificationByUniqueAttribute("<typeName>", "<classificationName>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveClassificationByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveClassificationByUniqueAttribute("<typeName>", "<classificationName>", attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveClassificationByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveClassificationByUniqueAttributeAsync (string typeName, string classificationName, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveClassificationByUniqueAttributeAsync(string typeName, string classificationName, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveClassificationByUniqueAttributeAsync(System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveClassificationByUniqueAttributeAsync (typeName As String, classificationName As String, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveClassificationByUniqueAttributeAsync : string * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveClassificationByUniqueAttributeAsync : string * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveClassificationByUniqueAttributeAsync (typeName, classificationName, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="classificationName" Type="System.String" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="classificationName"> The name of the classification. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete a given classification from an entity identified by its type and unique
            attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="classificationName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> or <paramref name="classificationName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveClassificationByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveClassificationByUniqueAttributeAsync("<typeName>", "<classificationName>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveClassificationByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveClassificationByUniqueAttributeAsync("<typeName>", "<classificationName>", attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveLabels">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveLabels (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveLabels(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabels(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveLabels (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveLabels : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.RemoveLabels : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.RemoveLabels (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete given labels to a given entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabels(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveLabels.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = client.RemoveLabels("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveLabels with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = client.RemoveLabels("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveLabels">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveLabels (string guid, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveLabels(string guid, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabels(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveLabels (guid As String, Optional body As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveLabels : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.RemoveLabels : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.RemoveLabels (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> set of labels to be deleted. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Delete given labels to a given entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveLabels.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveLabels("<guid>");
]]></code>
This sample shows how to call RemoveLabels with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveLabels("<guid>", body: new string[] { "<body>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveLabelsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveLabelsAsync (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveLabelsAsync(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveLabelsAsync (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveLabelsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveLabelsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveLabelsAsync (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete given labels to a given entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveLabelsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = await client.RemoveLabelsAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveLabelsAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = await client.RemoveLabelsAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveLabelsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveLabelsAsync (string guid, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveLabelsAsync(string guid, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveLabelsAsync (guid As String, Optional body As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveLabelsAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveLabelsAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveLabelsAsync (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> set of labels to be deleted. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Delete given labels to a given entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveLabelsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveLabelsAsync("<guid>");
]]></code>
This sample shows how to call RemoveLabelsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveLabelsAsync("<guid>", body: new string[] { "<body>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveLabelsByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveLabelsByUniqueAttribute (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveLabelsByUniqueAttribute(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsByUniqueAttribute(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveLabelsByUniqueAttribute (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveLabelsByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.RemoveLabelsByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.RemoveLabelsByUniqueAttribute (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Delete given labels to a given entity identified by its type and unique
             attribute.
            
             If labels is null/empty, no labels will be removed.
            
             If any labels
             in labels set are non-existing labels, they will be ignored, only existing
             labels will be removed. In addition to the typeName path parameter, attribute
             key-value pair(s) can be provided in the following format:
             attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
             across entities, eg. qualifiedName. The REST request would look something like
             this: DELETE
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsByUniqueAttribute(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveLabelsByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = client.RemoveLabelsByUniqueAttribute("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveLabelsByUniqueAttribute with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = client.RemoveLabelsByUniqueAttribute("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveLabelsByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveLabelsByUniqueAttribute (string typeName, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveLabelsByUniqueAttribute(string typeName, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsByUniqueAttribute(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveLabelsByUniqueAttribute (typeName As String, Optional body As IEnumerable(Of String) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveLabelsByUniqueAttribute : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.RemoveLabelsByUniqueAttribute : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.RemoveLabelsByUniqueAttribute (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> set of labels to be deleted. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Delete given labels to a given entity identified by its type and unique
             attribute.
            
             If labels is null/empty, no labels will be removed.
            
             If any labels
             in labels set are non-existing labels, they will be ignored, only existing
             labels will be removed. In addition to the typeName path parameter, attribute
             key-value pair(s) can be provided in the following format:
             attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
             across entities, eg. qualifiedName. The REST request would look something like
             this: DELETE
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveLabelsByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveLabelsByUniqueAttribute("<typeName>");
]]></code>
This sample shows how to call RemoveLabelsByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.RemoveLabelsByUniqueAttribute("<typeName>", body: new string[] { "<body>" }, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveLabelsByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveLabelsByUniqueAttributeAsync (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveLabelsByUniqueAttributeAsync(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsByUniqueAttributeAsync(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveLabelsByUniqueAttributeAsync (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveLabelsByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveLabelsByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveLabelsByUniqueAttributeAsync (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Delete given labels to a given entity identified by its type and unique
             attribute.
            
             If labels is null/empty, no labels will be removed.
            
             If any labels
             in labels set are non-existing labels, they will be ignored, only existing
             labels will be removed. In addition to the typeName path parameter, attribute
             key-value pair(s) can be provided in the following format:
             attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
             across entities, eg. qualifiedName. The REST request would look something like
             this: DELETE
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsByUniqueAttributeAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveLabelsByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = await client.RemoveLabelsByUniqueAttributeAsync("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveLabelsByUniqueAttributeAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = await client.RemoveLabelsByUniqueAttributeAsync("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveLabelsByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveLabelsByUniqueAttributeAsync (string typeName, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveLabelsByUniqueAttributeAsync(string typeName, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.RemoveLabelsByUniqueAttributeAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveLabelsByUniqueAttributeAsync (typeName As String, Optional body As IEnumerable(Of String) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveLabelsByUniqueAttributeAsync : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveLabelsByUniqueAttributeAsync : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.RemoveLabelsByUniqueAttributeAsync (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> set of labels to be deleted. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Delete given labels to a given entity identified by its type and unique
             attribute.
            
             If labels is null/empty, no labels will be removed.
            
             If any labels
             in labels set are non-existing labels, they will be ignored, only existing
             labels will be removed. In addition to the typeName path parameter, attribute
             key-value pair(s) can be provided in the following format:
             attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
             across entities, eg. qualifiedName. The REST request would look something like
             this: DELETE
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveLabelsByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveLabelsByUniqueAttributeAsync("<typeName>");
]]></code>
This sample shows how to call RemoveLabelsByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.RemoveLabelsByUniqueAttributeAsync("<typeName>", body: new string[] { "<body>" }, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="SetLabels">
      <MemberSignature Language="C#" Value="public virtual Azure.Response SetLabels (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response SetLabels(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.SetLabels(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetLabels (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member SetLabels : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.SetLabels : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.SetLabels (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Set labels to a given entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.SetLabels(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call SetLabels.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = client.SetLabels("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call SetLabels with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = client.SetLabels("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="SetLabels">
      <MemberSignature Language="C#" Value="public virtual Azure.Response SetLabels (string guid, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response SetLabels(string guid, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.SetLabels(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetLabels (guid As String, Optional body As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member SetLabels : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.SetLabels : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.SetLabels (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> set of labels to be set to the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Set labels to a given entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call SetLabels.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.SetLabels("<guid>");
]]></code>
This sample shows how to call SetLabels with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.SetLabels("<guid>", body: new string[] { "<body>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="SetLabelsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; SetLabelsAsync (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; SetLabelsAsync(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetLabelsAsync (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member SetLabelsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.SetLabelsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.SetLabelsAsync (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Set labels to a given entity.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call SetLabelsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = await client.SetLabelsAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call SetLabelsAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = await client.SetLabelsAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="SetLabelsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; SetLabelsAsync (string guid, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; SetLabelsAsync(string guid, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetLabelsAsync (guid As String, Optional body As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member SetLabelsAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.SetLabelsAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.SetLabelsAsync (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> set of labels to be set to the entity. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Set labels to a given entity. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call SetLabelsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.SetLabelsAsync("<guid>");
]]></code>
This sample shows how to call SetLabelsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.SetLabelsAsync("<guid>", body: new string[] { "<body>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="SetLabelsByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response SetLabelsByUniqueAttribute (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response SetLabelsByUniqueAttribute(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsByUniqueAttribute(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetLabelsByUniqueAttribute (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member SetLabelsByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.SetLabelsByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.SetLabelsByUniqueAttribute (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Set labels to a given entity identified by its type and unique attributes.
            
             If
             labels is null/empty, existing labels will all be removed.
            
             In addition to the
             typeName path parameter, attribute key-value pair(s) can be provided in the
             following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this: POST
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsByUniqueAttribute(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call SetLabelsByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = client.SetLabelsByUniqueAttribute("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call SetLabelsByUniqueAttribute with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = client.SetLabelsByUniqueAttribute("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="SetLabelsByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response SetLabelsByUniqueAttribute (string typeName, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response SetLabelsByUniqueAttribute(string typeName, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsByUniqueAttribute(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetLabelsByUniqueAttribute (typeName As String, Optional body As IEnumerable(Of String) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member SetLabelsByUniqueAttribute : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.SetLabelsByUniqueAttribute : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.SetLabelsByUniqueAttribute (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> set of labels to be set. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Set labels to a given entity identified by its type and unique attributes.
            
             If
             labels is null/empty, existing labels will all be removed.
            
             In addition to the
             typeName path parameter, attribute key-value pair(s) can be provided in the
             following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this: POST
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call SetLabelsByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.SetLabelsByUniqueAttribute("<typeName>");
]]></code>
This sample shows how to call SetLabelsByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.SetLabelsByUniqueAttribute("<typeName>", body: new string[] { "<body>" }, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="SetLabelsByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; SetLabelsByUniqueAttributeAsync (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; SetLabelsByUniqueAttributeAsync(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsByUniqueAttributeAsync(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetLabelsByUniqueAttributeAsync (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member SetLabelsByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.SetLabelsByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.SetLabelsByUniqueAttributeAsync (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Set labels to a given entity identified by its type and unique attributes.
            
             If
             labels is null/empty, existing labels will all be removed.
            
             In addition to the
             typeName path parameter, attribute key-value pair(s) can be provided in the
             following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this: POST
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsByUniqueAttributeAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call SetLabelsByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = null;
Response response = await client.SetLabelsByUniqueAttributeAsync("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call SetLabelsByUniqueAttributeAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    "<body>"
});
Response response = await client.SetLabelsByUniqueAttributeAsync("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="SetLabelsByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; SetLabelsByUniqueAttributeAsync (string typeName, System.Collections.Generic.IEnumerable&lt;string&gt; body = default, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; SetLabelsByUniqueAttributeAsync(string typeName, class System.Collections.Generic.IEnumerable`1&lt;string&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.SetLabelsByUniqueAttributeAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SetLabelsByUniqueAttributeAsync (typeName As String, Optional body As IEnumerable(Of String) = Nothing, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member SetLabelsByUniqueAttributeAsync : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.SetLabelsByUniqueAttributeAsync : string * seq&lt;string&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.SetLabelsByUniqueAttributeAsync (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> set of labels to be set. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Set labels to a given entity identified by its type and unique attributes.
            
             If
             labels is null/empty, existing labels will all be removed.
            
             In addition to the
             typeName path parameter, attribute key-value pair(s) can be provided in the
             following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
            
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this: POST
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call SetLabelsByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.SetLabelsByUniqueAttributeAsync("<typeName>");
]]></code>
This sample shows how to call SetLabelsByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.SetLabelsByUniqueAttributeAsync("<typeName>", body: new string[] { "<body>" }, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateAttributeById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateAttributeById (string guid, string name, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateAttributeById(string guid, string name, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateAttributeById(System.String,System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateAttributeById (guid As String, name As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateAttributeById : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdateAttributeById : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.UpdateAttributeById (guid, name, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="name"> The name of the attribute. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Update entity partially - create or update entity attribute identified by its
            GUID.
            Supports only primitive attribute type and entity references.
            It does not support updating complex types like arrays, and maps.
            Null updates are not possible.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.UpdateAttributeById(System.String,System.String,System.BinaryData,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="name" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateAttributeById and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdateAttributeById("<guid>", "<name>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateAttributeById with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdateAttributeById("<guid>", "<name>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateAttributeById">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; UpdateAttributeById (string guid, string name, BinaryData body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; UpdateAttributeById(string guid, string name, class System.BinaryData body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateAttributeById(System.String,System.String,System.BinaryData,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateAttributeById (guid As String, name As String, body As BinaryData, Optional cancellationToken As CancellationToken = Nothing) As Response(Of EntityMutationResult)" />
      <MemberSignature Language="F#" Value="abstract member UpdateAttributeById : string * string * BinaryData * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&#xA;override this.UpdateAttributeById : string * string * BinaryData * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;" Usage="entity.UpdateAttributeById (guid, name, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="body" Type="System.BinaryData" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="name"> The name of the attribute. </param>
        <param name="body"> The value of the attribute. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Update entity partially - create or update entity attribute identified by its
            GUID.
            Supports only primitive attribute type and entity references.
            It does not support updating complex types like arrays, and maps.
            Null updates are not possible.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="name" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UpdateAttributeById.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = client.UpdateAttributeById("<guid>", "<name>", BinaryData.FromObjectAsJson(new object()));
]]></code>
This sample shows how to call UpdateAttributeById with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = client.UpdateAttributeById("<guid>", "<name>", BinaryData.FromObjectAsJson(new object()));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateAttributeByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateAttributeByIdAsync (string guid, string name, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateAttributeByIdAsync(string guid, string name, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateAttributeByIdAsync(System.String,System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateAttributeByIdAsync (guid As String, name As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateAttributeByIdAsync : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateAttributeByIdAsync : string * string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.UpdateAttributeByIdAsync (guid, name, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="name"> The name of the attribute. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Update entity partially - create or update entity attribute identified by its
            GUID.
            Supports only primitive attribute type and entity references.
            It does not support updating complex types like arrays, and maps.
            Null updates are not possible.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.UpdateAttributeByIdAsync(System.String,System.String,System.BinaryData,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="name" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateAttributeByIdAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdateAttributeByIdAsync("<guid>", "<name>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateAttributeByIdAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdateAttributeByIdAsync("<guid>", "<name>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateAttributeByIdAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; UpdateAttributeByIdAsync (string guid, string name, BinaryData body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; UpdateAttributeByIdAsync(string guid, string name, class System.BinaryData body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateAttributeByIdAsync(System.String,System.String,System.BinaryData,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateAttributeByIdAsync (guid As String, name As String, body As BinaryData, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of EntityMutationResult))" />
      <MemberSignature Language="F#" Value="abstract member UpdateAttributeByIdAsync : string * string * BinaryData * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;&#xA;override this.UpdateAttributeByIdAsync : string * string * BinaryData * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;" Usage="entity.UpdateAttributeByIdAsync (guid, name, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="body" Type="System.BinaryData" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="name"> The name of the attribute. </param>
        <param name="body"> The value of the attribute. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Update entity partially - create or update entity attribute identified by its
            GUID.
            Supports only primitive attribute type and entity references.
            It does not support updating complex types like arrays, and maps.
            Null updates are not possible.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" />, <paramref name="name" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UpdateAttributeByIdAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = await client.UpdateAttributeByIdAsync("<guid>", "<name>", BinaryData.FromObjectAsJson(new object()));
]]></code>
This sample shows how to call UpdateAttributeByIdAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response<EntityMutationResult> response = await client.UpdateAttributeByIdAsync("<guid>", "<name>", BinaryData.FromObjectAsJson(new object()));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; UpdateByUniqueAttribute (string typeName, Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt; UpdateByUniqueAttribute(string typeName, class Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateByUniqueAttribute(System.String,Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateByUniqueAttribute (typeName As String, atlasEntityWithExtInfo As AtlasEntityWithExtInfo, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of EntityMutationResult)" />
      <MemberSignature Language="F#" Value="abstract member UpdateByUniqueAttribute : string * Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&#xA;override this.UpdateByUniqueAttribute : string * Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;" Usage="entity.UpdateByUniqueAttribute (typeName, atlasEntityWithExtInfo, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="atlasEntityWithExtInfo" Type="Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="atlasEntityWithExtInfo">
             An instance of an entity along with extended info - like hive_table,
             hive_database.
             </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Update entity partially - Allow a subset of attributes to be updated on an
             entity which is identified by its type and unique attribute eg:
             Referenceable.qualifiedName. Null updates are not possible.
            
             In addition to the
             typeName path parameter, attribute key-value pair(s) can be provided in the
             following format:
            
             attr:&lt;attrName&gt;=&lt;attrValue&gt;.
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this:
             PUT
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="atlasEntityWithExtInfo" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UpdateByUniqueAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityWithExtInfo atlasEntityWithExtInfo = new AtlasEntityWithExtInfo();
Response<EntityMutationResult> response = client.UpdateByUniqueAttribute("<typeName>", atlasEntityWithExtInfo);
]]></code>
This sample shows how to call UpdateByUniqueAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityWithExtInfo atlasEntityWithExtInfo = new AtlasEntityWithExtInfo
{
    ReferredEntities =
    {
        ["key"] = new AtlasEntity
        {
            Attributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            TypeName = "<typeName>",
            LastModifiedTS = "<lastModifiedTS>",
            BusinessAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Classifications = {new AtlasClassification
            {
                Attributes =
                {
                    ["key"] = BinaryData.FromObjectAsJson(new object())
                },
                TypeName = "<typeName>",
                LastModifiedTS = "<lastModifiedTS>",
                EntityGuid = "<entityGuid>",
                EntityStatus = EntityStatus.Active,
                RemovePropagationsOnEntityDelete = true,
                ValidityPeriods = {new TimeBoundary
                {
                    EndTime = "<endTime>",
                    StartTime = "<startTime>",
                    TimeZone = "<timeZone>",
                }},
            }},
            CreateTime = 1234L,
            CreatedBy = "<createdBy>",
            CustomAttributes =
            {
                ["key"] = "<customAttributes>"
            },
            Guid = "<guid>",
            HomeId = "<homeId>",
            IsIncomplete = true,
            Labels = {"<labels>"},
            Meanings = {new AtlasTermAssignmentHeader
            {
                Confidence = 1234,
                CreatedBy = "<createdBy>",
                Description = "<description>",
                DisplayText = "<displayText>",
                Expression = "<expression>",
                RelationGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
                Status = AtlasTermAssignmentStatus.Discovered,
                Steward = "<steward>",
                TermGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
            }},
            ProvenanceType = 1234,
            Proxy = true,
            RelationshipAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Status = EntityStatus.Active,
            UpdateTime = 1234L,
            UpdatedBy = "<updatedBy>",
            Version = 1234L,
            Contacts =
            {
                ["key"] = {new ContactInfo
                {
                    Id = "<id>",
                    Info = "<info>",
                }}
            },
        }
    },
    Entity = default,
};
Response<EntityMutationResult> response = client.UpdateByUniqueAttribute("<typeName>", atlasEntityWithExtInfo, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateByUniqueAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateByUniqueAttribute (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateByUniqueAttribute(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateByUniqueAttribute(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateByUniqueAttribute (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdateByUniqueAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.UpdateByUniqueAttribute (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Update entity partially - Allow a subset of attributes to be updated on an
             entity which is identified by its type and unique attribute eg:
             Referenceable.qualifiedName. Null updates are not possible.
            
             In addition to the
             typeName path parameter, attribute key-value pair(s) can be provided in the
             following format:
            
             attr:&lt;attrName&gt;=&lt;attrValue&gt;.
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this:
             PUT
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.UpdateByUniqueAttribute(System.String,Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateByUniqueAttribute and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdateByUniqueAttribute("<typeName>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateByUniqueAttribute with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    referredEntities = new
    {
        key = new
        {
            attributes = new
            {
                key = new object(),
            },
            typeName = "<typeName>",
            lastModifiedTS = "<lastModifiedTS>",
            businessAttributes = new
            {
                key = new object(),
            },
            classifications = new object[]
            {
                new
                {
                    attributes = new
                    {
                        key = new object(),
                    },
                    typeName = "<typeName>",
                    lastModifiedTS = "<lastModifiedTS>",
                    entityGuid = "<entityGuid>",
                    entityStatus = "ACTIVE",
                    removePropagationsOnEntityDelete = true,
                    validityPeriods = new object[]
                    {
                        new
                        {
                            endTime = "<endTime>",
                            startTime = "<startTime>",
                            timeZone = "<timeZone>",
                        }
                    },
                }
            },
            createTime = 1234L,
            createdBy = "<createdBy>",
            customAttributes = new
            {
                key = "<customAttributes>",
            },
            guid = "<guid>",
            homeId = "<homeId>",
            isIncomplete = true,
            labels = new object[]
            {
                "<labels>"
            },
            meanings = new object[]
            {
                new
                {
                    confidence = 1234,
                    createdBy = "<createdBy>",
                    description = "<description>",
                    displayText = "<displayText>",
                    expression = "<expression>",
                    relationGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                    status = "DISCOVERED",
                    steward = "<steward>",
                    termGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                }
            },
            provenanceType = 1234,
            proxy = true,
            relationshipAttributes = new
            {
                key = new object(),
            },
            status = "ACTIVE",
            updateTime = 1234L,
            updatedBy = "<updatedBy>",
            version = 1234L,
            contacts = new
            {
                key = new object[]
                {
                    new
                    {
                        id = "<id>",
                        info = "<info>",
                    }
                },
            },
        },
    },
});
Response response = client.UpdateByUniqueAttribute("<typeName>", content, attribute: "<attribute>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; UpdateByUniqueAttributeAsync (string typeName, Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt; UpdateByUniqueAttributeAsync(string typeName, class Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateByUniqueAttributeAsync(System.String,Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateByUniqueAttributeAsync (typeName As String, atlasEntityWithExtInfo As AtlasEntityWithExtInfo, Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of EntityMutationResult))" />
      <MemberSignature Language="F#" Value="abstract member UpdateByUniqueAttributeAsync : string * Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;&#xA;override this.UpdateByUniqueAttributeAsync : string * Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;" Usage="entity.UpdateByUniqueAttributeAsync (typeName, atlasEntityWithExtInfo, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Analytics.Purview.DataMap.EntityMutationResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="atlasEntityWithExtInfo" Type="Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="atlasEntityWithExtInfo">
             An instance of an entity along with extended info - like hive_table,
             hive_database.
             </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
             Update entity partially - Allow a subset of attributes to be updated on an
             entity which is identified by its type and unique attribute eg:
             Referenceable.qualifiedName. Null updates are not possible.
            
             In addition to the
             typeName path parameter, attribute key-value pair(s) can be provided in the
             following format:
            
             attr:&lt;attrName&gt;=&lt;attrValue&gt;.
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this:
             PUT
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="atlasEntityWithExtInfo" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UpdateByUniqueAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityWithExtInfo atlasEntityWithExtInfo = new AtlasEntityWithExtInfo();
Response<EntityMutationResult> response = await client.UpdateByUniqueAttributeAsync("<typeName>", atlasEntityWithExtInfo);
]]></code>
This sample shows how to call UpdateByUniqueAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

AtlasEntityWithExtInfo atlasEntityWithExtInfo = new AtlasEntityWithExtInfo
{
    ReferredEntities =
    {
        ["key"] = new AtlasEntity
        {
            Attributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            TypeName = "<typeName>",
            LastModifiedTS = "<lastModifiedTS>",
            BusinessAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Classifications = {new AtlasClassification
            {
                Attributes =
                {
                    ["key"] = BinaryData.FromObjectAsJson(new object())
                },
                TypeName = "<typeName>",
                LastModifiedTS = "<lastModifiedTS>",
                EntityGuid = "<entityGuid>",
                EntityStatus = EntityStatus.Active,
                RemovePropagationsOnEntityDelete = true,
                ValidityPeriods = {new TimeBoundary
                {
                    EndTime = "<endTime>",
                    StartTime = "<startTime>",
                    TimeZone = "<timeZone>",
                }},
            }},
            CreateTime = 1234L,
            CreatedBy = "<createdBy>",
            CustomAttributes =
            {
                ["key"] = "<customAttributes>"
            },
            Guid = "<guid>",
            HomeId = "<homeId>",
            IsIncomplete = true,
            Labels = {"<labels>"},
            Meanings = {new AtlasTermAssignmentHeader
            {
                Confidence = 1234,
                CreatedBy = "<createdBy>",
                Description = "<description>",
                DisplayText = "<displayText>",
                Expression = "<expression>",
                RelationGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
                Status = AtlasTermAssignmentStatus.Discovered,
                Steward = "<steward>",
                TermGuid = Guid.Parse("73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a"),
            }},
            ProvenanceType = 1234,
            Proxy = true,
            RelationshipAttributes =
            {
                ["key"] = BinaryData.FromObjectAsJson(new object())
            },
            Status = EntityStatus.Active,
            UpdateTime = 1234L,
            UpdatedBy = "<updatedBy>",
            Version = 1234L,
            Contacts =
            {
                ["key"] = {new ContactInfo
                {
                    Id = "<id>",
                    Info = "<info>",
                }}
            },
        }
    },
    Entity = default,
};
Response<EntityMutationResult> response = await client.UpdateByUniqueAttributeAsync("<typeName>", atlasEntityWithExtInfo, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateByUniqueAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateByUniqueAttributeAsync (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateByUniqueAttributeAsync(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateByUniqueAttributeAsync(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateByUniqueAttributeAsync (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateByUniqueAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.UpdateByUniqueAttributeAsync (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
             The qualified name of the entity. (This is only an example. qualifiedName can
             be changed to other unique attributes)
             </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
             [Protocol Method] Update entity partially - Allow a subset of attributes to be updated on an
             entity which is identified by its type and unique attribute eg:
             Referenceable.qualifiedName. Null updates are not possible.
            
             In addition to the
             typeName path parameter, attribute key-value pair(s) can be provided in the
             following format:
            
             attr:&lt;attrName&gt;=&lt;attrValue&gt;.
             NOTE: The attrName and
             attrValue should be unique across entities, eg. qualifiedName.
            
             The REST
             request would look something like this:
             PUT
             /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
             <list type="bullet"><item><description>
             This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
             </description></item><item><description>
             Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.UpdateByUniqueAttributeAsync(System.String,Azure.Analytics.Purview.DataMap.AtlasEntityWithExtInfo,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
             </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateByUniqueAttributeAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdateByUniqueAttributeAsync("<typeName>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateByUniqueAttributeAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new
{
    referredEntities = new
    {
        key = new
        {
            attributes = new
            {
                key = new object(),
            },
            typeName = "<typeName>",
            lastModifiedTS = "<lastModifiedTS>",
            businessAttributes = new
            {
                key = new object(),
            },
            classifications = new object[]
            {
                new
                {
                    attributes = new
                    {
                        key = new object(),
                    },
                    typeName = "<typeName>",
                    lastModifiedTS = "<lastModifiedTS>",
                    entityGuid = "<entityGuid>",
                    entityStatus = "ACTIVE",
                    removePropagationsOnEntityDelete = true,
                    validityPeriods = new object[]
                    {
                        new
                        {
                            endTime = "<endTime>",
                            startTime = "<startTime>",
                            timeZone = "<timeZone>",
                        }
                    },
                }
            },
            createTime = 1234L,
            createdBy = "<createdBy>",
            customAttributes = new
            {
                key = "<customAttributes>",
            },
            guid = "<guid>",
            homeId = "<homeId>",
            isIncomplete = true,
            labels = new object[]
            {
                "<labels>"
            },
            meanings = new object[]
            {
                new
                {
                    confidence = 1234,
                    createdBy = "<createdBy>",
                    description = "<description>",
                    displayText = "<displayText>",
                    expression = "<expression>",
                    relationGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                    status = "DISCOVERED",
                    steward = "<steward>",
                    termGuid = "73f411fe-4f43-4b4b-9cbd-6828d8f4cf9a",
                }
            },
            provenanceType = 1234,
            proxy = true,
            relationshipAttributes = new
            {
                key = new object(),
            },
            status = "ACTIVE",
            updateTime = 1234L,
            updatedBy = "<updatedBy>",
            version = 1234L,
            contacts = new
            {
                key = new object[]
                {
                    new
                    {
                        id = "<id>",
                        info = "<info>",
                    }
                },
            },
        },
    },
});
Response response = await client.UpdateByUniqueAttributeAsync("<typeName>", content, attribute: "<attribute>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("guidAssignments").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("mutatedEntities").GetProperty("<key>")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classificationNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("attributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("entityStatus").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("removePropagationsOnEntityDelete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("classifications")[0].GetProperty("validityPeriods")[0].GetProperty("timeZone").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("isIncomplete").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("labels")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meaningNames")[0].ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("confidence").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("displayText").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("expression").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("relationGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("steward").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("meanings")[0].GetProperty("termGuid").ToString());
Console.WriteLine(result.GetProperty("partialUpdatedEntities")[0].GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateClassifications">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateClassifications (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateClassifications(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassifications(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateClassifications (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateClassifications : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdateClassifications : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="entity.UpdateClassifications (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Update classifications to an existing entity represented by a guid.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassifications(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateClassifications.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = client.UpdateClassifications("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateClassifications with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    }
});
Response response = client.UpdateClassifications("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateClassifications">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateClassifications (string guid, System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateClassifications(string guid, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassifications(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateClassifications (guid As String, body As IEnumerable(Of AtlasClassification), Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateClassifications : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.UpdateClassifications : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.UpdateClassifications (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> An array of classifications to be updated. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Update classifications to an existing entity represented by a guid. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UpdateClassifications.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.UpdateClassifications("<guid>", new AtlasClassification[]
{
    new AtlasClassification()
});
]]></code>
This sample shows how to call UpdateClassifications with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.UpdateClassifications("<guid>", new AtlasClassification[]
{
    new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    }
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateClassificationsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateClassificationsAsync (string guid, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateClassificationsAsync(string guid, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateClassificationsAsync (guid As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateClassificationsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateClassificationsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.UpdateClassificationsAsync (guid, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Update classifications to an existing entity represented by a guid.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsAsync(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateClassificationsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = await client.UpdateClassificationsAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateClassificationsAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    }
});
Response response = await client.UpdateClassificationsAsync("<guid>", content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateClassificationsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateClassificationsAsync (string guid, System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateClassificationsAsync(string guid, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsAsync(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateClassificationsAsync (guid As String, body As IEnumerable(Of AtlasClassification), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateClassificationsAsync : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateClassificationsAsync : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.UpdateClassificationsAsync (guid, body, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="guid"> The globally unique identifier of the entity. </param>
        <param name="body"> An array of classifications to be updated. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Update classifications to an existing entity represented by a guid. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="guid" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guid" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UpdateClassificationsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.UpdateClassificationsAsync("<guid>", new AtlasClassification[]
{
    new AtlasClassification()
});
]]></code>
This sample shows how to call UpdateClassificationsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.UpdateClassificationsAsync("<guid>", new AtlasClassification[]
{
    new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    }
});
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateClassificationsUniqueByAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateClassificationsUniqueByAttribute (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateClassificationsUniqueByAttribute(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsUniqueByAttribute(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateClassificationsUniqueByAttribute (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateClassificationsUniqueByAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdateClassificationsUniqueByAttribute : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="entity.UpdateClassificationsUniqueByAttribute (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Update classification on an entity identified by its type and unique attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsUniqueByAttribute(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateClassificationsUniqueByAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = client.UpdateClassificationsUniqueByAttribute("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateClassificationsUniqueByAttribute with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    }
});
Response response = client.UpdateClassificationsUniqueByAttribute("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateClassificationsUniqueByAttribute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateClassificationsUniqueByAttribute (string typeName, System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateClassificationsUniqueByAttribute(string typeName, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsUniqueByAttribute(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateClassificationsUniqueByAttribute (typeName As String, body As IEnumerable(Of AtlasClassification), Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateClassificationsUniqueByAttribute : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.UpdateClassificationsUniqueByAttribute : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * string * System.Threading.CancellationToken -&gt; Azure.Response" Usage="entity.UpdateClassificationsUniqueByAttribute (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> An array of classification to be updated. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Update classification on an entity identified by its type and unique attributes. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UpdateClassificationsUniqueByAttribute.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.UpdateClassificationsUniqueByAttribute("<typeName>", new AtlasClassification[]
{
    new AtlasClassification()
});
]]></code>
This sample shows how to call UpdateClassificationsUniqueByAttribute with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = client.UpdateClassificationsUniqueByAttribute("<typeName>", new AtlasClassification[]
{
    new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    }
}, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateClassificationsUniqueByAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateClassificationsUniqueByAttributeAsync (string typeName, Azure.Core.RequestContent content, string attribute = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateClassificationsUniqueByAttributeAsync(string typeName, class Azure.Core.RequestContent content, string attribute, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsUniqueByAttributeAsync(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateClassificationsUniqueByAttributeAsync (typeName As String, content As RequestContent, Optional attribute As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateClassificationsUniqueByAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateClassificationsUniqueByAttributeAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.UpdateClassificationsUniqueByAttributeAsync (typeName, content, attribute, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Update classification on an entity identified by its type and unique attributes.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsUniqueByAttributeAsync(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateClassificationsUniqueByAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = await client.UpdateClassificationsUniqueByAttributeAsync("<typeName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateClassificationsUniqueByAttributeAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        attributes = new
        {
            key = new object(),
        },
        typeName = "<typeName>",
        lastModifiedTS = "<lastModifiedTS>",
        entityGuid = "<entityGuid>",
        entityStatus = "ACTIVE",
        removePropagationsOnEntityDelete = true,
        validityPeriods = new object[]
        {
            new
            {
                endTime = "<endTime>",
                startTime = "<startTime>",
                timeZone = "<timeZone>",
            }
        },
    }
});
Response response = await client.UpdateClassificationsUniqueByAttributeAsync("<typeName>", content, attribute: "<attribute>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateClassificationsUniqueByAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateClassificationsUniqueByAttributeAsync (string typeName, System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, string attribute = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateClassificationsUniqueByAttributeAsync(string typeName, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Analytics.Purview.DataMap.AtlasClassification&gt; body, string attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Analytics.Purview.DataMap.Entity.UpdateClassificationsUniqueByAttributeAsync(System.String,System.Collections.Generic.IEnumerable{Azure.Analytics.Purview.DataMap.AtlasClassification},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateClassificationsUniqueByAttributeAsync (typeName As String, body As IEnumerable(Of AtlasClassification), Optional attribute As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateClassificationsUniqueByAttributeAsync : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateClassificationsUniqueByAttributeAsync : string * seq&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt; * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="entity.UpdateClassificationsUniqueByAttributeAsync (typeName, body, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Analytics.Purview.DataMap</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="body" Type="System.Collections.Generic.IEnumerable&lt;Azure.Analytics.Purview.DataMap.AtlasClassification&gt;" />
        <Parameter Name="attribute" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="typeName"> The name of the type. </param>
        <param name="body"> An array of classification to be updated. </param>
        <param name="attribute">
            The qualified name of the entity. (This is only an example. qualifiedName can
            be changed to other unique attributes)
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Update classification on an entity identified by its type and unique attributes. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> or <paramref name="body" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UpdateClassificationsUniqueByAttributeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.UpdateClassificationsUniqueByAttributeAsync("<typeName>", new AtlasClassification[]
{
    new AtlasClassification()
});
]]></code>
This sample shows how to call UpdateClassificationsUniqueByAttributeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
Entity client = new DataMapClient(endpoint, credential).GetEntityClient();

Response response = await client.UpdateClassificationsUniqueByAttributeAsync("<typeName>", new AtlasClassification[]
{
    new AtlasClassification
    {
        Attributes =
        {
            ["key"] = BinaryData.FromObjectAsJson(new object())
        },
        TypeName = "<typeName>",
        LastModifiedTS = "<lastModifiedTS>",
        EntityGuid = "<entityGuid>",
        EntityStatus = EntityStatus.Active,
        RemovePropagationsOnEntityDelete = true,
        ValidityPeriods = {new TimeBoundary
        {
            EndTime = "<endTime>",
            StartTime = "<startTime>",
            TimeZone = "<timeZone>",
        }},
    }
}, attribute: "<attribute>");
]]></code></example>
      </Docs>
    </Member>
  </Members>
</Type>
