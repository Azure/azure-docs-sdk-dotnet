<Type Name="FabricClient+ServiceManagementClient" FullName="System.Fabric.FabricClient+ServiceManagementClient">
  <TypeSignature Language="C#" Value="public sealed class FabricClient.ServiceManagementClient" />
  <TypeSignature Language="ILAsm" Value=".class nested public auto ansi sealed beforefieldinit FabricClient/ServiceManagementClient extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Fabric.FabricClient.ServiceManagementClient" />
  <AssemblyInfo>
    <AssemblyName>System.Fabric</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>255.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <para>Represents the enabling of the services to be managed.</para>
    </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateServiceAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CreateServiceAsync (System.Fabric.Description.ServiceDescription description);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CreateServiceAsync(class System.Fabric.Description.ServiceDescription description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.CreateServiceAsync(System.Fabric.Description.ServiceDescription)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.Fabric.Description.ServiceDescription" />
      </Parameters>
      <Docs>
        <param name="description">
          <para>The configuration for the service. A <see cref="T:System.Fabric.Description.ServiceDescription" /> contains all of the information necessary to create a service.</para>
        </param>
        <summary>
          <para>Instantiates a service with specified description.</para>
        </summary>
        <returns>
          <para>The instantiated service.</para>
        </returns>
        <remarks>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
          <para>Service Fabric name will be implicitly created if it does not already exist.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="description" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateServiceAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CreateServiceAsync (System.Fabric.Description.ServiceDescription serviceDescription, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CreateServiceAsync(class System.Fabric.Description.ServiceDescription serviceDescription, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.CreateServiceAsync(System.Fabric.Description.ServiceDescription,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceDescription" Type="System.Fabric.Description.ServiceDescription" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceDescription">
          <para>The configuration for the service. A <see cref="T:System.Fabric.Description.ServiceDescription" /> contains all of the information necessary to create a service.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" />that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Instantiates a service with specified description. 
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>The instantiated service.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly created if it does not already exist.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="serviceDescription" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateServiceFromTemplateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CreateServiceFromTemplateAsync (System.Fabric.Description.ServiceFromTemplateDescription serviceFromTemplateDescription);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CreateServiceFromTemplateAsync(class System.Fabric.Description.ServiceFromTemplateDescription serviceFromTemplateDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.CreateServiceFromTemplateAsync(System.Fabric.Description.ServiceFromTemplateDescription)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceFromTemplateDescription" Type="System.Fabric.Description.ServiceFromTemplateDescription" />
      </Parameters>
      <Docs>
        <param name="serviceFromTemplateDescription">
          <para>Describes the Service to be created from service template specified in application manifest.</para>
        </param>
        <summary>
          <para>Instantiates a service from the template specified in the Application Manifest.</para>
        </summary>
        <returns>
          <para>The instantiated service.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly created if it does not already exist.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricElementNotFoundException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ServiceTemplateNotFound" />: The service template does not exist.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>The request timed out but may have already been accepted for processing by the system.</para>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <para>The request was canceled before the timeout expired but may have already been accepted for processing by the system.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateServiceFromTemplateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CreateServiceFromTemplateAsync (System.Fabric.Description.ServiceFromTemplateDescription serviceFromTemplateDescription, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CreateServiceFromTemplateAsync(class System.Fabric.Description.ServiceFromTemplateDescription serviceFromTemplateDescription, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.CreateServiceFromTemplateAsync(System.Fabric.Description.ServiceFromTemplateDescription,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceFromTemplateDescription" Type="System.Fabric.Description.ServiceFromTemplateDescription" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceFromTemplateDescription">
          <para>Describes a service to be created from service template specified in application manifest.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Instantiates a service from the template specified in the Application Manifest.</para>
        </summary>
        <returns>
          <para>The instantiated service.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly created if it does not already exist.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricElementNotFoundException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ServiceTemplateNotFound" />: The service template does not exist.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>The request timed out but may have already been accepted for processing by the system.</para>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <para>The request was canceled before the timeout expired but may have already been accepted for processing by the system.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateServiceFromTemplateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CreateServiceFromTemplateAsync (Uri applicationName, Uri serviceName, string serviceTypeName, byte[] initializationData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CreateServiceFromTemplateAsync(class System.Uri applicationName, class System.Uri serviceName, string serviceTypeName, unsigned int8[] initializationData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.CreateServiceFromTemplateAsync(System.Uri,System.Uri,System.String,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationName" Type="System.Uri" />
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="serviceTypeName" Type="System.String" />
        <Parameter Name="initializationData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="applicationName">
          <para>The Service Fabric Name of the application under which the service will be created.</para>
        </param>
        <param name="serviceName">
          <para>The Service Fabric Name of the service.</para>
        </param>
        <param name="serviceTypeName">
          <para>The name of the service type. This has to be same as the ServiceTypeName specified in the service manifest.</para>
        </param>
        <param name="initializationData">
          <para>The initialization data represents the custom data provided by the creator of the service. Service Fabric does not parse this data. 
            This data would be available in every instance or replica in <see cref="T:System.Fabric.StatefulServiceContext" /> or <see cref="T:System.Fabric.StatelessServiceContext" />.            
            It cannot be changed after the service is created. 
            </para>
        </param>
        <summary>
          <para>Instantiates a service from the template specified in the Application Manifest.</para>
        </summary>
        <returns>
          <para>The instantiated service.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly created if it does not already exist.</para>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricElementNotFoundException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ServiceTemplateNotFound" />: The service template does not exist</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>The request timed out but may have already been accepted for processing by the system.</para>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <para>The request was canceled before the timeout expired but may have already been accepted for processing by the system.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="applicationName" /> or <paramref name="serviceName" /> are null.</exception>
        <exception cref="T:System.ArgumentException">When <paramref name="serviceTypeName" /> is null or white-space.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateServiceFromTemplateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CreateServiceFromTemplateAsync (Uri applicationName, Uri serviceName, string serviceTypeName, byte[] initializationData, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CreateServiceFromTemplateAsync(class System.Uri applicationName, class System.Uri serviceName, string serviceTypeName, unsigned int8[] initializationData, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.CreateServiceFromTemplateAsync(System.Uri,System.Uri,System.String,System.Byte[],System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationName" Type="System.Uri" />
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="serviceTypeName" Type="System.String" />
        <Parameter Name="initializationData" Type="System.Byte[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="applicationName">
          <para>The Service Fabric Name of the application under which the service will be created.</para>
        </param>
        <param name="serviceName">
          <para>The Service Fabric Name of the service.</para>
        </param>
        <param name="serviceTypeName">
          <para>The name of the service type. This has to be same as the ServiceTypeName specified in the service manifest.</para>
        </param>
        <param name="initializationData">
          <para>The initialization data represents the custom data provided by the creator of the service. Service Fabric does not parse this data. 
            This data would be available in every instance or replica in <see cref="T:System.Fabric.StatefulServiceContext" /> or <see cref="T:System.Fabric.StatelessServiceContext" />.            
            It cannot be changed after the service is created. 
            </para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Instantiates a service from the template specified in the Application Manifest.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>The instantiated service.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly created if it does not already exist.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricElementNotFoundException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ServiceTemplateNotFound" />: The service template does not exist.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>The request timed out but may have already been accepted for processing by the system.</para>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <para>The request was canceled before the timeout expired but may have already been accepted for processing by the system.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="applicationName" /> or <paramref name="serviceName" /> are null.</exception>
        <exception cref="T:System.ArgumentException">When <paramref name="serviceTypeName" /> is null or white-space.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteServiceAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task DeleteServiceAsync (System.Fabric.Description.DeleteServiceDescription deleteServiceDescription);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task DeleteServiceAsync(class System.Fabric.Description.DeleteServiceDescription deleteServiceDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.DeleteServiceAsync(System.Fabric.Description.DeleteServiceDescription)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deleteServiceDescription" Type="System.Fabric.Description.DeleteServiceDescription" />
      </Parameters>
      <Docs>
        <param name="deleteServiceDescription">
          <para>The description of the service to be deleted.</para>
        </param>
        <summary>
          <para>Deletes the specified service instance.</para>
        </summary>
        <returns>
          <para>The deleted service instance.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly and recursively deleted if the application is Service Fabric managed.</para>
          <para>A forceful deletion call can convert on-going normal deletion to forceful one.</para>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="deleteServiceDescription" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteServiceAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task DeleteServiceAsync (Uri serviceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task DeleteServiceAsync(class System.Uri serviceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.DeleteServiceAsync(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This API is deprecated, use overload taking DeleteServiceDescription instead.", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric name of the service.</para>
        </param>
        <summary>
          <para>Deletes the specified service instance.</para>
        </summary>
        <returns>
          <para>The deleted service instance.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly and recursively deleted if the application is Service Fabric managed.</para>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="serviceName" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteServiceAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task DeleteServiceAsync (System.Fabric.Description.DeleteServiceDescription deleteServiceDescription, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task DeleteServiceAsync(class System.Fabric.Description.DeleteServiceDescription deleteServiceDescription, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.DeleteServiceAsync(System.Fabric.Description.DeleteServiceDescription,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deleteServiceDescription" Type="System.Fabric.Description.DeleteServiceDescription" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="deleteServiceDescription">
          <para>The description of the service to be deleted.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Deletes the specified service instance.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>The deleted service instance.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly and recursively deleted if the application is Service Fabric managed.</para>
          <para>A forceful deletion call can convert on-going normal deletion to forceful one.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="deleteServiceDescription" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteServiceAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task DeleteServiceAsync (Uri serviceName, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task DeleteServiceAsync(class System.Uri serviceName, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.DeleteServiceAsync(System.Uri,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This API is deprecated, use overload taking DeleteServiceDescription instead.", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric name of the service.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Deletes the specified service instance.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>The deleted service instance.</para>
        </returns>
        <remarks>
          <para>Service Fabric name will be implicitly and recursively deleted if the application is Service Fabric managed.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="serviceName" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetServiceDescriptionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.Description.ServiceDescription&gt; GetServiceDescriptionAsync (Uri serviceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.Description.ServiceDescription&gt; GetServiceDescriptionAsync(class System.Uri serviceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.GetServiceDescriptionAsync(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.Description.ServiceDescription&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service.</para>
        </param>
        <summary>
          <para>Gets the Service Description for the specified service instance.</para>
        </summary>
        <returns>
          <para>The Service Description for the specified service instance.</para>
        </returns>
        <remarks>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
          <para>
            <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.GetServiceDescriptionAsync(System.Uri)" /> is the most efficient way of determining whether a name is associated with a service.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="serviceName" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetServiceDescriptionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.Description.ServiceDescription&gt; GetServiceDescriptionAsync (Uri serviceName, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.Description.ServiceDescription&gt; GetServiceDescriptionAsync(class System.Uri serviceName, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.GetServiceDescriptionAsync(System.Uri,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.Description.ServiceDescription&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service. </para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Gets the Service Description for the specified service instance.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>The Service Description for the specified service instance.</para>
        </returns>
        <remarks>
          <para>
            <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.GetServiceDescriptionAsync(System.Uri)" /> is the most efficient way of determining whether a name is associated with a service.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="serviceName" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetServiceManifestAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;string&gt; GetServiceManifestAsync (string applicationTypeName, string applicationTypeVersion, string serviceManifestName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;string&gt; GetServiceManifestAsync(string applicationTypeName, string applicationTypeVersion, string serviceManifestName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.GetServiceManifestAsync(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationTypeName" Type="System.String" />
        <Parameter Name="applicationTypeVersion" Type="System.String" />
        <Parameter Name="serviceManifestName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="applicationTypeName">
          <para>The name of the provisioned application manifest.</para>
        </param>
        <param name="applicationTypeVersion">
          <para>The version of the provisioned application manifest.</para>
        </param>
        <param name="serviceManifestName">
          <para>The name of the service manifest referenced in the application manifest.</para>
        </param>
        <summary>
          <para>Gets the provisioned service manifest document in the specified application type name and application type version.</para>
        </summary>
        <returns>
          <para>The provisioned service manifest document.</para>
        </returns>
        <remarks>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetServiceManifestAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;string&gt; GetServiceManifestAsync (string applicationTypeName, string applicationTypeVersion, string serviceManifestName, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;string&gt; GetServiceManifestAsync(string applicationTypeName, string applicationTypeVersion, string serviceManifestName, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.GetServiceManifestAsync(System.String,System.String,System.String,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationTypeName" Type="System.String" />
        <Parameter Name="applicationTypeVersion" Type="System.String" />
        <Parameter Name="serviceManifestName" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="applicationTypeName">
          <para>The name of the provisioned application manifest.</para>
        </param>
        <param name="applicationTypeVersion">
          <para>The version of the provisioned application manifest.</para>
        </param>
        <param name="serviceManifestName">
          <para>The name of the service manifest referenced in the application manifest.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Gets the provisioned service manifest document in the specified application type name and application type version.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>The provisioned service manifest document</para>
        </returns>
        <remarks>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentException">If <paramref name="applicationTypeName" /> or <paramref name="applicationTypeVersion" /> or <paramref name="serviceManifestName" /> are null/empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterServiceNotificationFilterAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;long&gt; RegisterServiceNotificationFilterAsync (System.Fabric.Description.ServiceNotificationFilterDescription description);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int64&gt; RegisterServiceNotificationFilterAsync(class System.Fabric.Description.ServiceNotificationFilterDescription description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServiceNotificationFilterAsync(System.Fabric.Description.ServiceNotificationFilterDescription)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.Fabric.Description.ServiceNotificationFilterDescription" />
      </Parameters>
      <Docs>
        <param name="description">
          <para>The description that determines which service endpoint change events should be delivered to this client through the <see cref="E:System.Fabric.FabricClient.ServiceManagementClient.ServiceNotificationFilterMatched" /> event.</para>
        </param>
        <summary>
          <para>Registers a <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" />.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Threading.Tasks.Task" /> representing the async operation. The task result is an ID corresponding to the registered <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" /> that can be used to unregister the same filter through <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.UnregisterServiceNotificationFilterAsync(System.Int64)" />.</para>
        </returns>
        <remarks>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">If <paramref name="description" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterServiceNotificationFilterAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;long&gt; RegisterServiceNotificationFilterAsync (System.Fabric.Description.ServiceNotificationFilterDescription description, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int64&gt; RegisterServiceNotificationFilterAsync(class System.Fabric.Description.ServiceNotificationFilterDescription description, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServiceNotificationFilterAsync(System.Fabric.Description.ServiceNotificationFilterDescription,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.Fabric.Description.ServiceNotificationFilterDescription" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="description">
          <para>The description that determines which service endpoint change events should be delivered to this client through the <see cref="E:System.Fabric.FabricClient.ServiceManagementClient.ServiceNotificationFilterMatched" /> event.</para>
        </param>
        <param name="timeout">
          <para>The maximum time allowed for processing the request before <see cref="T:System.TimeoutException" /> is thrown.</para>
        </param>
        <param name="cancellationToken">
          <para>Reserved for future use.</para>
        </param>
        <summary>
          <para>Registers a <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" />.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Threading.Tasks.Task" /> representing the async operation. The task result is an ID corresponding to the registered <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" /> that can be used to unregister the same filter through <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.UnregisterServiceNotificationFilterAsync(System.Int64)" />.</para>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">If <paramref name="description" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterServicePartitionResolutionChangeHandler">
      <MemberSignature Language="C#" Value="public long RegisterServicePartitionResolutionChangeHandler (Uri serviceName, System.Fabric.ServicePartitionResolutionChangeHandler callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 RegisterServicePartitionResolutionChangeHandler(class System.Uri serviceName, class System.Fabric.ServicePartitionResolutionChangeHandler callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServicePartitionResolutionChangeHandler(System.Uri,System.Fabric.ServicePartitionResolutionChangeHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="callback" Type="System.Fabric.ServicePartitionResolutionChangeHandler" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service.</para>
        </param>
        <param name="callback">
          <para>The function that will be called when a notification arrives.</para>
        </param>
        <summary>
          <para>This API is deprecated, use <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServiceNotificationFilterAsync(System.Fabric.Description.ServiceNotificationFilterDescription)" /> instead.</para>
        </summary>
        <returns>
          <para>The handler to be raised when the accessibility information of a service partition changes.</para>
        </returns>
        <remarks>
          <para>Notification will include changes on partition’s endpoints or exceptions that occurred while the information was being updated. This overload is used for Singleton partitioned service instances. Returned Int64 is the callback handle identifier for the registration.</para>
          <para>Notifications is a mechanism that delivers notifications to user’s code each time there is an service address change or an address resolution error related to a service partition the code has raised interest for. This way instead of resolving every time the current <see cref="T:System.Fabric.ResolvedServicePartition" /> becomes stale, program registers for updates.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">If <paramref name="serviceName" /> or <paramref name="callback" /> are null.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterServicePartitionResolutionChangeHandler">
      <MemberSignature Language="C#" Value="public long RegisterServicePartitionResolutionChangeHandler (Uri serviceName, long partitionKey, System.Fabric.ServicePartitionResolutionChangeHandler callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 RegisterServicePartitionResolutionChangeHandler(class System.Uri serviceName, int64 partitionKey, class System.Fabric.ServicePartitionResolutionChangeHandler callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServicePartitionResolutionChangeHandler(System.Uri,System.Int64,System.Fabric.ServicePartitionResolutionChangeHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.Int64" />
        <Parameter Name="callback" Type="System.Fabric.ServicePartitionResolutionChangeHandler" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="callback">
          <para>The function that will be called when a notification arrives.</para>
        </param>
        <summary>
          <para>This API is deprecated, use <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServiceNotificationFilterAsync(System.Fabric.Description.ServiceNotificationFilterDescription)" /> instead.</para>
        </summary>
        <returns>
          <para>The handler to be raised when the accessibility information of a service partition changes.</para>
        </returns>
        <remarks>
          <para>Notification will include changes on partition’s endpoints or exceptions that occurred while the information was being updated. This overload is used for UniformInt64Range partitioned service instances. Returned Int64 is the callback handle identifier for the registration.</para>
          <para>Notifications is a mechanism that delivers notifications to user’s code each time there is an service address change or an address resolution error related to a service partition the code has raised interest for. This way instead of resolving every time the current <see cref="T:System.Fabric.ResolvedServicePartition" /> becomes stale, program registers for updates.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">If <paramref name="serviceName" /> or <paramref name="callback" /> are null.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterServicePartitionResolutionChangeHandler">
      <MemberSignature Language="C#" Value="public long RegisterServicePartitionResolutionChangeHandler (Uri serviceName, string partitionKey, System.Fabric.ServicePartitionResolutionChangeHandler callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 RegisterServicePartitionResolutionChangeHandler(class System.Uri serviceName, string partitionKey, class System.Fabric.ServicePartitionResolutionChangeHandler callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServicePartitionResolutionChangeHandler(System.Uri,System.String,System.Fabric.ServicePartitionResolutionChangeHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.String" />
        <Parameter Name="callback" Type="System.Fabric.ServicePartitionResolutionChangeHandler" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="callback">
          <para>The function that will be called when a notification arrives.</para>
        </param>
        <summary>
          <para>This API is deprecated, use <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServiceNotificationFilterAsync(System.Fabric.Description.ServiceNotificationFilterDescription)" /> instead.</para>
        </summary>
        <returns>
          <para>The handler to be raised when the accessibility information of a service partition changes.</para>
        </returns>
        <remarks>
          <para>Notification will include changes on partition’s endpoints or exceptions that occurred while the information was being updated. This overload is used for Named partitioned service instances. Returned Int64 is the callback handle identifier for the registration.</para>
          <para>Notifications is a mechanism that delivers notifications to user’s code each time there is an service address change or an address resolution error related to a service partition the code has raised interest for. This way instead of resolving every time the current <see cref="T:System.Fabric.ResolvedServicePartition" /> becomes stale, program registers for updates.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">If <paramref name="serviceName" /> or <paramref name="callback" /> are null.</exception>
        <exception cref="T:System.ArgumentException">If <paramref name="partitionKey" /> is null or empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveReplicaAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RemoveReplicaAsync (string nodeName, Guid partitionId, long replicaOrInstanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RemoveReplicaAsync(string nodeName, valuetype System.Guid partitionId, int64 replicaOrInstanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RemoveReplicaAsync(System.String,System.Guid,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeName" Type="System.String" />
        <Parameter Name="partitionId" Type="System.Guid" />
        <Parameter Name="replicaOrInstanceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="nodeName">
          <para>The name of the node.</para>
        </param>
        <param name="partitionId">
          <para>The partition identifier.</para>
        </param>
        <param name="replicaOrInstanceId">
          <para>The instance identifier.</para>
        </param>
        <summary>
          <para>Removes a service replica running on a node.</para>
        </summary>
        <returns>
          <para>A Task representing the acknowledgment of the request.</para>
        </returns>
        <remarks>
          <para>This API gives a running replica the chance to cleanup its state and be gracefully shutdown. </para>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
          <para>WARNING: There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ReplicaDoesNotExist" /> is returned if the replica or instance id is not running on the node.</para>
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.InvalidReplicaStateForReplicaOperation" /> is returned if the replica or instance id cannot be restarted or removed at this time as it is in an invalid state. For example, the replica is already in the process of being closed.</para>
          <para>
                See also <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.ArgumentException">If <paramref name="nodeName" /> is null or empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveReplicaAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RemoveReplicaAsync (string nodeName, Guid partitionId, long replicaOrInstanceId, bool forceRemove);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RemoveReplicaAsync(string nodeName, valuetype System.Guid partitionId, int64 replicaOrInstanceId, bool forceRemove) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RemoveReplicaAsync(System.String,System.Guid,System.Int64,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeName" Type="System.String" />
        <Parameter Name="partitionId" Type="System.Guid" />
        <Parameter Name="replicaOrInstanceId" Type="System.Int64" />
        <Parameter Name="forceRemove" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nodeName">
          <para>The name of the node.</para>
        </param>
        <param name="partitionId">
          <para>The partition identifier.</para>
        </param>
        <param name="replicaOrInstanceId">
          <para>The instance identifier.</para>
        </param>
        <param name="forceRemove">
          <para>Specifies whether the replica should be given a chance to gracefully clean up its state and close</para>
        </param>
        <summary>
          <para>Removes a service replica running on a node.</para>
        </summary>
        <returns>
          <para>A Task representing the acknowledgment of the request.</para>
        </returns>
        <remarks>
          <para>This API gives a running replica the chance to cleanup its state and be gracefully shutdown. </para>
          <para>If the forceRemove flag is set then no such opportunity is given. Service Fabric will terminate the host for that replica and any persisted state of that replica will be leaked. </para>
          <para>WARNING: There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.</para>
          <para>In addition, the forceRemove flag impacts all other replicas hosted in the same process.</para>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ReplicaDoesNotExist" /> is returned if the replica or instance id is not running on the node.</para>
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.InvalidReplicaStateForReplicaOperation" /> is returned if the replica or instance id cannot be restarted or removed at this time as it is in an invalid state. For example, the replica is already in the process of being closed.</para>
          <para>
                See also <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.ArgumentException">If <paramref name="nodeName" /> is null or empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveReplicaAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RemoveReplicaAsync (string nodeName, Guid partitionId, long replicaOrInstanceId, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RemoveReplicaAsync(string nodeName, valuetype System.Guid partitionId, int64 replicaOrInstanceId, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RemoveReplicaAsync(System.String,System.Guid,System.Int64,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeName" Type="System.String" />
        <Parameter Name="partitionId" Type="System.Guid" />
        <Parameter Name="replicaOrInstanceId" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="nodeName">
          <para>The name of the node.</para>
        </param>
        <param name="partitionId">
          <para>The partition identifier.</para>
        </param>
        <param name="replicaOrInstanceId">
          <para>The instance identifier.</para>
        </param>
        <param name="timeout">
          <para>The timespan that defines the maximum amount of time  will allow this operation to continue before returning a <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The optional cancellation token that the operation is observing. It can be used to send a notification that the operation should be canceled. Note that cancellation is advisory and that the operation may still be completed even if it is cancelled.</para>
        </param>
        <summary>
          <para>Removes a service replica running on a node.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>A Task representing the acknowledgment of the request.</para>
        </returns>
        <remarks>
          <para>This API gives a running replica the chance to cleanup its state and be gracefully shutdown. </para>
          <para>WARNING: There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ReplicaDoesNotExist" /> is returned if the replica or instance id is not running on the node.</para>
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.InvalidReplicaStateForReplicaOperation" /> is returned if the replica or instance id cannot be restarted or removed at this time as it is in an invalid state. For example, the replica is already in the process of being closed.</para>
          <para>
                See also <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.ArgumentException">If <paramref name="nodeName" /> is null or empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveReplicaAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RemoveReplicaAsync (string nodeName, Guid partitionId, long replicaOrInstanceId, bool forceRemove, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RemoveReplicaAsync(string nodeName, valuetype System.Guid partitionId, int64 replicaOrInstanceId, bool forceRemove, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RemoveReplicaAsync(System.String,System.Guid,System.Int64,System.Boolean,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeName" Type="System.String" />
        <Parameter Name="partitionId" Type="System.Guid" />
        <Parameter Name="replicaOrInstanceId" Type="System.Int64" />
        <Parameter Name="forceRemove" Type="System.Boolean" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="nodeName">
          <para>The name of the node.</para>
        </param>
        <param name="partitionId">
          <para>The partition identifier.</para>
        </param>
        <param name="replicaOrInstanceId">
          <para>The instance identifier.</para>
        </param>
        <param name="forceRemove">
          <para>Specifies whether the replica should be given a chance to gracefully clean up its state and close</para>
        </param>
        <param name="timeout">
          <para>The timespan that defines the maximum amount of time  will allow this operation to continue before returning a <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The optional cancellation token that the operation is observing. It can be used to send a notification that the operation should be canceled. Note that cancellation is advisory and that the operation may still be completed even if it is cancelled.</para>
        </param>
        <summary>
          <para>Removes a service replica running on a node.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>A Task representing the acknowledgment of the request.</para>
        </returns>
        <remarks>
          <para>This API gives a running replica the chance to cleanup its state and be gracefully shutdown. </para>
          <para>If the forceRemove flag is set then no such opportunity is given. Service Fabric will terminate the host for that replica and any persisted state of that replica will be leaked. </para>
          <para>WARNING: There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.</para>
          <para>In addition, the forceRemove flag impacts all other replicas hosted in the same process.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ReplicaDoesNotExist" /> is returned if the replica or instance id is not running on the node.</para>
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.InvalidReplicaStateForReplicaOperation" /> is returned if the replica or instance id cannot be restarted or removed at this time as it is in an invalid state. For example, the replica is already in the process of being closed.</para>
          <para>
                See also <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.ArgumentException">If <paramref name="nodeName" /> is null or empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>The <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri)" /> will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, System.Fabric.ResolvedServicePartition previousResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, class System.Fabric.ResolvedServicePartition previousResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Fabric.ResolvedServicePartition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="previousResult">
          <para>The Previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>A complaint based resolution API.</para>
          <para>This method will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available. </para>
          <para>PreviousResult argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the previousResult argument or previousResult argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, long partitionKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, int64 partitionKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This method will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition. </para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, string partitionKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, string partitionKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, System.Fabric.ResolvedServicePartition previousResult, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, class System.Fabric.ResolvedServicePartition previousResult, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Fabric.ResolvedServicePartition,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="previousResult">
          <para>The Previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This method will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available.</para>
          <para>PreviousResult argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the previousResult argument or previousResult argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, long partitionKey, System.Fabric.ResolvedServicePartition previousResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, int64 partitionKey, class System.Fabric.ResolvedServicePartition previousResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Int64,System.Fabric.ResolvedServicePartition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.Int64" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="previousResult">
          <para>The Previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available. </para>
          <para>PreviousResult argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the previousResult argument or previousResult argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, long partitionKey, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, int64 partitionKey, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Int64,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, string partitionKey, System.Fabric.ResolvedServicePartition previousResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, string partitionKey, class System.Fabric.ResolvedServicePartition previousResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.String,System.Fabric.ResolvedServicePartition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.String" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="previousResult">
          <para>The previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available.</para>
          <para>The PreviousResult argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the previousResult argument or previousResult argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, string partitionKey, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, string partitionKey, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, System.Fabric.ResolvedServicePartition previousResult, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, class System.Fabric.ResolvedServicePartition previousResult, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Fabric.ResolvedServicePartition,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="previousResult">
          <para>Previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" />that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This method will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available.</para>
          <para>
            <paramref name="previousResult" /> argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the <paramref name="previousResult" /> argument or <paramref name="previousResult" /> argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, long partitionKey, System.Fabric.ResolvedServicePartition previousResult, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, int64 partitionKey, class System.Fabric.ResolvedServicePartition previousResult, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Int64,System.Fabric.ResolvedServicePartition,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.Int64" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="previousResult">
          <para>Previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available.</para>
          <para>PreviousResult argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the previousResult argument or previousResult argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, long partitionKey, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, int64 partitionKey, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Int64,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, string partitionKey, System.Fabric.ResolvedServicePartition previousResult, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, string partitionKey, class System.Fabric.ResolvedServicePartition previousResult, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.String,System.Fabric.ResolvedServicePartition,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.String" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="previousResult">
          <para>The previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available.</para>
          <para>The PreviousResult argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the previousResult argument or previousResult argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, string partitionKey, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, string partitionKey, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.String,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will always return the closest <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, long partitionKey, System.Fabric.ResolvedServicePartition previousResult, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, int64 partitionKey, class System.Fabric.ResolvedServicePartition previousResult, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.Int64,System.Fabric.ResolvedServicePartition,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.Int64" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="previousResult">
          <para>Previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>
            <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available.</para>
          <para>PreviousResult argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the previousResult argument or previousResult argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveServicePartitionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync (Uri serviceName, string partitionKey, System.Fabric.ResolvedServicePartition previousResult, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Fabric.ResolvedServicePartition&gt; ResolveServicePartitionAsync(class System.Uri serviceName, string partitionKey, class System.Fabric.ResolvedServicePartition previousResult, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.ResolveServicePartitionAsync(System.Uri,System.String,System.Fabric.ResolvedServicePartition,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Fabric.ResolvedServicePartition&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.Uri" />
        <Parameter Name="partitionKey" Type="System.String" />
        <Parameter Name="previousResult" Type="System.Fabric.ResolvedServicePartition" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="serviceName">
          <para>The Service Fabric Name of the service instance.</para>
        </param>
        <param name="partitionKey">
          <para>The partition key for the service partition.</para>
        </param>
        <param name="previousResult">
          <para>The previous <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition that the user believes is stale.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Queries the system for the set of endpoints the specified service partition is listening to.</para>
        </summary>
        <returns>
          <para>The set of endpoints the specified service partition is listening to.</para>
        </returns>
        <remarks>
          <para>This is a complaint based resolution API.</para>
          <para>This will return a <see cref="T:System.Fabric.ResolvedServicePartition" /> for the specified service partition. When this overload is used, the system will return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> than the “previousResult” argument if it is available.</para>
          <para>The PreviousResult argument enables the user to say ”This is the previous list of endpoints for this Service partition. I have tried the endpoints and I believe they are stale. Return me a more up to date version of this set.” In this case, the system will try to return a more up-to-date <see cref="T:System.Fabric.ResolvedServicePartition" /> in the most efficient way possible. If no newer version can be found, a <see cref="T:System.Fabric.ResolvedServicePartition" /> with the same version will be returned.ResolveServicePartition can be called without the previousResult argument or previousResult argument set to null. As no prerequisite is specified, the system will return the closest copy of the <see cref="T:System.Fabric.ResolvedServicePartition" /> for the service partition.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RestartReplicaAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RestartReplicaAsync (string nodeName, Guid partitionId, long replicaOrInstanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RestartReplicaAsync(string nodeName, valuetype System.Guid partitionId, int64 replicaOrInstanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RestartReplicaAsync(System.String,System.Guid,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeName" Type="System.String" />
        <Parameter Name="partitionId" Type="System.Guid" />
        <Parameter Name="replicaOrInstanceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="nodeName">
          <para>The name of the node.</para>
        </param>
        <param name="partitionId">
          <para>The partition identifier.</para>
        </param>
        <param name="replicaOrInstanceId">
          <para>The instance identifier.</para>
        </param>
        <summary>
          <para>Restarts a service replica of a persisted service running on a node.</para>
        </summary>
        <returns>
          <para>A Task representing the acknowledgment of the request.</para>
        </returns>
        <remarks>
          <para>WARNING: There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.</para>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ReplicaDoesNotExist" /> is returned if the replica or instance id is not running on the node.</para>
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.InvalidReplicaStateForReplicaOperation" /> is returned if the replica or instance id cannot be restarted or removed at this time as it is in an invalid state. For example, the replica is already in the process of being closed.</para>
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.InvalidReplicaOperation" /> is returned if the replica does not belong to a stateful persisted service. Only stateful persisted replicas can be restarted.</para>
          <para>
                See also <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.ArgumentException">If <paramref name="nodeName" /> is null or empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartReplicaAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RestartReplicaAsync (string nodeName, Guid partitionId, long replicaOrInstanceId, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RestartReplicaAsync(string nodeName, valuetype System.Guid partitionId, int64 replicaOrInstanceId, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.RestartReplicaAsync(System.String,System.Guid,System.Int64,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeName" Type="System.String" />
        <Parameter Name="partitionId" Type="System.Guid" />
        <Parameter Name="replicaOrInstanceId" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="nodeName">
          <para>The name of the node.</para>
        </param>
        <param name="partitionId">
          <para>The partition identifier.</para>
        </param>
        <param name="replicaOrInstanceId">
          <para>The instance identifier.</para>
        </param>
        <param name="timeout">
          <para>The timespan that defines the maximum amount of time  will allow this operation to continue before returning a <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The optional cancellation token that the operation is observing. It can be used to send a notification that the operation should be canceled. Note that cancellation is advisory and that the operation may still be completed even if it is cancelled.</para>
        </param>
        <summary>
          <para>Restarts a service replica of a persisted service running on a node.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>A Task representing the acknowledgment of the request.</para>
        </returns>
        <remarks>
          <para>WARNING: There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.</para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.TimeoutException">
          <para>
                See <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.Fabric.FabricException">
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.ReplicaDoesNotExist" /> is returned if the replica or instance id is not running on the node.</para>
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.InvalidReplicaStateForReplicaOperation" /> is returned if the replica or instance id cannot be restarted or removed at this time as it is in an invalid state. For example, the replica is already in the process of being closed.</para>
          <para>
            <see cref="F:System.Fabric.FabricErrorCode.InvalidReplicaOperation" /> is returned if the replica does not belong to a stateful persisted service. Only stateful persisted replicas can be restarted.</para>
          <para>
                See also <see href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-errors-and-exceptions" /> for handling common FabricClient failures.</para>
        </exception>
        <exception cref="T:System.ArgumentException">If <paramref name="nodeName" /> is null or empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServiceNotificationFilterMatched">
      <MemberSignature Language="C#" Value="public event EventHandler ServiceNotificationFilterMatched;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ServiceNotificationFilterMatched" />
      <MemberSignature Language="DocId" Value="E:System.Fabric.FabricClient.ServiceManagementClient.ServiceNotificationFilterMatched" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Raised when a <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" /> previously registered through <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServiceNotificationFilterAsync(System.Fabric.Description.ServiceNotificationFilterDescription)" /> is matched by a service's endpoint changes in system.</para>
        </summary>
        <remarks>
            The event argument is of type <see cref="T:System.Fabric.FabricClient.ServiceManagementClient.ServiceNotificationEventArgs" />.
            </remarks>
        <example>
            The following example shows how to register for and process service notifications:
            <code language="cs">
            namespace ServiceNotificationsExample
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        var client = new FabricClient(new string[] { "[cluster_endpoint]:[client_port]" });
            
                        var filter = new ServiceNotificationFilterDescription()
                        {
                            Name = new Uri("fabric:/my_application"),
                            MatchNamePrefix = true,
                        };
            
                        client.ServiceManager.ServiceNotificationFilterMatched += (s, e) =&gt; OnNotification(e);
            
                        var filterId = client.ServiceManager.RegisterServiceNotificationFilterAsync(filter).Result;
            
                        Console.WriteLine(
                            "Registered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
            
                        Console.ReadLine();
            
                        client.ServiceManager.UnregisterServiceNotificationFilterAsync(filterId).Wait();
            
                        Console.WriteLine(
                            "Unregistered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
                    }
            
                    private static void OnNotification(EventArgs e)
                    {
                        var castedEventArgs = (FabricClient.ServiceManagementClient.ServiceNotificationEventArgs)e;
            
                        var notification = castedEventArgs.Notification;
            
                        Console.WriteLine(
                            "[{0}] received notification for service '{1}'",
                            DateTime.UtcNow,
                            notification.ServiceName);
                    }
                }
            }
            </code></example>
        <example>
            The following example shows how to register for and process service notifications:
            <code language="cs">
            namespace ServiceNotificationsExample
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        var client = new FabricClient(new string[] { "[cluster_endpoint]:[client_port]" });
            
                        var filter = new ServiceNotificationFilterDescription()
                        {
                            Name = new Uri("fabric:/my_application"),
                            MatchNamePrefix = true,
                        };
            
                        client.ServiceManager.ServiceNotificationFilterMatched += (s, e) =&gt; OnNotification(e);
            
                        var filterId = client.ServiceManager.RegisterServiceNotificationFilterAsync(filter).Result;
            
                        Console.WriteLine(
                            "Registered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
            
                        Console.ReadLine();
            
                        client.ServiceManager.UnregisterServiceNotificationFilterAsync(filterId).Wait();
            
                        Console.WriteLine(
                            "Unregistered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
                    }
            
                    private static void OnNotification(EventArgs e)
                    {
                        var castedEventArgs = (FabricClient.ServiceManagementClient.ServiceNotificationEventArgs)e;
            
                        var notification = castedEventArgs.Notification;
            
                        Console.WriteLine(
                            "[{0}] received notification for service '{1}'",
                            DateTime.UtcNow,
                            notification.ServiceName);
                    }
                }
            }
            </code></example>
        <example>
            The following example shows how to register for and process service notifications:
            <code language="cs">
            namespace ServiceNotificationsExample
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        var client = new FabricClient(new string[] { "[cluster_endpoint]:[client_port]" });
            
                        var filter = new ServiceNotificationFilterDescription()
                        {
                            Name = new Uri("fabric:/my_application"),
                            MatchNamePrefix = true,
                        };
            
                        client.ServiceManager.ServiceNotificationFilterMatched += (s, e) =&gt; OnNotification(e);
            
                        var filterId = client.ServiceManager.RegisterServiceNotificationFilterAsync(filter).Result;
            
                        Console.WriteLine(
                            "Registered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
            
                        Console.ReadLine();
            
                        client.ServiceManager.UnregisterServiceNotificationFilterAsync(filterId).Wait();
            
                        Console.WriteLine(
                            "Unregistered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
                    }
            
                    private static void OnNotification(EventArgs e)
                    {
                        var castedEventArgs = (FabricClient.ServiceManagementClient.ServiceNotificationEventArgs)e;
            
                        var notification = castedEventArgs.Notification;
            
                        Console.WriteLine(
                            "[{0}] received notification for service '{1}'",
                            DateTime.UtcNow,
                            notification.ServiceName);
                    }
                }
            }
            </code></example>
        <example>
            The following example shows how to register for and process service notifications:
            <code language="cs">
            namespace ServiceNotificationsExample
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        var client = new FabricClient(new string[] { "[cluster_endpoint]:[client_port]" });
            
                        var filter = new ServiceNotificationFilterDescription()
                        {
                            Name = new Uri("fabric:/my_application"),
                            MatchNamePrefix = true,
                        };
            
                        client.ServiceManager.ServiceNotificationFilterMatched += (s, e) =&gt; OnNotification(e);
            
                        var filterId = client.ServiceManager.RegisterServiceNotificationFilterAsync(filter).Result;
            
                        Console.WriteLine(
                            "Registered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
            
                        Console.ReadLine();
            
                        client.ServiceManager.UnregisterServiceNotificationFilterAsync(filterId).Wait();
            
                        Console.WriteLine(
                            "Unregistered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
                    }
            
                    private static void OnNotification(EventArgs e)
                    {
                        var castedEventArgs = (FabricClient.ServiceManagementClient.ServiceNotificationEventArgs)e;
            
                        var notification = castedEventArgs.Notification;
            
                        Console.WriteLine(
                            "[{0}] received notification for service '{1}'",
                            DateTime.UtcNow,
                            notification.ServiceName);
                    }
                }
            }
            </code></example>
        <example>
            The following example shows how to register for and process service notifications:
            <code language="cs">
            namespace ServiceNotificationsExample
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        var client = new FabricClient(new string[] { "[cluster_endpoint]:[client_port]" });
            
                        var filter = new ServiceNotificationFilterDescription()
                        {
                            Name = new Uri("fabric:/my_application"),
                            MatchNamePrefix = true,
                        };
            
                        client.ServiceManager.ServiceNotificationFilterMatched += (s, e) =&gt; OnNotification(e);
            
                        var filterId = client.ServiceManager.RegisterServiceNotificationFilterAsync(filter).Result;
            
                        Console.WriteLine(
                            "Registered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
            
                        Console.ReadLine();
            
                        client.ServiceManager.UnregisterServiceNotificationFilterAsync(filterId).Wait();
            
                        Console.WriteLine(
                            "Unregistered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
                    }
            
                    private static void OnNotification(EventArgs e)
                    {
                        var castedEventArgs = (FabricClient.ServiceManagementClient.ServiceNotificationEventArgs)e;
            
                        var notification = castedEventArgs.Notification;
            
                        Console.WriteLine(
                            "[{0}] received notification for service '{1}'",
                            DateTime.UtcNow,
                            notification.ServiceName);
                    }
                }
            }
            </code></example>
        <example>
            The following example shows how to register for and process service notifications:
            <code language="cs">
            namespace ServiceNotificationsExample
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        var client = new FabricClient(new string[] { "[cluster_endpoint]:[client_port]" });
            
                        var filter = new ServiceNotificationFilterDescription()
                        {
                            Name = new Uri("fabric:/my_application"),
                            MatchNamePrefix = true,
                        };
            
                        client.ServiceManager.ServiceNotificationFilterMatched += (s, e) =&gt; OnNotification(e);
            
                        var filterId = client.ServiceManager.RegisterServiceNotificationFilterAsync(filter).Result;
            
                        Console.WriteLine(
                            "Registered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
            
                        Console.ReadLine();
            
                        client.ServiceManager.UnregisterServiceNotificationFilterAsync(filterId).Wait();
            
                        Console.WriteLine(
                            "Unregistered filter: name={0} id={1}",
                            filter.Name,
                            filterId);
                    }
            
                    private static void OnNotification(EventArgs e)
                    {
                        var castedEventArgs = (FabricClient.ServiceManagementClient.ServiceNotificationEventArgs)e;
            
                        var notification = castedEventArgs.Notification;
            
                        Console.WriteLine(
                            "[{0}] received notification for service '{1}'",
                            DateTime.UtcNow,
                            notification.ServiceName);
                    }
                }
            }
            </code></example>
      </Docs>
    </Member>
    <Member MemberName="UnregisterServiceNotificationFilterAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task UnregisterServiceNotificationFilterAsync (long filterId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task UnregisterServiceNotificationFilterAsync(int64 filterId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.UnregisterServiceNotificationFilterAsync(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filterId">
          <para>The ID of a previously registered <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" /> returned from <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServiceNotificationFilterAsync(System.Fabric.Description.ServiceNotificationFilterDescription)" />.</para>
        </param>
        <summary>
          <para>Unregisters a previously registered <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" />.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Threading.Tasks.Task" /> representing the async operation.</para>
        </returns>
        <remarks>
          <para>It's not necessary to unregister individual filters if the client itself will no longer be used since all <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" /> objects registered by the <see cref="T:System.Fabric.FabricClient" /> will be automatically unregistered when client is disposed.</para>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterServiceNotificationFilterAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task UnregisterServiceNotificationFilterAsync (long filterId, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task UnregisterServiceNotificationFilterAsync(int64 filterId, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.UnregisterServiceNotificationFilterAsync(System.Int64,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterId" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="filterId">
          <para>The ID of a previously registered <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" /> returned from <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServiceNotificationFilterAsync(System.Fabric.Description.ServiceNotificationFilterDescription)" />.</para>
        </param>
        <param name="timeout">
          <para>The maximum time allowed for processing the request before <see cref="T:System.TimeoutException" /> is thrown.</para>
        </param>
        <param name="cancellationToken">
          <para>Reserved for future use.</para>
        </param>
        <summary>
          <para>Unregisters a previously registered <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" />.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Threading.Tasks.Task" /> representing the async operation.</para>
        </returns>
        <remarks>
            It's not necessary to unregister individual filters if the client itself will no longer be used since all <see cref="T:System.Fabric.Description.ServiceNotificationFilterDescription" /> objects registered by the <see cref="T:System.Fabric.FabricClient" /> will be automatically unregistered when client is disposed.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterServicePartitionResolutionChangeHandler">
      <MemberSignature Language="C#" Value="public void UnregisterServicePartitionResolutionChangeHandler (long callbackHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterServicePartitionResolutionChangeHandler(int64 callbackHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.UnregisterServicePartitionResolutionChangeHandler(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callbackHandle" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="callbackHandle">
          <para>The callbackHandle identifier that will be removed. This is returned by the <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServicePartitionResolutionChangeHandler(System.Uri,System.Fabric.ServicePartitionResolutionChangeHandler)" /> call.</para>
        </param>
        <summary>
          <para>Unregisters a change handler previously registered with <see cref="M:System.Fabric.FabricClient.ServiceManagementClient.RegisterServicePartitionResolutionChangeHandler(System.Uri,System.Fabric.ServicePartitionResolutionChangeHandler)" />.</para>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state. Dispose of the <see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UpdateServiceAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task UpdateServiceAsync (Uri name, System.Fabric.Description.ServiceUpdateDescription updateDescription);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task UpdateServiceAsync(class System.Uri name, class System.Fabric.Description.ServiceUpdateDescription updateDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.UpdateServiceAsync(System.Uri,System.Fabric.Description.ServiceUpdateDescription)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Uri" />
        <Parameter Name="updateDescription" Type="System.Fabric.Description.ServiceUpdateDescription" />
      </Parameters>
      <Docs>
        <param name="name">
          <para>The URI name of the service being updated.</para>
        </param>
        <param name="updateDescription">
          <para>The <see cref="T:System.Fabric.Description.ServiceUpdateDescription" /> that specifies the updated configuration for the service.</para>
        </param>
        <summary>
          <para>Updates a service with the specified description.</para>
        </summary>
        <returns>
          <para>The updated service.</para>
        </returns>
        <remarks>
          <para>The default timeout is one minute for which the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />. </para>
          <para>NOTE: To safely increase both the <see cref="P:System.Fabric.Description.StatefulServiceUpdateDescription.MinReplicaSetSize" /> and the <see cref="P:System.Fabric.Description.StatefulServiceUpdateDescription.TargetReplicaSetSize" /> first increase the <see cref="P:System.Fabric.Description.StatefulServiceUpdateDescription.TargetReplicaSetSize" /> and wait for additional replicas to be created and then increase the <see cref="P:System.Fabric.Description.StatefulServiceUpdateDescription.MinReplicaSetSize" /></para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state.
            Dispose of the<see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="name" /> or <paramref name="updateDescription" /> are null.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpdateServiceAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task UpdateServiceAsync (Uri name, System.Fabric.Description.ServiceUpdateDescription serviceUpdateDescription, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task UpdateServiceAsync(class System.Uri name, class System.Fabric.Description.ServiceUpdateDescription serviceUpdateDescription, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Fabric.FabricClient.ServiceManagementClient.UpdateServiceAsync(System.Uri,System.Fabric.Description.ServiceUpdateDescription,System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>255.0.0.0</AssemblyVersion>
        <AssemblyName>System.Fabric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Uri" />
        <Parameter Name="serviceUpdateDescription" Type="System.Fabric.Description.ServiceUpdateDescription" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name">
          <para>The URI name of the service being updated.</para>
        </param>
        <param name="serviceUpdateDescription">
          <para>The <see cref="T:System.Fabric.Description.ServiceUpdateDescription" /> that specifies the updated configuration for the service.</para>
        </param>
        <param name="timeout">
          <para>The maximum amount of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" />.</para>
        </param>
        <param name="cancellationToken">
          <para>The <see cref="T:System.Threading.CancellationToken" /> that the operation is observing. It can be used to propagate notification that the operation should be canceled.</para>
        </param>
        <summary>
          <para>Updates a service with the specified description.
            Also takes in timeout interval, which is the maximum of time the system will allow this operation to continue before returning <see cref="T:System.TimeoutException" /> and cancellation-token that the operation is observing. 
            </para>
        </summary>
        <returns>
          <para>The updated service.</para>
        </returns>
        <remarks>
          <para>NOTE: To safely increase both the <see cref="P:System.Fabric.Description.StatefulServiceUpdateDescription.MinReplicaSetSize" /> and the <see cref="P:System.Fabric.Description.StatefulServiceUpdateDescription.TargetReplicaSetSize" /> first increase the <see cref="P:System.Fabric.Description.StatefulServiceUpdateDescription.TargetReplicaSetSize" /> and wait for additional replicas to be created and then increase the <see cref="P:System.Fabric.Description.StatefulServiceUpdateDescription.MinReplicaSetSize" /></para>
        </remarks>
        <exception cref="T:System.Fabric.FabricObjectClosedException">
          <para>The <see cref="T:System.Fabric.FabricClient" /> object is in a closed state.
            Dispose of the<see cref="T:System.Fabric.FabricClient" /> object you are using and instantiate a new <see cref="T:System.Fabric.FabricClient" /> object.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">When <paramref name="name" /> or <paramref name="serviceUpdateDescription" /> are null.</exception>
      </Docs>
    </Member>
  </Members>
</Type>