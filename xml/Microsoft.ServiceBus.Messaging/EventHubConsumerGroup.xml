<Type Name="EventHubConsumerGroup" FullName="Microsoft.ServiceBus.Messaging.EventHubConsumerGroup">
  <TypeSignature Language="C#" Value="public sealed class EventHubConsumerGroup : Microsoft.ServiceBus.Messaging.ClientEntity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit EventHubConsumerGroup extends Microsoft.ServiceBus.Messaging.ClientEntity" />
  <TypeSignature Language="DocId" Value="T:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.ServiceBus</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.ServiceBus.Messaging.ClientEntity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents the consumer group within an Event Hub. This class creates receivers for a specific consumer 
            group within an Event Hub. This can be the default consumer group or another user-created consumer group.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateReceiver">
      <MemberSignature Language="C#" Value="public Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver (string partitionId, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver(string partitionId, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ServiceBus.Messaging.EventHubReceiver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Creates a new Event Hubs receiver in the specified partition. You can use the 
            created receiver to receive events for one Event Hubs partition, specified by <paramref name="partitionId" />.</summary>
        <returns>Returns the 
            <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" /> object that is tied to the given Event Hubs partition.</returns>
        <remarks>If the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup" /> has checkpoint enabled, 
            this overload will always throw InvalidOperationException because checkpoint
            enabled ConsumerGroup requires epoch to work (please use the overload that 
            supply epoch as input argument). If checkpoint is disabled, 
            then receiver will get message from the start of the event stream, as determined by the 
            message retention policy of the Event Hub.</remarks>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingException">Thrown if the service encounters a transient error.</exception>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingCommunicationException">Thrown if the client 
            has a problem connecting to the service.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="partitionId" /> is not within the expected range, as determined by the 
            <see cref="P:Microsoft.ServiceBus.Messaging.EventHubDescription.PartitionCount" /> property.</exception>
        <exception cref="T:System.ServiceModel.QuotaExceededException">Thrown if the number of receivers currently connected to the partition specified 
            by <paramref name="partitionId" /> has exceeded the maximum allowed quota set by the service.</exception>
        <exception cref="T:Microsoft.ServiceBus.Messaging.ReceiverDisconnectedException">Thrown if there is currently a receiver connected to the 
            partition as specified by <paramref name="partitionId" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiver">
      <MemberSignature Language="C#" Value="public Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver (string partitionId, DateTime startingDateTimeUtc, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver(string partitionId, valuetype System.DateTime startingDateTimeUtc, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.DateTime,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ServiceBus.Messaging.EventHubReceiver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingDateTimeUtc" Type="System.DateTime" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingDateTimeUtc">The starting UTC time for receiving messages.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Creates a new Event Hubs receiver in the specified partition, starting at the specified date and time. 
            You can use the created receiver to receive events for one Event Hubs partition, specified by <paramref name="partitionId" />.</summary>
        <returns>Returns the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" />.</returns>
        <remarks>Service only uses this <paramref name="startingDateTimeUtc" /> as an approximation when 
            determining next event to deliver.
            
            Keep in mind that there can be clock skew between client time and service time, so user application 
            should be designed to handle duplication in event delivery.</remarks>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingException">Thrown if the service encounters a transient error.</exception>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingCommunicationException">Thrown if the client 
            has a problem connecting to the service.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="partitionId" /> is not within the expected range, as determined by the 
            <see cref="P:Microsoft.ServiceBus.Messaging.EventHubDescription.PartitionCount" /> property.</exception>
        <exception cref="T:System.ServiceModel.QuotaExceededException">Thrown if the number of receivers currently connected to the partition specified 
            by <paramref name="partitionId" /> has exceeded the maximum allowed quota set by the service.</exception>
        <exception cref="T:Microsoft.ServiceBus.Messaging.ReceiverDisconnectedException">Thrown if there is currently a receiver connected to the 
            partition as specified by <paramref name="partitionId" />, with an <paramref name="startingDateTimeUtc" /> specified.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiver">
      <MemberSignature Language="C#" Value="public Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver (string partitionId, long epoch, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver(string partitionId, int64 epoch, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ServiceBus.Messaging.EventHubReceiver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="epoch" Type="System.Int64" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="epoch">The epoch value. The service uses this value to enforce partition/lease ownership.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Creates a new Event Hubs receiver in the specified partition, and the specified epoch value. You 
            can use the created receiver to receive events for one Event Hubs partition, specified by <paramref name="partitionId" />.</summary>
        <returns>Returns the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" />.</returns>
        <remarks>If the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup" /> has checkpoint enabled, then the
            receiver will get next message from the checkpoint offset. If checkpoint is disabled, 
            then receiver will get message from the start of the event stream, as determined by the 
            message retention policy of the event hub.</remarks>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingException">Thrown if the service encounters a transient error.</exception>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingCommunicationException">Thrown if the client 
            has a problem connecting to the service.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="partitionId" /> is not within the expected range, as determined by the 
            <see cref="P:Microsoft.ServiceBus.Messaging.EventHubDescription.PartitionCount" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiver">
      <MemberSignature Language="C#" Value="public Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver (string partitionId, string startingOffset, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver(string partitionId, string startingOffset, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.String,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ServiceBus.Messaging.EventHubReceiver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingOffset" Type="System.String" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingOffset">The starting offset at which to start receiving messages.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Creates a new Event Hubs receiver in the specified partition, at the specified starting offset. You 
            can use the created receiver to receive events for one Event Hubs partition, specified by <paramref name="partitionId" />.</summary>
        <returns>Returns the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="partitionId" /> is not within the expected range, as determined by the 
            <see cref="P:Microsoft.ServiceBus.Messaging.EventHubDescription.PartitionCount" /> property.</exception>
        <exception cref="T:System.ServiceModel.QuotaExceededException">Thrown if the number of receivers currently connected to the partition specified 
            by <paramref name="partitionId" /> has exceeded the maximum allowed quota set by the service.</exception>
        <exception cref="T:Microsoft.ServiceBus.Messaging.ReceiverDisconnectedException">Thrown if there is currently a receiver connected to the 
            partition as specified by <paramref name="partitionId" />, with an <paramref name="startingOffset" /> specified.</exception>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiver">
      <MemberSignature Language="C#" Value="public Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver (string partitionId, DateTime startingDateTimeUtc, long epoch, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver(string partitionId, valuetype System.DateTime startingDateTimeUtc, int64 epoch, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.DateTime,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ServiceBus.Messaging.EventHubReceiver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingDateTimeUtc" Type="System.DateTime" />
        <Parameter Name="epoch" Type="System.Int64" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingDateTimeUtc">The starting UTC time for receiving messages.</param>
        <param name="epoch">The epoch value. The service uses this value to enforce partition/lease ownership.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Creates a new Event Hubs receiver in the specified partition, starting at the specified date and time. 
            You can use the created receiver to receive events for one Event Hubs partition, specified by <paramref name="partitionId" />.</summary>
        <returns>Returns the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" />.</returns>
        <remarks>Service only uses this <paramref name="startingDateTimeUtc" /> as an approximation when 
            determining next event to deliver.
            
            Keep in mind that there can be clock skew between client time and service time, so user application 
            should be designed to handle duplication in event delivery.</remarks>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingException">Thrown if the service encounters a transient error.</exception>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingCommunicationException">Thrown if the client 
            has a problem connecting to the service.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="partitionId" /> is not within the expected range, as determined by the 
            <see cref="P:Microsoft.ServiceBus.Messaging.EventHubDescription.PartitionCount" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiver">
      <MemberSignature Language="C#" Value="public Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver (string partitionId, string startingOffset, bool offsetInclusive, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver(string partitionId, string startingOffset, bool offsetInclusive, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.String,System.Boolean,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ServiceBus.Messaging.EventHubReceiver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingOffset" Type="System.String" />
        <Parameter Name="offsetInclusive" Type="System.Boolean" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingOffset">The starting offset at which to start receiving messages.</param>
        <param name="offsetInclusive">A Boolean value that indicates whether <paramref name="startingOffset" /> is treated as an inclusive offset, meaning that the first 
            <param name="receiverOptions">Options for a event hub receiver.</param>
            event returned is the event that contains the starting offset. Normally, the first event returned is the event after the starting offset.</param>
        <param name="receiverOptions">To be added.</param>
        <summary>Creates a new Event Hubs receiver in the specified partition, at the specified starting offset. You 
            can use the created receiver to receive events for one Event Hubs partition, specified by <paramref name="partitionId" />.</summary>
        <returns>Returns <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" />.</returns>
        <remarks>To be added.</remarks>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiver">
      <MemberSignature Language="C#" Value="public Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver (string partitionId, string startingOffset, long epoch, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver(string partitionId, string startingOffset, int64 epoch, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.String,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ServiceBus.Messaging.EventHubReceiver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingOffset" Type="System.String" />
        <Parameter Name="epoch" Type="System.Int64" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingOffset">The starting offset at which to start receiving messages. To specify the start of the stream, see 
            <see cref="F:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.StartOfStream" />.</param>
        <param name="epoch">The epoch value. The service uses this value to enforce partition/lease ownership.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Creates a new Event Hubs receiver in the specified partition, at the specified starting offset.</summary>
        <returns>Returns the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingException">Thrown if the service encounters a transient error.</exception>
        <exception cref="T:Microsoft.ServiceBus.Messaging.MessagingCommunicationException">Thrown if the client 
            has a problem connecting to the service.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="partitionId" /> is not within the expected range, as determined by the 
            <see cref="P:Microsoft.ServiceBus.Messaging.EventHubDescription.PartitionCount" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiver">
      <MemberSignature Language="C#" Value="public Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver (string partitionId, string startingOffset, bool offsetInclusive, long epoch, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.ServiceBus.Messaging.EventHubReceiver CreateReceiver(string partitionId, string startingOffset, bool offsetInclusive, int64 epoch, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.String,System.Boolean,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ServiceBus.Messaging.EventHubReceiver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingOffset" Type="System.String" />
        <Parameter Name="offsetInclusive" Type="System.Boolean" />
        <Parameter Name="epoch" Type="System.Int64" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingOffset">The starting offset at which to start receiving messages.</param>
        <param name="offsetInclusive">A Boolean value that indicates whether <paramref name="startingOffset" /> is treated as an inclusive offset, meaning that the first 
            event returned is the event that contains the starting offset. Normally, the first event returned is the event after the starting offset.</param>
        <param name="epoch">The epoch value. The service uses this value to enforce partition/lease ownership.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Creates a new Event Hubs receiver in the specified partition, at the specified starting offset. You 
            can use the created receiver to receive events for one Event Hubs partition, specified by <paramref name="partitionId" />.</summary>
        <returns>Returns <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiverAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync (string partitionId, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync(string partitionId, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiverAsync(System.String,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Asynchronous version of <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>If the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup" /> has checkpoint enabled, 
            this overload will always throw InvalidOperationException because checkpoint
            enabled ConsumerGroup requires epoch to work (please use the overload that 
            supply epoch as input argument). If checkpoint is disabled, 
            then receiver will get message from the start of the event stream, as determined by the 
            message retention policy of the Event Hub.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiverAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync (string partitionId, DateTime startingDateTimeUtc, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync(string partitionId, valuetype System.DateTime startingDateTimeUtc, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiverAsync(System.String,System.DateTime,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingDateTimeUtc" Type="System.DateTime" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingDateTimeUtc">The starting UTC time for receiving messages.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.DateTime,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>Service only use this <paramref name="startingDateTimeUtc" /> as an approximation when 
            determining next event to deliver.
            
            Keep in mind that there can be clock skew between client time and service time, so user application 
            should be designed to handle duplication in event delivery.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiverAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync (string partitionId, long epoch, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync(string partitionId, int64 epoch, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiverAsync(System.String,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="epoch" Type="System.Int64" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="epoch">The epoch value. The service uses this value to enforce partition/lease ownership.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>If the <see cref="T:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup" /> has checkpoint enabled, then the
            receiver will get next message from the checkpoint offset. If checkpoint is disabled, 
            then receiver will get message from the start of the event stream, as determined by the 
            message retention policy of the Event Hub.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiverAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync (string partitionId, string startingOffset, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync(string partitionId, string startingOffset, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiverAsync(System.String,System.String,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingOffset" Type="System.String" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingOffset">The starting offset at which to start receiving messages.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiverAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync (string partitionId, DateTime startingDateTimeUtc, long epoch, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync(string partitionId, valuetype System.DateTime startingDateTimeUtc, int64 epoch, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiverAsync(System.String,System.DateTime,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingDateTimeUtc" Type="System.DateTime" />
        <Parameter Name="epoch" Type="System.Int64" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingDateTimeUtc">The starting UTC time for receiving messages.</param>
        <param name="epoch">The epoch value. The service uses this value to enforce partition/lease ownership.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.DateTime,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>Service only uses this <paramref name="startingDateTimeUtc" /> as an approximation when 
            determining next event to deliver.
            
            Keep in mind that there can be clock skew between client time and service time, so user application 
            should be designed to handle duplication in event delivery.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiverAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync (string partitionId, string startingOffset, bool offsetInclusive, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync(string partitionId, string startingOffset, bool offsetInclusive, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiverAsync(System.String,System.String,System.Boolean,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingOffset" Type="System.String" />
        <Parameter Name="offsetInclusive" Type="System.Boolean" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingOffset">The starting offset at which to start receiving messages.</param>
        <param name="offsetInclusive">A Boolean value that indicates whether <paramref name="startingOffset" /> is treated as an inclusive offset, meaning that the first 
            event returned is the event that contains the starting offset. Normally, the first event returned is the event after the starting offset.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.String,System.Boolean,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
        <code>
                // The following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // The following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // The following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // The following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // The following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
        <code>
                // The following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer group. It uses
                // a previously stored offset as starting offset and return that event 
                // as the first event
                
                // assume we have obtained the description which will gives us the partition ids.
                // Also assume user has retrieved the stored offset 
                EventHubDescription description;
                string storedOffset = "2478";
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    storedOffset);
                
                // eventData will have offset == storedOffset
                var eventData = receiver.Receive();
            </code>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiverAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync (string partitionId, string startingOffset, long epoch, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync(string partitionId, string startingOffset, int64 epoch, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiverAsync(System.String,System.String,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingOffset" Type="System.String" />
        <Parameter Name="epoch" Type="System.Int64" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingOffset">The starting offset at which to start receiving messages. To specify the start of the stream, see 
            <see cref="F:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.StartOfStream" />.</param>
        <param name="epoch">The epoch value. The service uses this value to enforce partition/lease ownership.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.String,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReceiverAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync (string partitionId, string startingOffset, bool offsetInclusive, long epoch, Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.ServiceBus.Messaging.EventHubReceiver&gt; CreateReceiverAsync(string partitionId, string startingOffset, bool offsetInclusive, int64 epoch, class Microsoft.ServiceBus.Messaging.ReceiverOptions receiverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiverAsync(System.String,System.String,System.Boolean,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.ServiceBus.Messaging.EventHubReceiver&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="startingOffset" Type="System.String" />
        <Parameter Name="offsetInclusive" Type="System.Boolean" />
        <Parameter Name="epoch" Type="System.Int64" />
        <Parameter Name="receiverOptions" Type="Microsoft.ServiceBus.Messaging.ReceiverOptions" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition.</param>
        <param name="startingOffset">The starting offset at which to start receiving messages.</param>
        <param name="offsetInclusive">A Boolean value that indicates whether <paramref name="startingOffset" /> is treated as an inclusive offset, meaning that the first 
            event returned is the event that contains the starting offset. Normally, the first event returned is the event after the starting offset.</param>
        <param name="epoch">The epoch value. The service uses this value to enforce partition/lease ownership.</param>
        <param name="receiverOptions">Options for a event hub receiver.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,System.String,System.Boolean,System.Int64,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultGroupName">
      <MemberSignature Language="C#" Value="public const string DefaultGroupName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultGroupName" />
      <MemberSignature Language="DocId" Value="F:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.DefaultGroupName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The name of the default ConsumerGroup that is pre-created when creating EventHub.
            </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.ServiceBus.Messaging.EventHubClient.GetDefaultConsumerGroup" />
      </Docs>
    </Member>
    <Member MemberName="EnableReceiverRuntimeMetric">
      <MemberSignature Language="C#" Value="public bool EnableReceiverRuntimeMetric { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableReceiverRuntimeMetric" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.EnableReceiverRuntimeMetric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> Gets or sets a value indicating whether the runtime metric of a receiver is enabled. </summary>
        <value> true if a client wants to access <see cref="T:Microsoft.ServiceBus.Messaging.ReceiverRuntimeInfo" /> using <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" />. </value>
        <remarks>Its default value is derived from the value of <see cref="P:Microsoft.ServiceBus.Messaging.Amqp.AmqpTransportSettings.EnableReceiverRuntimeMetric" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public const string EndOfStream;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string EndOfStream" />
      <MemberSignature Language="DocId" Value="F:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.EndOfStream" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The constant that denotes the end of a stream. This can be used as an offset argument in receiver creation to 
            start receiving from the latest event, instead of a specific point in time/offset value.
            </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.EndOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.EndOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.EndOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.EndOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.EndOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.EndOfStream);
                
                var eventData = receiver.Receive();
            </code>
      </Docs>
    </Member>
    <Member MemberName="EventHubPath">
      <MemberSignature Language="C#" Value="public string EventHubPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EventHubPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.EventHubPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the event hub path.</summary>
        <value>The event hub path</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EventProcessorLifeCycleManagerFaulted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;Microsoft.ServiceBus.Messaging.EventProcessorFaultedEventArgs&gt; EventProcessorLifeCycleManagerFaulted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class Microsoft.ServiceBus.Messaging.EventProcessorFaultedEventArgs&gt; EventProcessorLifeCycleManagerFaulted" />
      <MemberSignature Language="DocId" Value="E:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.EventProcessorLifeCycleManagerFaulted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;Microsoft.ServiceBus.Messaging.EventProcessorFaultedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupName">
      <MemberSignature Language="C#" Value="public string GroupName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string GroupName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.GroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the consumer group.</summary>
        <value>The name of the consumer group.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAbort">
      <MemberSignature Language="C#" Value="protected override void OnAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.OnAbort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginClose">
      <MemberSignature Language="C#" Value="protected override IAsyncResult OnBeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.IAsyncResult OnBeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginOpen">
      <MemberSignature Language="C#" Value="protected override IAsyncResult OnBeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.IAsyncResult OnBeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClose">
      <MemberSignature Language="C#" Value="protected override void OnClose (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClose(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.OnClose(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndClose">
      <MemberSignature Language="C#" Value="protected override void OnEndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.OnEndClose(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndOpen">
      <MemberSignature Language="C#" Value="protected override void OnEndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.OnEndOpen(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrefetchCount">
      <MemberSignature Language="C#" Value="public int PrefetchCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrefetchCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.PrefetchCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of events that any receive operation will actively cache. By default, this value is inherited from 
            <see cref="T:Microsoft.ServiceBus.Messaging.EventHubClient" />. The default value is 10,000.</summary>
        <value>The number of events that the receiver can cache.</value>
        <remarks>Any <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" /> created from this instance will inherit this value by default.
            Changes to this value will not be propagate to already created receiver, but will be used by 
            new <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" /> created after the change. Also setting this property to non-zero will
            set <see cref="P:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.PrefetchSizeInBytes" /> to null.
            Note that setting the count too low will affect the effective performance of the event hub receive call.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the value is less than the minimum required value of 10.</exception>
      </Docs>
    </Member>
    <Member MemberName="PrefetchSizeInBytes">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; PrefetchSizeInBytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; PrefetchSizeInBytes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.PrefetchSizeInBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum size (in bytes) in total that any receive operation will actively cache. The size of each event data is determined by the 
            <see cref="P:Microsoft.ServiceBus.Messaging.EventData.SerializedSizeInBytes" /> property.</summary>
        <value>Returns <see cref="T:System.Int64" />.</value>
        <remarks>The size limit is not an absolute limit. the size might go over by at least 
            one event data worth of size. Any <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" /> created from this instance will inherit this value by default.
            Changes to this value will not be propagate to already created receiver, but will be used by 
            new <see cref="T:Microsoft.ServiceBus.Messaging.EventHubReceiver" /> created after the change. 
            Also, setting this property to non-null value will
            set <see cref="P:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.PrefetchCount" /> to zero.
            Note that setting the size too low will affect the effective performance of the Event Hub receive call.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the size value is less than the minimum required value of 260K bytes.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterProcessor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void RegisterProcessor&lt;T&gt; (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager) where T : Microsoft.ServiceBus.Messaging.IEventProcessor;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterProcessor&lt;(class Microsoft.ServiceBus.Messaging.IEventProcessor) T&gt;(class Microsoft.ServiceBus.Messaging.Lease lease, class Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessor``1(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>Microsoft.ServiceBus.Messaging.IEventProcessor</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="checkpointManager" Type="Microsoft.ServiceBus.Messaging.ICheckpointManager" />
      </Parameters>
      <Docs>
        <typeparam name="T">Implementation of <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" />.</typeparam>
        <param name="lease">Partition information.</param>
        <param name="checkpointManager">Checkpoints the offset for the specified partition when 
            <see cref="M:Microsoft.ServiceBus.Messaging.PartitionContext.CheckpointAsync(Microsoft.ServiceBus.Messaging.EventData)" /> is called.</param>
        <summary>Registers an implementation of 
            <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" /> in order to start consuming events from Event Hubs for the specified 
            <see cref="P:Microsoft.ServiceBus.Messaging.Lease.PartitionId" /> starting from 
            <see cref="P:Microsoft.ServiceBus.Messaging.Lease.Offset" />. Use this overload to create an event processor that checkpoints the message offset using a custom implementation of 
            <see cref="T:Microsoft.ServiceBus.Messaging.ICheckpointManager" />.</summary>
        <remarks>To perform more advanced <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" /> creation, implement an <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessorFactory" /> 
            class which allows you to control how event processors are created.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProcessor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void RegisterProcessor&lt;T&gt; (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, Microsoft.ServiceBus.Messaging.EventProcessorOptions processorOptions) where T : Microsoft.ServiceBus.Messaging.IEventProcessor;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterProcessor&lt;(class Microsoft.ServiceBus.Messaging.IEventProcessor) T&gt;(class Microsoft.ServiceBus.Messaging.Lease lease, class Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, class Microsoft.ServiceBus.Messaging.EventProcessorOptions processorOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessor``1(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.EventProcessorOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>Microsoft.ServiceBus.Messaging.IEventProcessor</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="checkpointManager" Type="Microsoft.ServiceBus.Messaging.ICheckpointManager" />
        <Parameter Name="processorOptions" Type="Microsoft.ServiceBus.Messaging.EventProcessorOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T">Implementation of <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" />.</typeparam>
        <param name="lease">Partition information.</param>
        <param name="checkpointManager">Checkpoints the offset for the specified partition when 
            <see cref="M:Microsoft.ServiceBus.Messaging.PartitionContext.CheckpointAsync(Microsoft.ServiceBus.Messaging.EventData)" /> is called.</param>
        <param name="processorOptions">An <see cref="T:Microsoft.ServiceBus.Messaging.EventProcessorOptions" /> object.</param>
        <summary>Registers an implementation of 
            <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" /> in order to start consuming events from Event Hubs for the specified 
            <see cref="P:Microsoft.ServiceBus.Messaging.Lease.PartitionId" /> starting from 
            <see cref="P:Microsoft.ServiceBus.Messaging.Lease.Offset" />. Use this overload to create an event processor that checkpoints the message offset using a custom implementation of 
            <see cref="T:Microsoft.ServiceBus.Messaging.ICheckpointManager" />.</summary>
        <remarks>To perform more advanced <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" /> creation, implement an <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessorFactory" /> 
            class which allows you to control how event processors are created.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProcessorAsync&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RegisterProcessorAsync&lt;T&gt; (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager) where T : Microsoft.ServiceBus.Messaging.IEventProcessor;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RegisterProcessorAsync&lt;(class Microsoft.ServiceBus.Messaging.IEventProcessor) T&gt;(class Microsoft.ServiceBus.Messaging.Lease lease, class Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessorAsync``1(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>Microsoft.ServiceBus.Messaging.IEventProcessor</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="checkpointManager" Type="Microsoft.ServiceBus.Messaging.ICheckpointManager" />
      </Parameters>
      <Docs>
        <typeparam name="T">Implementation of <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" />.</typeparam>
        <param name="lease">Partition information.</param>
        <param name="checkpointManager">Checkpoints the offset for the specified partition when 
            <see cref="M:Microsoft.ServiceBus.Messaging.PartitionContext.CheckpointAsync(Microsoft.ServiceBus.Messaging.EventData)" /> is called.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessor``1(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager)" />.</summary>
        <returns>A task instance that represents the asynchronous operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProcessorAsync&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RegisterProcessorAsync&lt;T&gt; (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, Microsoft.ServiceBus.Messaging.EventProcessorOptions processorOptions) where T : Microsoft.ServiceBus.Messaging.IEventProcessor;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RegisterProcessorAsync&lt;(class Microsoft.ServiceBus.Messaging.IEventProcessor) T&gt;(class Microsoft.ServiceBus.Messaging.Lease lease, class Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, class Microsoft.ServiceBus.Messaging.EventProcessorOptions processorOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessorAsync``1(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.EventProcessorOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>Microsoft.ServiceBus.Messaging.IEventProcessor</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="checkpointManager" Type="Microsoft.ServiceBus.Messaging.ICheckpointManager" />
        <Parameter Name="processorOptions" Type="Microsoft.ServiceBus.Messaging.EventProcessorOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T">Implementation of <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" />.</typeparam>
        <param name="lease">Partition information.</param>
        <param name="checkpointManager">Checkpoints the offset for the specified partition when 
            <see cref="M:Microsoft.ServiceBus.Messaging.PartitionContext.CheckpointAsync(Microsoft.ServiceBus.Messaging.EventData)" /> is called.</param>
        <param name="processorOptions">An <see cref="T:Microsoft.ServiceBus.Messaging.EventProcessorOptions" /> object.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessor``1(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.EventProcessorOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To perform more advanced <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" /> creation, implement an <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessorFactory" /> 
            class which allows you to control how event processors are created.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProcessorFactory">
      <MemberSignature Language="C#" Value="public void RegisterProcessorFactory (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, Microsoft.ServiceBus.Messaging.IEventProcessorFactory eventProcessorFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterProcessorFactory(class Microsoft.ServiceBus.Messaging.Lease lease, class Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, class Microsoft.ServiceBus.Messaging.IEventProcessorFactory eventProcessorFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessorFactory(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.IEventProcessorFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="checkpointManager" Type="Microsoft.ServiceBus.Messaging.ICheckpointManager" />
        <Parameter Name="eventProcessorFactory" Type="Microsoft.ServiceBus.Messaging.IEventProcessorFactory" />
      </Parameters>
      <Docs>
        <param name="lease">Partition information.</param>
        <param name="checkpointManager">Checkpoints the offset for the specified partition when 
             <see cref="M:Microsoft.ServiceBus.Messaging.PartitionContext.CheckpointAsync(Microsoft.ServiceBus.Messaging.EventData)" /> is called.</param>
        <param name="eventProcessorFactory">Factory to create an instance of <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" />.</param>
        <summary>Registers the 
             <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessorFactory" /> object used to create an instance of 
             <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" /> in order to start consuming events for the partition specified by 
             <see cref="P:Microsoft.ServiceBus.Messaging.Lease.PartitionId" />, starting from 
             <see cref="P:Microsoft.ServiceBus.Messaging.Lease.Offset" />. Use this overload to create an event processor that checkpoints the message offset using a custom implementation of 
             <see cref="T:Microsoft.ServiceBus.Messaging.ICheckpointManager" />.</summary>
        <remarks>To be added.</remarks>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
      </Docs>
    </Member>
    <Member MemberName="RegisterProcessorFactory">
      <MemberSignature Language="C#" Value="public void RegisterProcessorFactory (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, Microsoft.ServiceBus.Messaging.IEventProcessorFactory eventProcessorFactory, Microsoft.ServiceBus.Messaging.EventProcessorOptions processorOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterProcessorFactory(class Microsoft.ServiceBus.Messaging.Lease lease, class Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, class Microsoft.ServiceBus.Messaging.IEventProcessorFactory eventProcessorFactory, class Microsoft.ServiceBus.Messaging.EventProcessorOptions processorOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessorFactory(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.IEventProcessorFactory,Microsoft.ServiceBus.Messaging.EventProcessorOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="checkpointManager" Type="Microsoft.ServiceBus.Messaging.ICheckpointManager" />
        <Parameter Name="eventProcessorFactory" Type="Microsoft.ServiceBus.Messaging.IEventProcessorFactory" />
        <Parameter Name="processorOptions" Type="Microsoft.ServiceBus.Messaging.EventProcessorOptions" />
      </Parameters>
      <Docs>
        <param name="lease">Partition information.</param>
        <param name="checkpointManager">Checkpoints the offset for the specified partition when 
             <see cref="M:Microsoft.ServiceBus.Messaging.PartitionContext.CheckpointAsync(Microsoft.ServiceBus.Messaging.EventData)" /> is called.</param>
        <param name="eventProcessorFactory">Factory to create an instance of <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" />.</param>
        <param name="processorOptions">An <see cref="T:Microsoft.ServiceBus.Messaging.EventProcessorOptions" /> object.</param>
        <summary>Registers the 
             <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessorFactory" /> object used to create an instance of 
             <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" /> in order to start consuming events for the partition specified by 
             <see cref="P:Microsoft.ServiceBus.Messaging.Lease.PartitionId" />, starting from 
             <see cref="P:Microsoft.ServiceBus.Messaging.Lease.Offset" />. Use this overload to create an event processor that checkpoints the message offset using a custom implementation of 
             <see cref="T:Microsoft.ServiceBus.Messaging.ICheckpointManager" />.</summary>
        <remarks>To be added.</remarks>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
      </Docs>
    </Member>
    <Member MemberName="RegisterProcessorFactoryAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RegisterProcessorFactoryAsync (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, Microsoft.ServiceBus.Messaging.IEventProcessorFactory eventProcessorFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RegisterProcessorFactoryAsync(class Microsoft.ServiceBus.Messaging.Lease lease, class Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, class Microsoft.ServiceBus.Messaging.IEventProcessorFactory eventProcessorFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessorFactoryAsync(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.IEventProcessorFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="checkpointManager" Type="Microsoft.ServiceBus.Messaging.ICheckpointManager" />
        <Parameter Name="eventProcessorFactory" Type="Microsoft.ServiceBus.Messaging.IEventProcessorFactory" />
      </Parameters>
      <Docs>
        <param name="lease">Partition information.</param>
        <param name="checkpointManager">Checkpoints the offset for the specified partition when 
            <see cref="M:Microsoft.ServiceBus.Messaging.PartitionContext.CheckpointAsync(Microsoft.ServiceBus.Messaging.EventData)" /> is called.</param>
        <param name="eventProcessorFactory">Factory to create an instance of <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" />.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessorFactory(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.IEventProcessorFactory)" />.</summary>
        <returns>A task instance that represents the asynchronous operation.</returns>
        <remarks>To be added.</remarks>
        <code>
                TestEventProcessorFactory processorFactory = new TestEventProcessorFactory();
            
                // Register event processor with each shard to start consuming messages
                var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                foreach (var partitionId in hubDescription.PartitionIds)
                {
                    Lease lease = new Lease()
                    {
                        PartitionId = partitionId,
                        Offset = EventHubTestUtils.DefaultStartingOffset
                    };
                
                    await subscriberGroup.RegisterProcessorFactoryAsync(lease, new TestCheckpointManager(), processorFactory);
                }
            </code>
        <code>
                TestEventProcessorFactory processorFactory = new TestEventProcessorFactory();
            
                // Register event processor with each shard to start consuming messages
                var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                foreach (var partitionId in hubDescription.PartitionIds)
                {
                    Lease lease = new Lease()
                    {
                        PartitionId = partitionId,
                        Offset = EventHubTestUtils.DefaultStartingOffset
                    };
                
                    await subscriberGroup.RegisterProcessorFactoryAsync(lease, new TestCheckpointManager(), processorFactory);
                }
            </code>
        <code>
                TestEventProcessorFactory processorFactory = new TestEventProcessorFactory();
            
                // Register event processor with each shard to start consuming messages
                var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                foreach (var partitionId in hubDescription.PartitionIds)
                {
                    Lease lease = new Lease()
                    {
                        PartitionId = partitionId,
                        Offset = EventHubTestUtils.DefaultStartingOffset
                    };
                
                    await subscriberGroup.RegisterProcessorFactoryAsync(lease, new TestCheckpointManager(), processorFactory);
                }
            </code>
        <code>
                TestEventProcessorFactory processorFactory = new TestEventProcessorFactory();
            
                // Register event processor with each shard to start consuming messages
                var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                foreach (var partitionId in hubDescription.PartitionIds)
                {
                    Lease lease = new Lease()
                    {
                        PartitionId = partitionId,
                        Offset = EventHubTestUtils.DefaultStartingOffset
                    };
                
                    await subscriberGroup.RegisterProcessorFactoryAsync(lease, new TestCheckpointManager(), processorFactory);
                }
            </code>
        <code>
                TestEventProcessorFactory processorFactory = new TestEventProcessorFactory();
            
                // Register event processor with each shard to start consuming messages
                var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                foreach (var partitionId in hubDescription.PartitionIds)
                {
                    Lease lease = new Lease()
                    {
                        PartitionId = partitionId,
                        Offset = EventHubTestUtils.DefaultStartingOffset
                    };
                
                    await subscriberGroup.RegisterProcessorFactoryAsync(lease, new TestCheckpointManager(), processorFactory);
                }
            </code>
        <code>
                TestEventProcessorFactory processorFactory = new TestEventProcessorFactory();
            
                // Register event processor with each shard to start consuming messages
                var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                foreach (var partitionId in hubDescription.PartitionIds)
                {
                    Lease lease = new Lease()
                    {
                        PartitionId = partitionId,
                        Offset = EventHubTestUtils.DefaultStartingOffset
                    };
                
                    await subscriberGroup.RegisterProcessorFactoryAsync(lease, new TestCheckpointManager(), processorFactory);
                }
            </code>
      </Docs>
    </Member>
    <Member MemberName="RegisterProcessorFactoryAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RegisterProcessorFactoryAsync (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, Microsoft.ServiceBus.Messaging.IEventProcessorFactory eventProcessorFactory, Microsoft.ServiceBus.Messaging.EventProcessorOptions processorOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RegisterProcessorFactoryAsync(class Microsoft.ServiceBus.Messaging.Lease lease, class Microsoft.ServiceBus.Messaging.ICheckpointManager checkpointManager, class Microsoft.ServiceBus.Messaging.IEventProcessorFactory eventProcessorFactory, class Microsoft.ServiceBus.Messaging.EventProcessorOptions processorOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessorFactoryAsync(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.IEventProcessorFactory,Microsoft.ServiceBus.Messaging.EventProcessorOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="checkpointManager" Type="Microsoft.ServiceBus.Messaging.ICheckpointManager" />
        <Parameter Name="eventProcessorFactory" Type="Microsoft.ServiceBus.Messaging.IEventProcessorFactory" />
        <Parameter Name="processorOptions" Type="Microsoft.ServiceBus.Messaging.EventProcessorOptions" />
      </Parameters>
      <Docs>
        <param name="lease">Partition information.</param>
        <param name="checkpointManager">Checkpoints the offset for the specified partition when 
             <see cref="M:Microsoft.ServiceBus.Messaging.PartitionContext.CheckpointAsync(Microsoft.ServiceBus.Messaging.EventData)" /> is called.</param>
        <param name="eventProcessorFactory">Factory to create an instance of <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" />.</param>
        <param name="processorOptions">An <see cref="T:Microsoft.ServiceBus.Messaging.EventProcessorOptions" /> object.</param>
        <summary>Asynchronous version of 
             <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.RegisterProcessorFactory(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.ICheckpointManager,Microsoft.ServiceBus.Messaging.IEventProcessorFactory,Microsoft.ServiceBus.Messaging.EventProcessorOptions)" />.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>To be added.</remarks>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
        <code>
                 // TestEventProcessorFactory implements IEventProcessorFactory
                 var processorFactory = new TestEventProcessorFactory();
                
                 // Register event processor with each shard to start consuming messages
                 var subscriberGroup = receiveClient.GetDefaultConsumerGroup();
                 foreach (var partitionId in hubDescription.PartitionIds)
                 {
                     Lease lease = new Lease()
                     {
                         PartitionId = partitionId,
                         Offset = EventHubTestUtils.DefaultStartingOffset
                     };
            
                     subscriberGroup.RegisterProcessorFactory(lease, new TestCheckpointManager(), processorFactory);
                 }
             </code>
      </Docs>
    </Member>
    <Member MemberName="StartOfStream">
      <MemberSignature Language="C#" Value="public const string StartOfStream;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string StartOfStream" />
      <MemberSignature Language="DocId" Value="F:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.StartOfStream" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The constant that denotes the start of a stream. This can be used as an offset argument in receiver creation.
            </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.CreateReceiver(System.String,Microsoft.ServiceBus.Messaging.ReceiverOptions)" />
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
        <code>
                // the following code snippet creates a receiver that receive events
                // from the first partitions of the default consumer gorup.
                
                // assume we have obtained the description which will gives us the partition ids.
                EventHubDescription description;
                
                EventHubClient client = EventHubClient.CreateFromConnectionString(connection);
                var defaultGroup = client.GetDefaultConsumerGroup();
                var receiver = defaultGroup.CreateReceiver(
                                    description.PartitionIds.First(), 
                                    EventHubConsumerGroup.StartOfStream);
                
                var eventData = receiver.Receive();
            </code>
      </Docs>
    </Member>
    <Member MemberName="UnregisterProcessor">
      <MemberSignature Language="C#" Value="public void UnregisterProcessor (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.CloseReason reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterProcessor(class Microsoft.ServiceBus.Messaging.Lease lease, valuetype Microsoft.ServiceBus.Messaging.CloseReason reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.UnregisterProcessor(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.CloseReason)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="reason" Type="Microsoft.ServiceBus.Messaging.CloseReason" />
      </Parameters>
      <Docs>
        <param name="lease">Partition information.</param>
        <param name="reason">Reason for which 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.UnregisterProcessor(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.CloseReason)" /> was called.</param>
        <summary>Unregisters 
            <see cref="T:Microsoft.ServiceBus.Messaging.IEventProcessor" /> for the partition specified by 
            <see cref="P:Microsoft.ServiceBus.Messaging.Lease.PartitionId" />. This results in 
            <see cref="M:Microsoft.ServiceBus.Messaging.IEventProcessor.CloseAsync(Microsoft.ServiceBus.Messaging.PartitionContext,Microsoft.ServiceBus.Messaging.CloseReason)" /> being called on the underlying event processor.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterProcessorAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task UnregisterProcessorAsync (Microsoft.ServiceBus.Messaging.Lease lease, Microsoft.ServiceBus.Messaging.CloseReason reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task UnregisterProcessorAsync(class Microsoft.ServiceBus.Messaging.Lease lease, valuetype Microsoft.ServiceBus.Messaging.CloseReason reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.UnregisterProcessorAsync(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.CloseReason)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyName>Microsoft.ServiceBus</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lease" Type="Microsoft.ServiceBus.Messaging.Lease" />
        <Parameter Name="reason" Type="Microsoft.ServiceBus.Messaging.CloseReason" />
      </Parameters>
      <Docs>
        <param name="lease">Partition information.</param>
        <param name="reason">Reason that 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.UnregisterProcessorAsync(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.CloseReason)" /> was called.</param>
        <summary>Asynchronous version of 
            <see cref="M:Microsoft.ServiceBus.Messaging.EventHubConsumerGroup.UnregisterProcessor(Microsoft.ServiceBus.Messaging.Lease,Microsoft.ServiceBus.Messaging.CloseReason)" />.</summary>
        <returns>A task instance that represents the asynchronous operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>