<Type Name="WeatherData" FullName="Azure.Verticals.AgriFood.Farming.WeatherData">
  <TypeSignature Language="C#" Value="public class WeatherData" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WeatherData extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Verticals.AgriFood.Farming.WeatherData" />
  <TypeSignature Language="VB.NET" Value="Public Class WeatherData" />
  <TypeSignature Language="F#" Value="type WeatherData = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Verticals.AgriFood.Farming</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The WeatherData sub-client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeatherData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Verticals.AgriFood.Farming.WeatherData.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Verticals.AgriFood.Farming</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of WeatherData for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWeatherData">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetWeatherData (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetWeatherData(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Verticals.AgriFood.Farming.WeatherData.GetWeatherData(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetWeatherData (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetWeatherData : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetWeatherData : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="weatherData.GetWeatherData (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Verticals.AgriFood.Farming</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Returns a list of WeatherData.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>WeatherDataProviderRequest</c>:
<code>{
  locations: [
    {
      type: "LatLong" | "IataCode" | "IcaoCode" | "PlaceId" | "PostalKey", # Required. Location Type eg. LatLong/IataCode/IcaoCode/Placeid/PostalKey.
      value: string, # Required. Location Value eg. "10,-25" for LocationType Type "LatLong".
    }
  ], # Optional. List of locations for which weather data need to be fetched from the provider.
  providerAppId: string, # Optional. App id of the weather data provider.
  providerApiKey: string, # Required. Api key of the weather data provider.
  extensionId: string, # Required. Id of the extension to be used for the providerInput. eg. DTN.ClearAg.
  extensionApiName: string, # Required. Extension api name to which request is to be made.
  language: string, # Optional. Language (IETF BCP 47 language tag) in which search results should be returned by the data provider. Examples: 'en-US', 'es', 'es-MX', 'fr-FR'.
  startTimeHours: number, # Optional. Start of time range. Hour 0 represents the current hour. (Only applicable for DTN.ClearAg extension.)
  endTimeHours: number, # Optional. End of time range. Supported ranges are from 0 to 240. (Only applicable for DTN.ClearAg extension.)
  duration: number, # Optional. Specifies for how many days the daily forecast responses are returned. Available values are 1, 5, 10, 25 and 45. (Only applicable for Azure Weather Maps extension.)
  units: string, # Required. Units for which request to data provider is to be sent. Supported values are 'e' for English units, 'm' for Metric units, 'h' for Hybrid units (UK) and 's' for Metric SI units.
  additionalParams: {
    iconResolution: string, # Optional. Icon Resolution (Only applicable for AzureWeatherMaps).
    details: boolean, # Optional. Details (Only applicable for AzureWeatherMaps).
  }, # Optional. Schema of additional parameters for weather data provider request.
}
</code>

Response Body:

Schema for <c>WeatherDataProviderResponse</c>:
<code>{
  weatherMetadata: {
    extensionVersion: string, # Required. Version of the weather data extension.
    weatherDataType: string, # Required. Type of weather data (forecast/historical).
    extensionId: string, # Required. Id of the extension to be used for the providerInput. eg. DTN.ClearAg.
    extensionApiName: string, # Required. Extension api name to which request is to be made.
    language: string, # Optional. Language (IETF BCP 47 language tag) in which search results should be returned by the data provider. Examples: 'en-US', 'es', 'es-MX', 'fr-FR'.
    startTimeHours: number, # Optional. Start of time range. Hour 0 represents the current hour. (Only applicable for DTN.ClearAg extension.)
    endTimeHours: number, # Optional. End of time range. (Only applicable for DTN.ClearAg extension.)
    duration: number, # Optional. Specifies for how many days the daily forecast responses are returned. Available values are 1, 5, 10, 25 and 45. (Only applicable for Azure Weather Maps extension.)
    units: string, # Required. Units for which request to data provider is to be sent. Supported values are 'e' for English units, 'm' for Metric units, 'h' for Hybrid units (UK) and 's' for Metric SI units.
    additionalParams: {
      iconResolution: string, # Optional. Icon Resolution (Only applicable for AzureWeatherMaps).
      details: boolean, # Optional. Details (Only applicable for AzureWeatherMaps).
    }, # Optional. Schema of additional parameters for weather data provider request.
  }, # Required. Schema of Weather Metadata.
  status: "Succeeded" | "Failed" | "PartiallySucceeded", # Optional. Indicates a Succeeded, Failed, or PartiallySucceeded response.
  locations: [
    {
      location: {
        type: "LatLong" | "IataCode" | "IcaoCode" | "PlaceId" | "PostalKey", # Required. Location Type eg. LatLong/IataCode/IcaoCode/Placeid/PostalKey.
        value: string, # Required. Location Value eg. "10,-25" for LocationType Type "LatLong".
      }, # Optional. Schema of Location data.
      requestCompletionTime: string, # Optional. Request Completion Time in Utc of the location.
      lastRefreshedDateTime: string (ISO 8601 Format), # Optional. Date-time when resource was last requested, sample format: yyyy-MM-ddTHH:mm:ssZ.
      data: {
        wetBulbTemperature: {
          unit: string, # Optional. Data unit.
          values: [number], # Optional. Data values.
        }, # Optional. Schema for storing measurement readings and unit.
        cloudCover: Measures, # Optional. Schema for storing measurement readings and unit.
        dayOfWeek: [string], # Optional. Day of week.
        dayOrNight: [string], # Optional. This data field indicates whether it is daytime or nighttime based on the Local Apparent Time of the location.
        expirationTime: [string], # Optional. Expiration time in Utc format.
        iconCode: [string], # Optional. This number is the key to the weather icon lookup. The data field shows the icon number that is matched to represent the observed weather conditions.
        iconCodeExtend: [string], # Optional. Code representing full set sensible weather.
        hasPrecipitation: [boolean], # Optional. Indicates whether there is precipitation or not.
        pressureMeanSeaLevel: Measures, # Optional. Schema for storing measurement readings and unit.
        relativeHumidity: Measures, # Optional. Schema for storing measurement readings and unit.
        temperature: Measures, # Optional. Schema for storing measurement readings and unit.
        temperatureDewPoint: Measures, # Optional. Schema for storing measurement readings and unit.
        temperatureFeelsLike: Measures, # Optional. Schema for storing measurement readings and unit.
        temperatureHeatIndex: Measures, # Optional. Schema for storing measurement readings and unit.
        temperatureWindChill: Measures, # Optional. Schema for storing measurement readings and unit.
        uvDescription: [string], # Optional. The UV Index Description which complements the UV Index value by providing an associated level of risk of skin damage due to exposure (-2 = Not Available, -1 = No Report, 0 to 2 = Low, 3 to 5 = Moderate, 6 to 7 = High, 8 to 10 = Very High, 11 to 16 = Extreme).
        uvIndex: [string], # Optional. Hourly maximum UV index.
        validTimeLocal: [string], # Optional. Time forecast is valid in local apparent time.
        validTime: [string], # Optional. Time forecast is valid in Utc format.
        visibility: Measures, # Optional. Schema for storing measurement readings and unit.
        windDirection: Measures, # Optional. Schema for storing measurement readings and unit.
        windGust: Measures, # Optional. Schema for storing measurement readings and unit.
        windSpeed: Measures, # Optional. Schema for storing measurement readings and unit.
        wxPhraseLong: [string], # Optional. Hourly sensible weather phrase containing longer description.
        wxPhraseShort: [string], # Optional. Hourly sensible weather phrase containing short description.
        additionalAttributes: Dictionary&lt;string, any&gt;, # Optional. A collection of key value pairs that belongs to the resource. Each pair must not have a key greater than 50 characters and must not have a value greater than 250 characters. Note: A maximum of 100 key value pairs can be provided for a resource and only string and numeral values are supported.
      }, # Optional. Schema of weather data.
    }
  ], # Optional. List of weather data for all the weather locations.
  errors: {
    locations: [
      {
        location: WeatherLocation, # Optional. Schema of Location data.
        code: number, # Optional. Status code returned by data provider.
        description: string, # Optional. Description of the error.
        retryable: boolean, # Optional. Flag suggesting if retry attempt with same request body should be made to fetch required data.
      }
    ], # Optional. List of errors encountered for all failed locations.
  }, # Optional. Model for errors encountered for all failed locations.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetWeatherData and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
WeatherData client = new FarmBeatsClient(endpoint, credential).GetWeatherDataClient();

using RequestContent content = RequestContent.Create(new
{
    providerApiKey = "<providerApiKey>",
    extensionId = "<extensionId>",
    extensionApiName = "<extensionApiName>",
    units = "<units>",
});
Response response = client.GetWeatherData(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionVersion").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("weatherDataType").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionId").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionApiName").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("units").ToString());
]]></code>
This sample shows how to call GetWeatherData with all request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
WeatherData client = new FarmBeatsClient(endpoint, credential).GetWeatherDataClient();

using RequestContent content = RequestContent.Create(new
{
    locations = new object[]
    {
        new
        {
            type = "LatLong",
            value = "<value>",
        }
    },
    providerAppId = "<providerAppId>",
    providerApiKey = "<providerApiKey>",
    extensionId = "<extensionId>",
    extensionApiName = "<extensionApiName>",
    language = "<language>",
    startTimeHours = 1234,
    endTimeHours = 1234,
    duration = 1234,
    units = "<units>",
    additionalParams = new
    {
        iconResolution = "<iconResolution>",
        details = true,
    },
});
Response response = client.GetWeatherData(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionVersion").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("weatherDataType").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionId").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionApiName").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("language").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("startTimeHours").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("endTimeHours").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("units").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("additionalParams").GetProperty("iconResolution").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("additionalParams").GetProperty("details").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("location").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("location").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("requestCompletionTime").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("lastRefreshedDateTime").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("wetBulbTemperature").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("wetBulbTemperature").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("cloudCover").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("cloudCover").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("dayOfWeek")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("dayOrNight")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("expirationTime")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("iconCode")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("iconCodeExtend")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("hasPrecipitation")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("pressureMeanSeaLevel").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("pressureMeanSeaLevel").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("relativeHumidity").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("relativeHumidity").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperature").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperature").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureDewPoint").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureDewPoint").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureFeelsLike").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureFeelsLike").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureHeatIndex").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureHeatIndex").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureWindChill").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureWindChill").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("uvDescription")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("uvIndex")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("validTimeLocal")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("validTime")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("visibility").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("visibility").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windDirection").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windDirection").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windGust").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windGust").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windSpeed").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windSpeed").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("wxPhraseLong")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("wxPhraseShort")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("additionalAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("location").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("location").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("retryable").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetWeatherDataAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetWeatherDataAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetWeatherDataAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Verticals.AgriFood.Farming.WeatherData.GetWeatherDataAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetWeatherDataAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetWeatherDataAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetWeatherDataAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="weatherData.GetWeatherDataAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Verticals.AgriFood.Farming</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Returns a list of WeatherData.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>WeatherDataProviderRequest</c>:
<code>{
  locations: [
    {
      type: "LatLong" | "IataCode" | "IcaoCode" | "PlaceId" | "PostalKey", # Required. Location Type eg. LatLong/IataCode/IcaoCode/Placeid/PostalKey.
      value: string, # Required. Location Value eg. "10,-25" for LocationType Type "LatLong".
    }
  ], # Optional. List of locations for which weather data need to be fetched from the provider.
  providerAppId: string, # Optional. App id of the weather data provider.
  providerApiKey: string, # Required. Api key of the weather data provider.
  extensionId: string, # Required. Id of the extension to be used for the providerInput. eg. DTN.ClearAg.
  extensionApiName: string, # Required. Extension api name to which request is to be made.
  language: string, # Optional. Language (IETF BCP 47 language tag) in which search results should be returned by the data provider. Examples: 'en-US', 'es', 'es-MX', 'fr-FR'.
  startTimeHours: number, # Optional. Start of time range. Hour 0 represents the current hour. (Only applicable for DTN.ClearAg extension.)
  endTimeHours: number, # Optional. End of time range. Supported ranges are from 0 to 240. (Only applicable for DTN.ClearAg extension.)
  duration: number, # Optional. Specifies for how many days the daily forecast responses are returned. Available values are 1, 5, 10, 25 and 45. (Only applicable for Azure Weather Maps extension.)
  units: string, # Required. Units for which request to data provider is to be sent. Supported values are 'e' for English units, 'm' for Metric units, 'h' for Hybrid units (UK) and 's' for Metric SI units.
  additionalParams: {
    iconResolution: string, # Optional. Icon Resolution (Only applicable for AzureWeatherMaps).
    details: boolean, # Optional. Details (Only applicable for AzureWeatherMaps).
  }, # Optional. Schema of additional parameters for weather data provider request.
}
</code>

Response Body:

Schema for <c>WeatherDataProviderResponse</c>:
<code>{
  weatherMetadata: {
    extensionVersion: string, # Required. Version of the weather data extension.
    weatherDataType: string, # Required. Type of weather data (forecast/historical).
    extensionId: string, # Required. Id of the extension to be used for the providerInput. eg. DTN.ClearAg.
    extensionApiName: string, # Required. Extension api name to which request is to be made.
    language: string, # Optional. Language (IETF BCP 47 language tag) in which search results should be returned by the data provider. Examples: 'en-US', 'es', 'es-MX', 'fr-FR'.
    startTimeHours: number, # Optional. Start of time range. Hour 0 represents the current hour. (Only applicable for DTN.ClearAg extension.)
    endTimeHours: number, # Optional. End of time range. (Only applicable for DTN.ClearAg extension.)
    duration: number, # Optional. Specifies for how many days the daily forecast responses are returned. Available values are 1, 5, 10, 25 and 45. (Only applicable for Azure Weather Maps extension.)
    units: string, # Required. Units for which request to data provider is to be sent. Supported values are 'e' for English units, 'm' for Metric units, 'h' for Hybrid units (UK) and 's' for Metric SI units.
    additionalParams: {
      iconResolution: string, # Optional. Icon Resolution (Only applicable for AzureWeatherMaps).
      details: boolean, # Optional. Details (Only applicable for AzureWeatherMaps).
    }, # Optional. Schema of additional parameters for weather data provider request.
  }, # Required. Schema of Weather Metadata.
  status: "Succeeded" | "Failed" | "PartiallySucceeded", # Optional. Indicates a Succeeded, Failed, or PartiallySucceeded response.
  locations: [
    {
      location: {
        type: "LatLong" | "IataCode" | "IcaoCode" | "PlaceId" | "PostalKey", # Required. Location Type eg. LatLong/IataCode/IcaoCode/Placeid/PostalKey.
        value: string, # Required. Location Value eg. "10,-25" for LocationType Type "LatLong".
      }, # Optional. Schema of Location data.
      requestCompletionTime: string, # Optional. Request Completion Time in Utc of the location.
      lastRefreshedDateTime: string (ISO 8601 Format), # Optional. Date-time when resource was last requested, sample format: yyyy-MM-ddTHH:mm:ssZ.
      data: {
        wetBulbTemperature: {
          unit: string, # Optional. Data unit.
          values: [number], # Optional. Data values.
        }, # Optional. Schema for storing measurement readings and unit.
        cloudCover: Measures, # Optional. Schema for storing measurement readings and unit.
        dayOfWeek: [string], # Optional. Day of week.
        dayOrNight: [string], # Optional. This data field indicates whether it is daytime or nighttime based on the Local Apparent Time of the location.
        expirationTime: [string], # Optional. Expiration time in Utc format.
        iconCode: [string], # Optional. This number is the key to the weather icon lookup. The data field shows the icon number that is matched to represent the observed weather conditions.
        iconCodeExtend: [string], # Optional. Code representing full set sensible weather.
        hasPrecipitation: [boolean], # Optional. Indicates whether there is precipitation or not.
        pressureMeanSeaLevel: Measures, # Optional. Schema for storing measurement readings and unit.
        relativeHumidity: Measures, # Optional. Schema for storing measurement readings and unit.
        temperature: Measures, # Optional. Schema for storing measurement readings and unit.
        temperatureDewPoint: Measures, # Optional. Schema for storing measurement readings and unit.
        temperatureFeelsLike: Measures, # Optional. Schema for storing measurement readings and unit.
        temperatureHeatIndex: Measures, # Optional. Schema for storing measurement readings and unit.
        temperatureWindChill: Measures, # Optional. Schema for storing measurement readings and unit.
        uvDescription: [string], # Optional. The UV Index Description which complements the UV Index value by providing an associated level of risk of skin damage due to exposure (-2 = Not Available, -1 = No Report, 0 to 2 = Low, 3 to 5 = Moderate, 6 to 7 = High, 8 to 10 = Very High, 11 to 16 = Extreme).
        uvIndex: [string], # Optional. Hourly maximum UV index.
        validTimeLocal: [string], # Optional. Time forecast is valid in local apparent time.
        validTime: [string], # Optional. Time forecast is valid in Utc format.
        visibility: Measures, # Optional. Schema for storing measurement readings and unit.
        windDirection: Measures, # Optional. Schema for storing measurement readings and unit.
        windGust: Measures, # Optional. Schema for storing measurement readings and unit.
        windSpeed: Measures, # Optional. Schema for storing measurement readings and unit.
        wxPhraseLong: [string], # Optional. Hourly sensible weather phrase containing longer description.
        wxPhraseShort: [string], # Optional. Hourly sensible weather phrase containing short description.
        additionalAttributes: Dictionary&lt;string, any&gt;, # Optional. A collection of key value pairs that belongs to the resource. Each pair must not have a key greater than 50 characters and must not have a value greater than 250 characters. Note: A maximum of 100 key value pairs can be provided for a resource and only string and numeral values are supported.
      }, # Optional. Schema of weather data.
    }
  ], # Optional. List of weather data for all the weather locations.
  errors: {
    locations: [
      {
        location: WeatherLocation, # Optional. Schema of Location data.
        code: number, # Optional. Status code returned by data provider.
        description: string, # Optional. Description of the error.
        retryable: boolean, # Optional. Flag suggesting if retry attempt with same request body should be made to fetch required data.
      }
    ], # Optional. List of errors encountered for all failed locations.
  }, # Optional. Model for errors encountered for all failed locations.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetWeatherDataAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
WeatherData client = new FarmBeatsClient(endpoint, credential).GetWeatherDataClient();

using RequestContent content = RequestContent.Create(new
{
    providerApiKey = "<providerApiKey>",
    extensionId = "<extensionId>",
    extensionApiName = "<extensionApiName>",
    units = "<units>",
});
Response response = await client.GetWeatherDataAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionVersion").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("weatherDataType").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionId").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionApiName").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("units").ToString());
]]></code>
This sample shows how to call GetWeatherDataAsync with all request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
WeatherData client = new FarmBeatsClient(endpoint, credential).GetWeatherDataClient();

using RequestContent content = RequestContent.Create(new
{
    locations = new object[]
    {
        new
        {
            type = "LatLong",
            value = "<value>",
        }
    },
    providerAppId = "<providerAppId>",
    providerApiKey = "<providerApiKey>",
    extensionId = "<extensionId>",
    extensionApiName = "<extensionApiName>",
    language = "<language>",
    startTimeHours = 1234,
    endTimeHours = 1234,
    duration = 1234,
    units = "<units>",
    additionalParams = new
    {
        iconResolution = "<iconResolution>",
        details = true,
    },
});
Response response = await client.GetWeatherDataAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionVersion").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("weatherDataType").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionId").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("extensionApiName").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("language").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("startTimeHours").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("endTimeHours").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("units").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("additionalParams").GetProperty("iconResolution").ToString());
Console.WriteLine(result.GetProperty("weatherMetadata").GetProperty("additionalParams").GetProperty("details").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("location").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("location").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("requestCompletionTime").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("lastRefreshedDateTime").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("wetBulbTemperature").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("wetBulbTemperature").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("cloudCover").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("cloudCover").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("dayOfWeek")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("dayOrNight")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("expirationTime")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("iconCode")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("iconCodeExtend")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("hasPrecipitation")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("pressureMeanSeaLevel").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("pressureMeanSeaLevel").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("relativeHumidity").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("relativeHumidity").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperature").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperature").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureDewPoint").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureDewPoint").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureFeelsLike").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureFeelsLike").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureHeatIndex").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureHeatIndex").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureWindChill").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("temperatureWindChill").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("uvDescription")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("uvIndex")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("validTimeLocal")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("validTime")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("visibility").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("visibility").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windDirection").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windDirection").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windGust").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windGust").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windSpeed").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("windSpeed").GetProperty("values")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("wxPhraseLong")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("wxPhraseShort")[0].ToString());
Console.WriteLine(result.GetProperty("locations")[0].GetProperty("data").GetProperty("additionalAttributes").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("location").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("location").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("errors").GetProperty("locations")[0].GetProperty("retryable").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Verticals.AgriFood.Farming.WeatherData.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Verticals.AgriFood.Farming.WeatherData.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Verticals.AgriFood.Farming</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
