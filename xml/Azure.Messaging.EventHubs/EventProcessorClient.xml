<Type Name="EventProcessorClient" FullName="Azure.Messaging.EventHubs.EventProcessorClient">
  <TypeSignature Language="C#" Value="public class EventProcessorClient : Azure.Messaging.EventHubs.Primitives.EventProcessor&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartition&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventProcessorClient extends Azure.Messaging.EventHubs.Primitives.EventProcessor`1&lt;class Azure.Messaging.EventHubs.Primitives.EventProcessorPartition&gt;" />
  <TypeSignature Language="DocId" Value="T:Azure.Messaging.EventHubs.EventProcessorClient" />
  <TypeSignature Language="VB.NET" Value="Public Class EventProcessorClient&#xA;Inherits EventProcessor(Of EventProcessorPartition)" />
  <TypeSignature Language="F#" Value="type EventProcessorClient = class&#xA;    inherit EventProcessor&lt;EventProcessorPartition&gt;" />
  <AssemblyInfo>
    <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
    <AssemblyVersion>5.4.0.0</AssemblyVersion>
    <AssemblyVersion>5.4.1.0</AssemblyVersion>
    <AssemblyVersion>5.5.0.0</AssemblyVersion>
    <AssemblyVersion>5.6.0.0</AssemblyVersion>
    <AssemblyVersion>5.6.1.0</AssemblyVersion>
    <AssemblyVersion>5.6.2.0</AssemblyVersion>
    <AssemblyVersion>5.7.0.0</AssemblyVersion>
    <AssemblyVersion>5.7.1.0</AssemblyVersion>
    <AssemblyVersion>5.7.2.0</AssemblyVersion>
    <AssemblyVersion>5.7.3.0</AssemblyVersion>
    <AssemblyVersion>5.7.4.0</AssemblyVersion>
    <AssemblyVersion>5.7.5.0</AssemblyVersion>
    <AssemblyVersion>5.8.0.0</AssemblyVersion>
    <AssemblyVersion>5.8.1.0</AssemblyVersion>
    <AssemblyVersion>5.9.0.0</AssemblyVersion>
    <AssemblyVersion>5.9.1.0</AssemblyVersion>
    <AssemblyVersion>5.9.2.0</AssemblyVersion>
    <AssemblyVersion>5.9.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Azure.Messaging.EventHubs.Primitives.EventProcessor&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartition&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">Azure.Messaging.EventHubs.Primitives.EventProcessorPartition</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
               Allows for consuming and processing events across all partitions of a given Event Hub within the scope of a specific
               consumer group.  The processor is capable of collaborating with other instances for the same Event Hub and consumer
               group pairing to share work by using a common storage platform to communicate.  Fault tolerance is also built-in,
               allowing the processor to be resilient in the face of errors.
             </summary>
    <remarks>
               To enable coordination for sharing of partitions between <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> instances, they will assert exclusive read access to partitions
               for the consumer group.  No other readers should be active in the consumer group other than processors intending to collaborate.  Non-exclusive readers will
               be denied access; exclusive readers, including processors using a different storage locations, will interfere with the processor's operation and performance.
            
               The <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> is safe to cache and use for the lifetime of an application, and that is best practice when the application
               processes events regularly or semi-regularly.  The processor is responsible for ensuring efficient network, CPU, and memory use.  Calling either
               <see cref="M:Azure.Messaging.EventHubs.EventProcessorClient.StopProcessingAsync(System.Threading.CancellationToken)" /> or <see cref="M:Azure.Messaging.EventHubs.EventProcessorClient.StopProcessing(System.Threading.CancellationToken)" /> when processing is complete or as the application is shutting down will ensure
               that network resources and other unmanaged objects are properly cleaned up.
             </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EventProcessorClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
               Initializes a new instance of the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> class.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProcessorClient (Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.#ctor(Azure.Storage.Blobs.BlobContainerClient,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (checkpointStore As BlobContainerClient, consumerGroup As String, connectionString As String)" />
      <MemberSignature Language="F#" Value="new Azure.Messaging.EventHubs.EventProcessorClient : Azure.Storage.Blobs.BlobContainerClient * string * string -&gt; Azure.Messaging.EventHubs.EventProcessorClient" Usage="new Azure.Messaging.EventHubs.EventProcessorClient (checkpointStore, consumerGroup, connectionString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="checkpointStore" Type="Azure.Storage.Blobs.BlobContainerClient" />
        <Parameter Name="consumerGroup" Type="System.String" />
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="checkpointStore">The client responsible for persisting checkpoints and processor state to durable storage.  Processor instances sharing this storage will attempt to coordinate and share work.  The associated container is expected to exist.</param>
        <param name="consumerGroup">The name of the consumer group this processor is associated with.  The processor will assert exclusive read access to partitions for this group.</param>
        <param name="connectionString">The connection string to use for connecting to the Event Hubs namespace; it is expected that the Event Hub name and the shared key properties are contained in this connection string.</param>
        <summary>
               Initializes a new instance of the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> class.
             </summary>
        <remarks>
          <para>The container associated with the <paramref name="checkpointStore" /> is expected to exist; the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" />
               does not assume the ability to manage the storage account and is safe to run with only read/write permission for blobs in the container.  It is
               recommended that this container be unique to the Event Hub and consumer group used by the processor and that it not conain other blobs.</para>
          <para>If the connection string is copied from the Event Hubs namespace, it will likely not contain the name of the desired Event Hub,
               which is needed.  In this case, the name can be added manually by adding ";EntityPath=[[ EVENT HUB NAME ]]" to the end of the
               connection string.  For example, ";EntityPath=telemetry-hub".
            
               If you have defined a shared access policy directly on the Event Hub itself, then copying the connection string from that
               Event Hub will result in a connection string that contains the name.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProcessorClient (Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string connectionString, Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string connectionString, class Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.#ctor(Azure.Storage.Blobs.BlobContainerClient,System.String,System.String,Azure.Messaging.EventHubs.EventProcessorClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (checkpointStore As BlobContainerClient, consumerGroup As String, connectionString As String, clientOptions As EventProcessorClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Messaging.EventHubs.EventProcessorClient : Azure.Storage.Blobs.BlobContainerClient * string * string * Azure.Messaging.EventHubs.EventProcessorClientOptions -&gt; Azure.Messaging.EventHubs.EventProcessorClient" Usage="new Azure.Messaging.EventHubs.EventProcessorClient (checkpointStore, consumerGroup, connectionString, clientOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="checkpointStore" Type="Azure.Storage.Blobs.BlobContainerClient" />
        <Parameter Name="consumerGroup" Type="System.String" />
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="clientOptions" Type="Azure.Messaging.EventHubs.EventProcessorClientOptions" />
      </Parameters>
      <Docs>
        <param name="checkpointStore">The client responsible for persisting checkpoints and processor state to durable storage.  Processor instances sharing this storage will attempt to coordinate and share work.  The associated container is expected to exist.</param>
        <param name="consumerGroup">The name of the consumer group this processor is associated with.  The processor will assert exclusive read access to partitions for this group.</param>
        <param name="connectionString">The connection string to use for connecting to the Event Hubs namespace; it is expected that the Event Hub name and the shared key properties are contained in this connection string.</param>
        <param name="clientOptions">The set of options to use for this processor.</param>
        <summary>
               Initializes a new instance of the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> class.
             </summary>
        <remarks>
          <para>The container associated with the <paramref name="checkpointStore" /> is expected to exist; the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" />
               does not assume the ability to manage the storage account and is safe to run with only read/write permission for blobs in the container.  It is
               recommended that this container be unique to the Event Hub and consumer group used by the processor and that it not conain other blobs.</para>
          <para>If the connection string is copied from the Event Hubs namespace, it will likely not contain the name of the desired Event Hub,
               which is needed.  In this case, the name can be added manually by adding ";EntityPath=[[ EVENT HUB NAME ]]" to the end of the
               connection string.  For example, ";EntityPath=telemetry-hub".
            
               If you have defined a shared access policy directly on the Event Hub itself, then copying the connection string from that
               Event Hub will result in a connection string that contains the name.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProcessorClient (Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string connectionString, string eventHubName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string connectionString, string eventHubName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.#ctor(Azure.Storage.Blobs.BlobContainerClient,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (checkpointStore As BlobContainerClient, consumerGroup As String, connectionString As String, eventHubName As String)" />
      <MemberSignature Language="F#" Value="new Azure.Messaging.EventHubs.EventProcessorClient : Azure.Storage.Blobs.BlobContainerClient * string * string * string -&gt; Azure.Messaging.EventHubs.EventProcessorClient" Usage="new Azure.Messaging.EventHubs.EventProcessorClient (checkpointStore, consumerGroup, connectionString, eventHubName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="checkpointStore" Type="Azure.Storage.Blobs.BlobContainerClient" />
        <Parameter Name="consumerGroup" Type="System.String" />
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="eventHubName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="checkpointStore">The client responsible for persisting checkpoints and processor state to durable storage.  Processor instances sharing this storage will attempt to coordinate and share work.  The associated container is expected to exist.</param>
        <param name="consumerGroup">The name of the consumer group this processor is associated with.  The processor will assert exclusive read access to partitions for this group.</param>
        <param name="connectionString">The connection string to use for connecting to the Event Hubs namespace; it is expected that the shared key properties are contained in this connection string, but not the Event Hub name.</param>
        <param name="eventHubName">The name of the specific Event Hub to associate the processor with.</param>
        <summary>
               Initializes a new instance of the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> class.
             </summary>
        <remarks>
          <para>The container associated with the <paramref name="checkpointStore" /> is expected to exist; the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" />
               does not assume the ability to manage the storage account and is safe to run with only read/write permission for blobs in the container.  It is
               recommended that this container be unique to the Event Hub and consumer group used by the processor and that it not conain other blobs.</para>
          <para>If the connection string is copied from the Event Hub itself, it will contain the name of the desired Event Hub,
               and can be used directly without passing the <paramref name="eventHubName" />.  The name of the Event Hub should be
               passed only once, either as part of the connection string or separately.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProcessorClient (Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string connectionString, string eventHubName, Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string connectionString, string eventHubName, class Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.#ctor(Azure.Storage.Blobs.BlobContainerClient,System.String,System.String,System.String,Azure.Messaging.EventHubs.EventProcessorClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (checkpointStore As BlobContainerClient, consumerGroup As String, connectionString As String, eventHubName As String, clientOptions As EventProcessorClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Messaging.EventHubs.EventProcessorClient : Azure.Storage.Blobs.BlobContainerClient * string * string * string * Azure.Messaging.EventHubs.EventProcessorClientOptions -&gt; Azure.Messaging.EventHubs.EventProcessorClient" Usage="new Azure.Messaging.EventHubs.EventProcessorClient (checkpointStore, consumerGroup, connectionString, eventHubName, clientOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="checkpointStore" Type="Azure.Storage.Blobs.BlobContainerClient" />
        <Parameter Name="consumerGroup" Type="System.String" />
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="eventHubName" Type="System.String" />
        <Parameter Name="clientOptions" Type="Azure.Messaging.EventHubs.EventProcessorClientOptions" />
      </Parameters>
      <Docs>
        <param name="checkpointStore">The client responsible for persisting checkpoints and processor state to durable storage.  Processor instances sharing this storage will attempt to coordinate and share work.  The associated container is expected to exist.</param>
        <param name="consumerGroup">The name of the consumer group this processor is associated with.  The processor will assert exclusive read access to partitions for this group.</param>
        <param name="connectionString">The connection string to use for connecting to the Event Hubs namespace; it is expected that the shared key properties are contained in this connection string, but not the Event Hub name.</param>
        <param name="eventHubName">The name of the specific Event Hub to associate the processor with.</param>
        <param name="clientOptions">The set of options to use for this processor.</param>
        <summary>
               Initializes a new instance of the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> class.
             </summary>
        <remarks>
          <para>The container associated with the <paramref name="checkpointStore" /> is expected to exist; the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" />
               does not assume the ability to manage the storage account and is safe to run with only read/write permission for blobs in the container.  It is
               recommended that this container be unique to the Event Hub and consumer group used by the processor and that it not conain other blobs.</para>
          <para>If the connection string is copied from the Event Hub itself, it will contain the name of the desired Event Hub,
               and can be used directly without passing the <paramref name="eventHubName" />.  The name of the Event Hub should be
               passed only once, either as part of the connection string or separately.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProcessorClient (Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, Azure.AzureNamedKeyCredential credential, Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, class Azure.AzureNamedKeyCredential credential, class Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.#ctor(Azure.Storage.Blobs.BlobContainerClient,System.String,System.String,System.String,Azure.AzureNamedKeyCredential,Azure.Messaging.EventHubs.EventProcessorClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (checkpointStore As BlobContainerClient, consumerGroup As String, fullyQualifiedNamespace As String, eventHubName As String, credential As AzureNamedKeyCredential, Optional clientOptions As EventProcessorClientOptions = Nothing)" />
      <MemberSignature Language="F#" Value="new Azure.Messaging.EventHubs.EventProcessorClient : Azure.Storage.Blobs.BlobContainerClient * string * string * string * Azure.AzureNamedKeyCredential * Azure.Messaging.EventHubs.EventProcessorClientOptions -&gt; Azure.Messaging.EventHubs.EventProcessorClient" Usage="new Azure.Messaging.EventHubs.EventProcessorClient (checkpointStore, consumerGroup, fullyQualifiedNamespace, eventHubName, credential, clientOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="checkpointStore" Type="Azure.Storage.Blobs.BlobContainerClient" />
        <Parameter Name="consumerGroup" Type="System.String" />
        <Parameter Name="fullyQualifiedNamespace" Type="System.String" />
        <Parameter Name="eventHubName" Type="System.String" />
        <Parameter Name="credential" Type="Azure.AzureNamedKeyCredential" />
        <Parameter Name="clientOptions" Type="Azure.Messaging.EventHubs.EventProcessorClientOptions" />
      </Parameters>
      <Docs>
        <param name="checkpointStore">The client responsible for persisting checkpoints and processor state to durable storage.  Processor instances sharing this storage will attempt to coordinate and share work.  The associated container is expected to exist.</param>
        <param name="consumerGroup">The name of the consumer group this processor is associated with.  The processor will assert exclusive read access to partitions for this group.</param>
        <param name="fullyQualifiedNamespace">The fully qualified Event Hubs namespace to connect to.  This is likely to be similar to <c>{yournamespace}.servicebus.windows.net</c>.</param>
        <param name="eventHubName">The name of the specific Event Hub to associate the processor with.</param>
        <param name="credential">The shared access key credential to use for authorization.  Access controls may be specified by the Event Hubs namespace or the requested Event Hub, depending on Azure configuration.</param>
        <param name="clientOptions">The set of options to use for this processor.</param>
        <summary>
               Initializes a new instance of the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> class.
             </summary>
        <remarks>
               The container associated with the <paramref name="checkpointStore" /> is expected to exist; the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" />
               does not assume the ability to manage the storage account and is safe to run with only read/write permission for blobs in the container.  It is
               recommended that this container be unique to the Event Hub and consumer group used by the processor and that it not conain other blobs.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProcessorClient (Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, Azure.AzureSasCredential credential, Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, class Azure.AzureSasCredential credential, class Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.#ctor(Azure.Storage.Blobs.BlobContainerClient,System.String,System.String,System.String,Azure.AzureSasCredential,Azure.Messaging.EventHubs.EventProcessorClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (checkpointStore As BlobContainerClient, consumerGroup As String, fullyQualifiedNamespace As String, eventHubName As String, credential As AzureSasCredential, Optional clientOptions As EventProcessorClientOptions = Nothing)" />
      <MemberSignature Language="F#" Value="new Azure.Messaging.EventHubs.EventProcessorClient : Azure.Storage.Blobs.BlobContainerClient * string * string * string * Azure.AzureSasCredential * Azure.Messaging.EventHubs.EventProcessorClientOptions -&gt; Azure.Messaging.EventHubs.EventProcessorClient" Usage="new Azure.Messaging.EventHubs.EventProcessorClient (checkpointStore, consumerGroup, fullyQualifiedNamespace, eventHubName, credential, clientOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="checkpointStore" Type="Azure.Storage.Blobs.BlobContainerClient" />
        <Parameter Name="consumerGroup" Type="System.String" />
        <Parameter Name="fullyQualifiedNamespace" Type="System.String" />
        <Parameter Name="eventHubName" Type="System.String" />
        <Parameter Name="credential" Type="Azure.AzureSasCredential" />
        <Parameter Name="clientOptions" Type="Azure.Messaging.EventHubs.EventProcessorClientOptions" />
      </Parameters>
      <Docs>
        <param name="checkpointStore">The client responsible for persisting checkpoints and processor state to durable storage.  Processor instances sharing this storage will attempt to coordinate and share work.  The associated container is expected to exist.</param>
        <param name="consumerGroup">The name of the consumer group this processor is associated with.  The processor will assert exclusive read access to partitions for this group.</param>
        <param name="fullyQualifiedNamespace">The fully qualified Event Hubs namespace to connect to.  This is likely to be similar to <c>{yournamespace}.servicebus.windows.net</c>.</param>
        <param name="eventHubName">The name of the specific Event Hub to associate the processor with.</param>
        <param name="credential">The shared access signature credential to use for authorization.  Access controls may be specified by the Event Hubs namespace or the requested Event Hub, depending on Azure configuration.</param>
        <param name="clientOptions">The set of options to use for this processor.</param>
        <summary>
               Initializes a new instance of the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> class.
             </summary>
        <remarks>
               The container associated with the <paramref name="checkpointStore" /> is expected to exist; the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" />
               does not assume the ability to manage the storage account and is safe to run with only read/write permission for blobs in the container.  It is
               recommended that this container be unique to the Event Hub and consumer group used by the processor and that it not conain other blobs.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProcessorClient (Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, Azure.Core.TokenCredential credential, Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Storage.Blobs.BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, class Azure.Core.TokenCredential credential, class Azure.Messaging.EventHubs.EventProcessorClientOptions clientOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.#ctor(Azure.Storage.Blobs.BlobContainerClient,System.String,System.String,System.String,Azure.Core.TokenCredential,Azure.Messaging.EventHubs.EventProcessorClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (checkpointStore As BlobContainerClient, consumerGroup As String, fullyQualifiedNamespace As String, eventHubName As String, credential As TokenCredential, Optional clientOptions As EventProcessorClientOptions = Nothing)" />
      <MemberSignature Language="F#" Value="new Azure.Messaging.EventHubs.EventProcessorClient : Azure.Storage.Blobs.BlobContainerClient * string * string * string * Azure.Core.TokenCredential * Azure.Messaging.EventHubs.EventProcessorClientOptions -&gt; Azure.Messaging.EventHubs.EventProcessorClient" Usage="new Azure.Messaging.EventHubs.EventProcessorClient (checkpointStore, consumerGroup, fullyQualifiedNamespace, eventHubName, credential, clientOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="checkpointStore" Type="Azure.Storage.Blobs.BlobContainerClient" />
        <Parameter Name="consumerGroup" Type="System.String" />
        <Parameter Name="fullyQualifiedNamespace" Type="System.String" />
        <Parameter Name="eventHubName" Type="System.String" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
        <Parameter Name="clientOptions" Type="Azure.Messaging.EventHubs.EventProcessorClientOptions" />
      </Parameters>
      <Docs>
        <param name="checkpointStore">The client responsible for persisting checkpoints and processor state to durable storage.  Processor instances sharing this storage will attempt to coordinate and share work.  The associated container is expected to exist.</param>
        <param name="consumerGroup">The name of the consumer group this processor is associated with.  The processor will assert exclusive read access to partitions for this group.</param>
        <param name="fullyQualifiedNamespace">The fully qualified Event Hubs namespace to connect to.  This is likely to be similar to <c>{yournamespace}.servicebus.windows.net</c>.</param>
        <param name="eventHubName">The name of the specific Event Hub to associate the processor with.</param>
        <param name="credential">The Azure identity credential to use for authorization.  Access controls may be specified by the Event Hubs namespace or the requested Event Hub, depending on Azure configuration.</param>
        <param name="clientOptions">The set of options to use for this processor.</param>
        <summary>
               Initializes a new instance of the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> class.
             </summary>
        <remarks>
               The container associated with the <paramref name="checkpointStore" /> is expected to exist; the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" />
               does not assume the ability to manage the storage account and is safe to run with only read/write permission for blobs in the container.  It is
               recommended that this container be unique to the Event Hub and consumer group used by the processor and that it not conain other blobs.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClaimOwnershipAsync">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task&lt;System.Collections.Generic.IEnumerable&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;&gt; ClaimOwnershipAsync (System.Collections.Generic.IEnumerable&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt; desiredOwnership, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task`1&lt;class System.Collections.Generic.IEnumerable`1&lt;class Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;&gt; ClaimOwnershipAsync(class System.Collections.Generic.IEnumerable`1&lt;class Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt; desiredOwnership, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.ClaimOwnershipAsync(System.Collections.Generic.IEnumerable{Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ClaimOwnershipAsync (desiredOwnership As IEnumerable(Of EventProcessorPartitionOwnership), cancellationToken As CancellationToken) As Task(Of IEnumerable(Of EventProcessorPartitionOwnership))" />
      <MemberSignature Language="F#" Value="override this.ClaimOwnershipAsync : seq&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;seq&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;&gt;" Usage="eventProcessorClient.ClaimOwnershipAsync (desiredOwnership, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Collections.Generic.IEnumerable&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="desiredOwnership" Type="System.Collections.Generic.IEnumerable&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="desiredOwnership">The set of partition ownership desired by the event processor instance; this is the set of partitions that it will attempt to request responsibility for processing.</param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the processing.  This is most likely to occur when the processor is shutting down.</param>
        <summary>
               Attempts to claim ownership of the specified partitions for processing.  This method is used by
               load balancing to allow event processor instances to distribute the responsibility for processing
               partitions for a given Event Hub and consumer group pairing amongst the active event processors.
             </summary>
        <returns>The set of ownership records for the partitions that were successfully claimed; this is expected to be the <paramref name="desiredOwnership" /> or a subset of those partitions.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConsumerGroup">
      <MemberSignature Language="C#" Value="public string ConsumerGroup { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConsumerGroup" />
      <MemberSignature Language="DocId" Value="P:Azure.Messaging.EventHubs.EventProcessorClient.ConsumerGroup" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConsumerGroup As String" />
      <MemberSignature Language="F#" Value="member this.ConsumerGroup : string" Usage="Azure.Messaging.EventHubs.EventProcessorClient.ConsumerGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
               The name of the consumer group this event processor is associated with.  Events will be
               read only in the context of this group.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateConnection">
      <MemberSignature Language="C#" Value="protected override Azure.Messaging.EventHubs.EventHubConnection CreateConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Azure.Messaging.EventHubs.EventHubConnection CreateConnection() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.CreateConnection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateConnection () As EventHubConnection" />
      <MemberSignature Language="F#" Value="override this.CreateConnection : unit -&gt; Azure.Messaging.EventHubs.EventHubConnection" Usage="eventProcessorClient.CreateConnection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Messaging.EventHubs.EventHubConnection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
               Creates an <see cref="T:Azure.Messaging.EventHubs.EventHubConnection" /> to use for communicating with the Event Hubs service.
             </summary>
        <returns>The requested <see cref="T:Azure.Messaging.EventHubs.EventHubConnection" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="eventProcessorClient.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
        <summary>
               Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
             </summary>
        <returns>
          <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EventHubName">
      <MemberSignature Language="C#" Value="public string EventHubName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EventHubName" />
      <MemberSignature Language="DocId" Value="P:Azure.Messaging.EventHubs.EventProcessorClient.EventHubName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EventHubName As String" />
      <MemberSignature Language="F#" Value="member this.EventHubName : string" Usage="Azure.Messaging.EventHubs.EventProcessorClient.EventHubName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
               The name of the Event Hub that the processor is connected to, specific to the
               Event Hubs namespace that contains it.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedNamespace">
      <MemberSignature Language="C#" Value="public string FullyQualifiedNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedNamespace" />
      <MemberSignature Language="DocId" Value="P:Azure.Messaging.EventHubs.EventProcessorClient.FullyQualifiedNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullyQualifiedNamespace As String" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedNamespace : string" Usage="Azure.Messaging.EventHubs.EventProcessorClient.FullyQualifiedNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
               The fully qualified Event Hubs namespace that the processor is associated with.  This is likely
               to be similar to <c>{yournamespace}.servicebus.windows.net</c>.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCheckpointAsync">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorCheckpoint&gt; GetCheckpointAsync (string partitionId, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Messaging.EventHubs.Primitives.EventProcessorCheckpoint&gt; GetCheckpointAsync(string partitionId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.GetCheckpointAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetCheckpointAsync (partitionId As String, cancellationToken As CancellationToken) As Task(Of EventProcessorCheckpoint)" />
      <MemberSignature Language="F#" Value="override this.GetCheckpointAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorCheckpoint&gt;" Usage="eventProcessorClient.GetCheckpointAsync (partitionId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorCheckpoint&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="partitionId">The ID of the partition for which to retrieve the checkpoint.</param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the processing.  This is most likely to occur when the processor is shutting down.</param>
        <summary>
               Returns a checkpoint for the Event Hub, consumer group, and partition ID associated with the
               event processor instance, so that processing for a given partition can be properly initialized.
             </summary>
        <returns>The checkpoint for the processor to take into account when initializing partition.</returns>
        <remarks>
               Should a partition not have a corresponding checkpoint, the default starting position set by the <see cref="E:Azure.Messaging.EventHubs.EventProcessorClient.PartitionInitializingAsync" /> handler
               will be applied.  If no partition-specific starting point was specified, the <see cref="P:Azure.Messaging.EventHubs.Primitives.EventProcessorOptions.DefaultStartingPosition" /> will
               be used to initialize the partition for processing.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="eventProcessorClient.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
               Returns a hash code for this instance.
             </summary>
        <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identifier">
      <MemberSignature Language="C#" Value="public string Identifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Identifier" />
      <MemberSignature Language="DocId" Value="P:Azure.Messaging.EventHubs.EventProcessorClient.Identifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Identifier As String" />
      <MemberSignature Language="F#" Value="member this.Identifier : string" Usage="Azure.Messaging.EventHubs.EventProcessorClient.Identifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
               A unique name used to identify this event processor.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRunning">
      <MemberSignature Language="C#" Value="public bool IsRunning { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRunning" />
      <MemberSignature Language="DocId" Value="P:Azure.Messaging.EventHubs.EventProcessorClient.IsRunning" />
      <MemberSignature Language="VB.NET" Value="Public Property IsRunning As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsRunning : bool with get, set" Usage="Azure.Messaging.EventHubs.EventProcessorClient.IsRunning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
               Indicates whether or not this event processor is currently running.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ListOwnershipAsync">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task&lt;System.Collections.Generic.IEnumerable&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;&gt; ListOwnershipAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task`1&lt;class System.Collections.Generic.IEnumerable`1&lt;class Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;&gt; ListOwnershipAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.ListOwnershipAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ListOwnershipAsync (cancellationToken As CancellationToken) As Task(Of IEnumerable(Of EventProcessorPartitionOwnership))" />
      <MemberSignature Language="F#" Value="override this.ListOwnershipAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;seq&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;&gt;" Usage="eventProcessorClient.ListOwnershipAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Collections.Generic.IEnumerable&lt;Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the processing.  This is most likely to occur when the processor is shutting down.</param>
        <summary>
               Produces a list of the ownership assignments for partitions between each of the cooperating event processor
               instances for a given Event Hub and consumer group pairing.  This method is used when load balancing to allow
               the processor to discover other active collaborators and to make decisions about how to best balance work
               between them.
             </summary>
        <returns>The set of ownership records to take into account when making load balancing decisions.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitializingPartitionAsync">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task OnInitializingPartitionAsync (Azure.Messaging.EventHubs.Primitives.EventProcessorPartition partition, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task OnInitializingPartitionAsync(class Azure.Messaging.EventHubs.Primitives.EventProcessorPartition partition, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.OnInitializingPartitionAsync(Azure.Messaging.EventHubs.Primitives.EventProcessorPartition,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnInitializingPartitionAsync (partition As EventProcessorPartition, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="F#" Value="override this.OnInitializingPartitionAsync : Azure.Messaging.EventHubs.Primitives.EventProcessorPartition * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="eventProcessorClient.OnInitializingPartitionAsync (partition, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partition" Type="Azure.Messaging.EventHubs.Primitives.EventProcessorPartition" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="partition">The context of the partition being initialized.  Only the well-known members of the <see cref="T:Azure.Messaging.EventHubs.Primitives.EventProcessorPartition" /> will be populated.  If a custom context is being used, the implementor of this method is responsible for initializing custom members.</param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the initialization.  This is most likely to occur if the partition is claimed by another event processor instance or the processor is shutting down.</param>
        <summary>
               Performs the tasks to initialize a partition, and its associated context, for event processing.
             </summary>
        <returns>To be added.</returns>
        <remarks>
               It is not recommended that the state of the processor be managed directly from within this method; requesting to start or stop the processor may result in
               a deadlock scenario, especially if using the synchronous form of the call.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPartitionProcessingStoppedAsync">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task OnPartitionProcessingStoppedAsync (Azure.Messaging.EventHubs.Primitives.EventProcessorPartition partition, Azure.Messaging.EventHubs.Processor.ProcessingStoppedReason reason, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task OnPartitionProcessingStoppedAsync(class Azure.Messaging.EventHubs.Primitives.EventProcessorPartition partition, valuetype Azure.Messaging.EventHubs.Processor.ProcessingStoppedReason reason, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.OnPartitionProcessingStoppedAsync(Azure.Messaging.EventHubs.Primitives.EventProcessorPartition,Azure.Messaging.EventHubs.Processor.ProcessingStoppedReason,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnPartitionProcessingStoppedAsync (partition As EventProcessorPartition, reason As ProcessingStoppedReason, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="F#" Value="override this.OnPartitionProcessingStoppedAsync : Azure.Messaging.EventHubs.Primitives.EventProcessorPartition * Azure.Messaging.EventHubs.Processor.ProcessingStoppedReason * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="eventProcessorClient.OnPartitionProcessingStoppedAsync (partition, reason, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partition" Type="Azure.Messaging.EventHubs.Primitives.EventProcessorPartition" />
        <Parameter Name="reason" Type="Azure.Messaging.EventHubs.Processor.ProcessingStoppedReason" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="partition">The context of the partition for which processing is being stopped.</param>
        <param name="reason">The reason that processing is being stopped for the partition.</param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the processing.  This is not expected to signal under normal circumstances and will only occur if the processor encounters an unrecoverable error.</param>
        <summary>
               Performs the tasks needed when processing for a partition is being stopped.  This commonly occurs when the partition
               is claimed by another event processor instance or when the current event processor instance is shutting down.
             </summary>
        <returns>To be added.</returns>
        <remarks>
               It is not recommended that the state of the processor be managed directly from within this method; requesting to start or stop the processor may result in
               a deadlock scenario, especially if using the synchronous form of the call.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProcessingErrorAsync">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task OnProcessingErrorAsync (Exception exception, Azure.Messaging.EventHubs.Primitives.EventProcessorPartition partition, string operationDescription, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task OnProcessingErrorAsync(class System.Exception exception, class Azure.Messaging.EventHubs.Primitives.EventProcessorPartition partition, string operationDescription, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.OnProcessingErrorAsync(System.Exception,Azure.Messaging.EventHubs.Primitives.EventProcessorPartition,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnProcessingErrorAsync (exception As Exception, partition As EventProcessorPartition, operationDescription As String, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="F#" Value="override this.OnProcessingErrorAsync : Exception * Azure.Messaging.EventHubs.Primitives.EventProcessorPartition * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="eventProcessorClient.OnProcessingErrorAsync (exception, partition, operationDescription, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="partition" Type="Azure.Messaging.EventHubs.Primitives.EventProcessorPartition" />
        <Parameter Name="operationDescription" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="exception">The exception that occurred during operation of the event processor.</param>
        <param name="partition">The context of the partition associated with the error, if any; otherwise, <c>null</c>.  This may only be initialized for members of <see cref="T:Azure.Messaging.EventHubs.Primitives.EventProcessorPartition" />, depending on the point at which the error occurred.</param>
        <param name="operationDescription">A short textual description of the operation during which the exception occurred; intended to be informational only.</param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the processing.  This is most likely to occur when the processor is shutting down.</param>
        <summary>
               Performs the tasks needed when an unexpected exception occurs within the operation of the
               event processor infrastructure.
             </summary>
        <returns>To be added.</returns>
        <remarks>
               This error handler is invoked when there is an exception observed within the event processor itself; it is not invoked for exceptions in
               code that has been implemented to process events or other overrides and extension points that are not critical to the processor's operation.
               The event processor will make every effort to recover from exceptions and continue processing.  Should an exception that cannot be recovered
               from be encountered, the processor will attempt to forfeit ownership of all partitions that it was processing so that work may be redistributed.
            
               The exceptions surfaced to this method may be fatal or non-fatal; because the processor may not be able to accurately predict whether an
               exception was fatal or whether its state was corrupted, this method has responsibility for making the determination as to whether processing
               should be terminated or restarted.  The method may do so by calling Stop on the processor instance and then, if desired, calling Start on the processor.
            
               It is recommended that, for production scenarios, the decision be made by considering observations made by this error handler, the method invoked
               when initializing processing for a partition, and the method invoked when processing for a partition is stopped.  Many developers will also include
               data from their monitoring platforms in this decision as well.
            
               As with event processing, should an exception occur in the code for the error handler, the event processor will allow it to bubble and will not attempt to handle
               it in any way.  Developers are strongly encouraged to take exception scenarios into account and guard against them using try/catch blocks and other means as appropriate.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProcessingEventBatchAsync">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task OnProcessingEventBatchAsync (System.Collections.Generic.IEnumerable&lt;Azure.Messaging.EventHubs.EventData&gt; events, Azure.Messaging.EventHubs.Primitives.EventProcessorPartition partition, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task OnProcessingEventBatchAsync(class System.Collections.Generic.IEnumerable`1&lt;class Azure.Messaging.EventHubs.EventData&gt; events, class Azure.Messaging.EventHubs.Primitives.EventProcessorPartition partition, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.OnProcessingEventBatchAsync(System.Collections.Generic.IEnumerable{Azure.Messaging.EventHubs.EventData},Azure.Messaging.EventHubs.Primitives.EventProcessorPartition,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnProcessingEventBatchAsync (events As IEnumerable(Of EventData), partition As EventProcessorPartition, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="F#" Value="override this.OnProcessingEventBatchAsync : seq&lt;Azure.Messaging.EventHubs.EventData&gt; * Azure.Messaging.EventHubs.Primitives.EventProcessorPartition * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="eventProcessorClient.OnProcessingEventBatchAsync (events, partition, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="events" Type="System.Collections.Generic.IEnumerable&lt;Azure.Messaging.EventHubs.EventData&gt;" />
        <Parameter Name="partition" Type="Azure.Messaging.EventHubs.Primitives.EventProcessorPartition" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="events">The batch of events to be processed.</param>
        <param name="partition">The context of the partition from which the events were read.</param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the processing.  This is most likely to occur when the processor is shutting down.</param>
        <summary>
               Performs the tasks needed to process a batch of events for a given partition as they are read from the Event Hubs service.
             </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>The number of events in the <paramref name="events" /> batch may vary.  The batch will contain a number of events between zero and batch size that was
               requested when the processor was created, depending on the availability of events in the partition within the requested <see cref="P:Azure.Messaging.EventHubs.Primitives.EventProcessorOptions.MaximumWaitTime" />
               interval.
            
               If there are enough events available in the Event Hub partition to fill a batch of the requested size, the processor will populate the batch and dispatch it to this method
               immediately.  If there were not a sufficient number of events available in the partition to populate a full batch, the event processor will continue reading from the partition
               to reach the requested batch size until the <see cref="P:Azure.Messaging.EventHubs.Primitives.EventProcessorOptions.MaximumWaitTime" /> has elapsed, at which point it will return a batch containing whatever events were
               available by the end of that period.
            
               If a <see cref="P:Azure.Messaging.EventHubs.Primitives.EventProcessorOptions.MaximumWaitTime" /> was not requested, indicated by setting the option to <c>null</c>, the event processor will continue reading from the Event Hub
               partition until a full batch of the requested size could be populated and will not dispatch any partial batches to this method.</para>
          <para>Should an exception occur within the code for this method, the event processor will allow it to bubble and will not surface to the error handler or attempt to handle
               it in any way.  Developers are strongly encouraged to take exception scenarios into account and guard against them using try/catch blocks and other means as appropriate.</para>
          <para>It is not recommended that the state of the processor be managed directly from within this method; requesting to start or stop the processor may result in
               a deadlock scenario, especially if using the synchronous form of the call.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartitionClosingAsync">
      <MemberSignature Language="C#" Value="public event Func&lt;Azure.Messaging.EventHubs.Processor.PartitionClosingEventArgs,System.Threading.Tasks.Task&gt; PartitionClosingAsync;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`2&lt;class Azure.Messaging.EventHubs.Processor.PartitionClosingEventArgs, class System.Threading.Tasks.Task&gt; PartitionClosingAsync" />
      <MemberSignature Language="DocId" Value="E:Azure.Messaging.EventHubs.EventProcessorClient.PartitionClosingAsync" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PartitionClosingAsync As Func(Of PartitionClosingEventArgs, Task) " />
      <MemberSignature Language="F#" Value="member this.PartitionClosingAsync : Func&lt;Azure.Messaging.EventHubs.Processor.PartitionClosingEventArgs, System.Threading.Tasks.Task&gt; " Usage="member this.PartitionClosingAsync : System.Func&lt;Azure.Messaging.EventHubs.Processor.PartitionClosingEventArgs, System.Threading.Tasks.Task&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Azure.Messaging.EventHubs.Processor.PartitionClosingEventArgs,System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
               Performs the tasks needed when processing for a partition is being stopped.  This commonly occurs when the partition is claimed by another event processor instance or when
               the current event processor instance is shutting down.
            
               <para>It is not recommended that the state of the processor be managed directly from within this method; requesting to start or stop the processor may result in
               a deadlock scenario, especially if using the synchronous form of the call.</para></summary>
        <remarks>
               This handler will be invoked concurrently, as each close is independent.  No time limit is imposed on an invocation of this handler; it is safe for
               implementations to perform long-running operations and retries as needed.  This handler has no influence on processing for the associated partition
               and offers no guarantee that execution will complete before processing for the partition is restarted or migrates to a new host.
             </remarks>
        <exception cref="T:System.ArgumentException">If an attempt is made to remove a handler that doesn't match the current handler registered.</exception>
        <exception cref="T:System.NotSupportedException">If an attempt is made to add a handler when one is currently registered.</exception>
      </Docs>
    </Member>
    <Member MemberName="PartitionInitializingAsync">
      <MemberSignature Language="C#" Value="public event Func&lt;Azure.Messaging.EventHubs.Processor.PartitionInitializingEventArgs,System.Threading.Tasks.Task&gt; PartitionInitializingAsync;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`2&lt;class Azure.Messaging.EventHubs.Processor.PartitionInitializingEventArgs, class System.Threading.Tasks.Task&gt; PartitionInitializingAsync" />
      <MemberSignature Language="DocId" Value="E:Azure.Messaging.EventHubs.EventProcessorClient.PartitionInitializingAsync" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PartitionInitializingAsync As Func(Of PartitionInitializingEventArgs, Task) " />
      <MemberSignature Language="F#" Value="member this.PartitionInitializingAsync : Func&lt;Azure.Messaging.EventHubs.Processor.PartitionInitializingEventArgs, System.Threading.Tasks.Task&gt; " Usage="member this.PartitionInitializingAsync : System.Func&lt;Azure.Messaging.EventHubs.Processor.PartitionInitializingEventArgs, System.Threading.Tasks.Task&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Azure.Messaging.EventHubs.Processor.PartitionInitializingEventArgs,System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
               Performs the tasks to initialize a partition, and its associated context, for event processing.
            
               It is not recommended that the state of the processor be managed directly from within this method; requesting to start or stop the processor may result in
               a deadlock scenario, especially if using the synchronous form of the call.
             </summary>
        <remarks>
               This handler will be invoked concurrently, limited to one call per partition.  The processor will await each invocation before starting to process
               the associated partition.
            
               The processor will wait indefinitely for execution of the handler to complete.  It is recommended for
               implementations to avoid long-running operations, as they will delay processing for the associated partition.
             </remarks>
        <exception cref="T:System.ArgumentException">If an attempt is made to remove a handler that doesn't match the current handler registered.</exception>
        <exception cref="T:System.NotSupportedException">If an attempt is made to add a handler when one is currently registered.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessErrorAsync">
      <MemberSignature Language="C#" Value="public event Func&lt;Azure.Messaging.EventHubs.Processor.ProcessErrorEventArgs,System.Threading.Tasks.Task&gt; ProcessErrorAsync;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`2&lt;valuetype Azure.Messaging.EventHubs.Processor.ProcessErrorEventArgs, class System.Threading.Tasks.Task&gt; ProcessErrorAsync" />
      <MemberSignature Language="DocId" Value="E:Azure.Messaging.EventHubs.EventProcessorClient.ProcessErrorAsync" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessErrorAsync As Func(Of ProcessErrorEventArgs, Task) " />
      <MemberSignature Language="F#" Value="member this.ProcessErrorAsync : Func&lt;Azure.Messaging.EventHubs.Processor.ProcessErrorEventArgs, System.Threading.Tasks.Task&gt; " Usage="member this.ProcessErrorAsync : System.Func&lt;Azure.Messaging.EventHubs.Processor.ProcessErrorEventArgs, System.Threading.Tasks.Task&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Azure.Messaging.EventHubs.Processor.ProcessErrorEventArgs,System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
               Performs the tasks needed when an unexpected exception occurs within the operation of the event processor infrastructure.  Implementation is mandatory.
            
               This error handler is invoked when there is an exception observed within the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> itself; it is not invoked for exceptions in
               code that has been implemented to process events or other event handlers and extension points that execute developer code.  The <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> will
               make every effort to recover from exceptions and continue processing.  Should an exception that cannot be recovered from be encountered, the processor will attempt to forfeit
               ownership of all partitions that it was processing so that work may be redistributed.
            
               The exceptions surfaced to this method may be fatal or non-fatal; because the processor may not be able to accurately predict whether an
               exception was fatal or whether its state was corrupted, this method has responsibility for making the determination as to whether processing
               should be terminated or restarted.  If desired, this can be done safely by calling <see cref="M:Azure.Messaging.EventHubs.EventProcessorClient.StopProcessingAsync(System.Threading.CancellationToken)" />  and/or <see cref="M:Azure.Messaging.EventHubs.EventProcessorClient.StartProcessingAsync(System.Threading.CancellationToken)" />.
            
               It is recommended that, for production scenarios, the decision be made by considering observations made by this error handler, the method invoked
               when initializing processing for a partition, and the method invoked when processing for a partition is stopped.  Many developers will also include
               data from their monitoring platforms in this decision as well.
            
               As with event processing, should an exception occur in the code for the error handler, the event processor will allow it to bubble and will not attempt to handle
               it in any way.  Developers are strongly encouraged to take exception scenarios into account and guard against them using try/catch blocks and other means as appropriate.
             </summary>
        <remarks>
               This handler will be invoked concurrently and is not awaited by the processor, as each error is independent.  No time limit is imposed on an invocation of this handler;
               it is safe for implementations to perform long-running operations and retries as needed.
             </remarks>
        <exception cref="T:System.ArgumentException">If an attempt is made to remove a handler that doesn't match the current handler registered.</exception>
        <exception cref="T:System.NotSupportedException">If an attempt is made to add a handler when one is currently registered.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessEventAsync">
      <MemberSignature Language="C#" Value="public event Func&lt;Azure.Messaging.EventHubs.Processor.ProcessEventArgs,System.Threading.Tasks.Task&gt; ProcessEventAsync;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`2&lt;valuetype Azure.Messaging.EventHubs.Processor.ProcessEventArgs, class System.Threading.Tasks.Task&gt; ProcessEventAsync" />
      <MemberSignature Language="DocId" Value="E:Azure.Messaging.EventHubs.EventProcessorClient.ProcessEventAsync" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessEventAsync As Func(Of ProcessEventArgs, Task) " />
      <MemberSignature Language="F#" Value="member this.ProcessEventAsync : Func&lt;Azure.Messaging.EventHubs.Processor.ProcessEventArgs, System.Threading.Tasks.Task&gt; " Usage="member this.ProcessEventAsync : System.Func&lt;Azure.Messaging.EventHubs.Processor.ProcessEventArgs, System.Threading.Tasks.Task&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;Azure.Messaging.EventHubs.Processor.ProcessEventArgs,System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
              Performs the tasks needed to process a batch of events for a given partition as they are read from the Event Hubs service. Implementation is mandatory.
            
               Should an exception occur within the code for this method, the event processor will allow it to propagate up the stack without attempting to handle it in any way.
               On most hosts, this will fault the task responsible for partition processing, causing it to be restarted from the last checkpoint.  On some hosts, it may crash the process.
               Developers are strongly encouraged to take all exception scenarios into account and guard against them using try/catch blocks and other means as appropriate.
            
               It is not recommended that the state of the processor be managed directly from within this handler; requesting to start or stop the processor may result in
               a deadlock scenario, especially if using the synchronous form of the call.
             </summary>
        <remarks>
               This handler will be invoked concurrently, limited to one call per partition.  The processor will await each invocation to ensure that the events from
               the same partition are processed one-at-a-time in the order that they were read from the partition.
            
               No time limit is imposed on an invocation of this handler; the processor will wait indefinitely for execution to complete before dispatching another
               event for the associated partition.  It is safe for implementations to perform long-running operations, retries, delays, and dead-lettering activities.
             </remarks>
        <exception cref="T:System.ArgumentException">If an attempt is made to remove a handler that doesn't match the current handler registered.</exception>
        <exception cref="T:System.NotSupportedException">If an attempt is made to add a handler when one is currently registered.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartProcessing">
      <MemberSignature Language="C#" Value="public override void StartProcessing (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void StartProcessing(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.StartProcessing(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub StartProcessing (Optional cancellationToken As CancellationToken = Nothing)" />
      <MemberSignature Language="F#" Value="override this.StartProcessing : System.Threading.CancellationToken -&gt; unit" Usage="eventProcessorClient.StartProcessing cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the start operation.  This won't affect the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> once it starts running.</param>
        <summary>
               Signals the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> to begin processing events.  Should this method be called while the processor
               is running, no action is taken.
             </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.Messaging.EventHubs.EventHubsException">Occurs when this <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> instance is already closed.</exception>
        <exception cref="T:System.InvalidOperationException">Occurs when either the <see cref="E:Azure.Messaging.EventHubs.EventProcessorClient.ProcessEventAsync" /> handler or <see cref="E:Azure.Messaging.EventHubs.EventProcessorClient.ProcessErrorAsync" /> handler has not been registered.</exception>
        <exception cref="T:System.AggregateException">
               As the processor starts, it will attempt to detect configuration and permissions errors that would prevent it from
               being able to recover without intervention.  For example, an incorrect connection string or the inability to write to the
               storage container would be detected.  These exceptions will be packaged as an <see cref="T:System.AggregateException" />, and will cause
               <see cref="M:Azure.Messaging.EventHubs.EventProcessorClient.StartProcessing(System.Threading.CancellationToken)" /> to fail.
             </exception>
      </Docs>
    </Member>
    <Member MemberName="StartProcessingAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task StartProcessingAsync (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task StartProcessingAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.StartProcessingAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function StartProcessingAsync (Optional cancellationToken As CancellationToken = Nothing) As Task" />
      <MemberSignature Language="F#" Value="override this.StartProcessingAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="eventProcessorClient.StartProcessingAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the start operation.  This won't affect the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> once it starts running.</param>
        <summary>
               Signals the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> to begin processing events.  Should this method be called while the processor
               is running, no action is taken.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.Messaging.EventHubs.EventHubsException">Occurs when this <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> instance is already closed.</exception>
        <exception cref="T:System.InvalidOperationException">Occurs when either the <see cref="E:Azure.Messaging.EventHubs.EventProcessorClient.ProcessEventAsync" /> handler or <see cref="E:Azure.Messaging.EventHubs.EventProcessorClient.ProcessErrorAsync" /> handler has not been registered.</exception>
        <exception cref="T:System.AggregateException">
               As the processor starts, it will attempt to detect configuration and permissions errors that would prevent it from
               being able to recover without intervention.  For example, an incorrect connection string or the inability to write to the
               storage container would be detected.  These exceptions will be packaged as an <see cref="T:System.AggregateException" />, and will cause
               <see cref="M:Azure.Messaging.EventHubs.EventProcessorClient.StartProcessingAsync(System.Threading.CancellationToken)" /> to fail.
             </exception>
      </Docs>
    </Member>
    <Member MemberName="StopProcessing">
      <MemberSignature Language="C#" Value="public override void StopProcessing (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void StopProcessing(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.StopProcessing(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub StopProcessing (Optional cancellationToken As CancellationToken = Nothing)" />
      <MemberSignature Language="F#" Value="override this.StopProcessing : System.Threading.CancellationToken -&gt; unit" Usage="eventProcessorClient.StopProcessing cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the stop operation.  If the operation is successfully canceled, the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> will keep running.</param>
        <summary>
               Signals the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> to stop processing events.  Should this method be called while the processor
               is not running, no action is taken.
             </summary>
        <remarks>
               When stopping, the processor will update the ownership of partitions that it was responsible for processing and clean up network resources used for communication with
               the Event Hubs service.  As a result, this method will perform network I/O and may need to wait for partition reads that were active to complete.
            
               <para>Due to service calls and network latency, an invocation of this method may take slightly longer than the specified <see cref="P:Azure.Messaging.EventHubs.EventProcessorClientOptions.MaximumWaitTime" /> or
               if the wait time was not configured, the duration of the <see cref="P:Azure.Messaging.EventHubs.EventHubsRetryOptions.TryTimeout" /> of the configured retry policy.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="StopProcessingAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task StopProcessingAsync (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task StopProcessingAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.StopProcessingAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function StopProcessingAsync (Optional cancellationToken As CancellationToken = Nothing) As Task" />
      <MemberSignature Language="F#" Value="override this.StopProcessingAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="eventProcessorClient.StopProcessingAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the stop operation.  If the operation is successfully canceled, the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> will keep running.</param>
        <summary>
               Signals the <see cref="T:Azure.Messaging.EventHubs.EventProcessorClient" /> to stop processing events.  Should this method be called while the processor
               is not running, no action is taken.
             </summary>
        <returns>To be added.</returns>
        <remarks>
               When stopping, the processor will update the ownership of partitions that it was responsible for processing and clean up network resources used for communication with
               the Event Hubs service.  As a result, this method will perform network I/O and may need to wait for partition reads that were active to complete.
            
               <para>Due to service calls and network latency, an invocation of this method may take slightly longer than the specified <see cref="P:Azure.Messaging.EventHubs.EventProcessorClientOptions.MaximumWaitTime" /> or
               if the wait time was not configured, the duration of the <see cref="P:Azure.Messaging.EventHubs.EventHubsRetryOptions.TryTimeout" /> of the configured retry policy.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="eventProcessorClient.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
               Converts the instance to string representation.
             </summary>
        <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateCheckpointAsync">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task UpdateCheckpointAsync (string partitionId, long offset, long? sequenceNumber, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task UpdateCheckpointAsync(string partitionId, int64 offset, valuetype System.Nullable`1&lt;int64&gt; sequenceNumber, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.UpdateCheckpointAsync(System.String,System.Int64,System.Nullable{System.Int64},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function UpdateCheckpointAsync (partitionId As String, offset As Long, sequenceNumber As Nullable(Of Long), cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="F#" Value="override this.UpdateCheckpointAsync : string * int64 * Nullable&lt;int64&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="eventProcessorClient.UpdateCheckpointAsync (partitionId, offset, sequenceNumber, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionId" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="sequenceNumber" Type="System.Nullable&lt;System.Int64&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="partitionId">The identifier of the partition the checkpoint is for.</param>
        <param name="offset">The offset to associate with the checkpoint, indicating that a processor should begin reading form the next event in the stream.</param>
        <param name="sequenceNumber">An optional sequence number to associate with the checkpoint, intended as informational metadata.  The <paramref name="offset" /> will be used for positioning when events are read.</param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal a request to cancel the operation.</param>
        <summary>
               Creates or updates a checkpoint for a specific partition, identifying a position in the partition's event stream
               that an event processor should begin reading from.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateProcessingPreconditions">
      <MemberSignature Language="C#" Value="protected override System.Threading.Tasks.Task ValidateProcessingPreconditions (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Threading.Tasks.Task ValidateProcessingPreconditions(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Messaging.EventHubs.EventProcessorClient.ValidateProcessingPreconditions(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ValidateProcessingPreconditions (cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="F#" Value="override this.ValidateProcessingPreconditions : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="eventProcessorClient.ValidateProcessingPreconditions cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Messaging.EventHubs.Processor</AssemblyName>
        <AssemblyVersion>5.9.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> instance to signal the request to cancel the validation.</param>
        <summary>
               Performs the tasks needed to validate basic configuration and permissions of the dependencies needed for
               the processor to function.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AggregateException">Any validation failures will result in an aggregate exception.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
