<Type Name="BatchClient" FullName="Azure.Compute.Batch.BatchClient">
  <TypeSignature Language="C#" Value="public class BatchClient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BatchClient extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Compute.Batch.BatchClient" />
  <TypeSignature Language="VB.NET" Value="Public Class BatchClient" />
  <TypeSignature Language="F#" Value="type BatchClient = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Compute.Batch</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The Batch service client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected BatchClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of BatchClient for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchClient (Uri endpoint, Azure.AzureNamedKeyCredential credential);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri endpoint, class Azure.AzureNamedKeyCredential credential) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.#ctor(System.Uri,Azure.AzureNamedKeyCredential)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (endpoint As Uri, credential As AzureNamedKeyCredential)" />
      <MemberSignature Language="F#" Value="new Azure.Compute.Batch.BatchClient : Uri * Azure.AzureNamedKeyCredential -&gt; Azure.Compute.Batch.BatchClient" Usage="new Azure.Compute.Batch.BatchClient (endpoint, credential)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.AzureNamedKeyCredential" />
      </Parameters>
      <Docs>
        <param name="endpoint"> Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com). </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <summary> Initializes a new instance of BatchClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchClient (Uri endpoint, Azure.Core.TokenCredential credential);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri endpoint, class Azure.Core.TokenCredential credential) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.#ctor(System.Uri,Azure.Core.TokenCredential)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (endpoint As Uri, credential As TokenCredential)" />
      <MemberSignature Language="F#" Value="new Azure.Compute.Batch.BatchClient : Uri * Azure.Core.TokenCredential -&gt; Azure.Compute.Batch.BatchClient" Usage="new Azure.Compute.Batch.BatchClient (endpoint, credential)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
      </Parameters>
      <Docs>
        <param name="endpoint"> Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com). </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <summary> Initializes a new instance of BatchClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endpoint" /> or <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchClient (Uri endpoint, Azure.AzureNamedKeyCredential credential, Azure.Compute.Batch.BatchClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri endpoint, class Azure.AzureNamedKeyCredential credential, class Azure.Compute.Batch.BatchClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.#ctor(System.Uri,Azure.AzureNamedKeyCredential,Azure.Compute.Batch.BatchClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (endpoint As Uri, credential As AzureNamedKeyCredential, options As BatchClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Compute.Batch.BatchClient : Uri * Azure.AzureNamedKeyCredential * Azure.Compute.Batch.BatchClientOptions -&gt; Azure.Compute.Batch.BatchClient" Usage="new Azure.Compute.Batch.BatchClient (endpoint, credential, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.AzureNamedKeyCredential" />
        <Parameter Name="options" Type="Azure.Compute.Batch.BatchClientOptions" />
      </Parameters>
      <Docs>
        <param name="endpoint"> Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com). </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of BatchClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchClient (Uri endpoint, Azure.Core.TokenCredential credential, Azure.Compute.Batch.BatchClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri endpoint, class Azure.Core.TokenCredential credential, class Azure.Compute.Batch.BatchClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.#ctor(System.Uri,Azure.Core.TokenCredential,Azure.Compute.Batch.BatchClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (endpoint As Uri, credential As TokenCredential, options As BatchClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Compute.Batch.BatchClient : Uri * Azure.Core.TokenCredential * Azure.Compute.Batch.BatchClientOptions -&gt; Azure.Compute.Batch.BatchClient" Usage="new Azure.Compute.Batch.BatchClient (endpoint, credential, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
        <Parameter Name="options" Type="Azure.Compute.Batch.BatchClientOptions" />
      </Parameters>
      <Docs>
        <param name="endpoint"> Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com). </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of BatchClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endpoint" /> or <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateJob (Azure.Compute.Batch.BatchJobCreateContent job, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateJob(class Azure.Compute.Batch.BatchJobCreateContent job, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateJob(Azure.Compute.Batch.BatchJobCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateJob (job As BatchJobCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateJob : Azure.Compute.Batch.BatchJobCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.CreateJob : Azure.Compute.Batch.BatchJobCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.CreateJob (job, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="job" Type="Azure.Compute.Batch.BatchJobCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="job"> The Job to be created. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Creates a Job to the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>
            The Batch service supports two ways to control the work done as part of a Job.
            In the first approach, the user specifies a Job Manager Task. The Batch service
            launches this Task when it is ready to start the Job. The Job Manager Task
            controls all other Tasks that run under this Job, by using the Task APIs. In
            the second approach, the user directly controls the execution of Tasks under an
            active Job, by using the Task APIs. Also note: when naming Jobs, avoid
            including sensitive information such as user names or secret project names.
            This information may appear in telemetry logs accessible to Microsoft Support
            engineers.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="job" /> is null. </exception>
        <example>
This sample shows how to call CreateJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobCreateContent job = new BatchJobCreateContent("<id>", new BatchPoolInfo());
Response response = client.CreateJob(job);
]]></code>
This sample shows how to call CreateJob with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobCreateContent job = new BatchJobCreateContent("<id>", new BatchPoolInfo
{
    PoolId = "<poolId>",
    AutoPoolSpecification = new BatchAutoPoolSpecification(BatchPoolLifetimeOption.JobSchedule)
    {
        AutoPoolIdPrefix = "<autoPoolIdPrefix>",
        KeepAlive = true,
        Pool = new BatchPoolSpecification("<vmSize>")
        {
            DisplayName = "<displayName>",
            VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
            {
                Publisher = "<publisher>",
                Offer = "<offer>",
                Sku = "<sku>",
                Version = "<version>",
                VirtualMachineImageId = "<virtualMachineImageId>",
            }, "<nodeAgentSKUId>")
            {
                WindowsConfiguration = new WindowsConfiguration
                {
                    EnableAutomaticUpdates = true,
                },
                DataDisks = {new DataDisk(1234, 1234)
                {
                    Caching = CachingType.None,
                    StorageAccountType = StorageAccountType.StandardLRS,
                }},
                LicenseType = "<licenseType>",
                ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
                {
                    ContainerImageNames = { "<containerImageNames>" },
                    ContainerRegistries = { default },
                },
                DiskEncryptionConfiguration = new DiskEncryptionConfiguration
                {
                    Targets = { DiskEncryptionTarget.OsDisk },
                },
                NodePlacementConfiguration = new BatchNodePlacementConfiguration
                {
                    Policy = BatchNodePlacementPolicyType.Regional,
                },
                Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
                {
                    TypeHandlerVersion = "<typeHandlerVersion>",
                    AutoUpgradeMinorVersion = true,
                    EnableAutomaticUpgrade = true,
                    Settings =
                    {
                        ["key"] = "<settings>"
                    },
                    ProtectedSettings =
                    {
                        ["key"] = "<protectedSettings>"
                    },
                    ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
                }},
                OsDisk = new OSDisk
                {
                    EphemeralOSDiskSettings = new DiffDiskSettings
                    {
                        Placement = DiffDiskPlacement.CacheDisk,
                    },
                    Caching = CachingType.None,
                    DiskSizeGB = 1234,
                    ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
                    WriteAcceleratorEnabled = true,
                },
                SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
                {
                    SecureBootEnabled = true,
                    VTpmEnabled = true,
                }),
                ServiceArtifactReference = new ServiceArtifactReference("<id>"),
            },
            TaskSlotsPerNode = 1234,
            TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
            ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
            ResourceTags = "<resourceTags>",
            TargetDedicatedNodes = 1234,
            TargetLowPriorityNodes = 1234,
            EnableAutoScale = true,
            AutoScaleFormula = "<autoScaleFormula>",
            AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
            EnableInterNodeCommunication = true,
            NetworkConfiguration = new NetworkConfiguration
            {
                SubnetId = "<subnetId>",
                DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
                EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
                {
                    new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
                    {
                        NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                        {
                            SourcePortRanges = {"<sourcePortRanges>"},
                        }},
                    }
                }),
                PublicIpAddressConfiguration = new PublicIpAddressConfiguration
                {
                    IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
                    IpAddressIds = { "<ipAddressIds>" },
                },
                EnableAcceleratedNetworking = true,
            },
            StartTask = new BatchStartTask("<commandLine>")
            {
                ContainerSettings = default,
                ResourceFiles = { default },
                EnvironmentSettings = { default },
                UserIdentity = default,
                MaxTaskRetryCount = 1234,
                WaitForSuccess = true,
            },
            ApplicationPackageReferences = { default },
            UserAccounts = {new UserAccount("<name>", "<password>")
            {
                ElevationLevel = ElevationLevel.NonAdmin,
                LinuxUserConfiguration = new LinuxUserConfiguration
                {
                    Uid = 1234,
                    Gid = 1234,
                    SshPrivateKey = "<sshPrivateKey>",
                },
                WindowsUserConfiguration = new WindowsUserConfiguration
                {
                    LoginMode = LoginMode.Batch,
                },
            }},
            Metadata = { new MetadataItem("<name>", "<value>") },
            MountConfiguration = {new MountConfiguration
            {
                AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
                {
                    AccountKey = "<accountKey>",
                    SasKey = "<sasKey>",
                    BlobfuseOptions = "<blobfuseOptions>",
                    IdentityReference = default,
                },
                NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
                CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
                {
                    MountOptions = "<mountOptions>",
                },
                AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
            }},
            TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
            UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
            {
                AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
                {
                    DisableAutomaticRollback = true,
                    EnableAutomaticOsUpgrade = true,
                    UseRollingUpgradePolicy = true,
                    OsRollingUpgradeDeferral = true,
                },
                RollingUpgradePolicy = new RollingUpgradePolicy
                {
                    EnableCrossZoneUpgrade = true,
                    MaxBatchInstancePercent = 1234,
                    MaxUnhealthyInstancePercent = 1234,
                    MaxUnhealthyUpgradedInstancePercent = 1234,
                    PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
                    PrioritizeUnhealthyInstances = true,
                    RollbackFailedInstancesOnPolicyBreach = true,
                },
            },
        },
    },
})
{
    DisplayName = "<displayName>",
    UsesTaskDependencies = true,
    Priority = 1234,
    AllowTaskPreemption = true,
    MaxParallelTasks = 1234,
    Constraints = new BatchJobConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    JobManagerTask = new BatchJobManagerTask("<id>", "<commandLine>")
    {
        DisplayName = "<displayName>",
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
        {
            Container = new OutputFileBlobContainerDestination("<containerUrl>")
            {
                Path = "<path>",
                IdentityReference = default,
                UploadHeaders = {new HttpHeader("<name>")
                {
                    Value = "<value>",
                }},
            },
        }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        Constraints = new BatchTaskConstraints
        {
            MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            MaxTaskRetryCount = 1234,
        },
        RequiredSlots = 1234,
        KillJobOnCompletion = true,
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        RunExclusive = true,
        ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
        {
            Version = "<version>",
        }},
        AuthenticationTokenSettings = new AuthenticationTokenSettings
        {
            Access = { AccessScope.Job },
        },
        AllowLowPriorityNode = true,
    },
    JobPreparationTask = new BatchJobPreparationTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        Constraints = default,
        WaitForSuccess = true,
        UserIdentity = default,
        RerunOnNodeRebootAfterSuccess = true,
    },
    JobReleaseTask = new BatchJobReleaseTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        UserIdentity = default,
    },
    CommonEnvironmentSettings = { default },
    OnAllTasksComplete = OnAllBatchTasksComplete.NoAction,
    OnTaskFailure = OnBatchTaskFailure.NoAction,
    NetworkConfiguration = new BatchJobNetworkConfiguration("<subnetId>"),
    Metadata = { default },
};
Response response = client.CreateJob(job, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateJob (Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateJob(class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateJob(Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateJob (content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateJob : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateJob : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.CreateJob (content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a Job to the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateJob(Azure.Compute.Batch.BatchJobCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    poolInfo = new object(),
});
Response response = client.CreateJob(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateJob with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    displayName = "<displayName>",
    usesTaskDependencies = true,
    priority = 1234,
    allowTaskPreemption = true,
    maxParallelTasks = 1234,
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    jobManagerTask = new
    {
        id = "<id>",
        displayName = "<displayName>",
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            registry = new
            {
                username = "<username>",
                password = "<password>",
                registryServer = "<registryServer>",
                identityReference = new
                {
                    resourceId = "<resourceId>",
                },
            },
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        outputFiles = new object[]
        {
            new
            {
                filePattern = "<filePattern>",
                destination = new
                {
                    container = new
                    {
                        path = "<path>",
                        containerUrl = "<containerUrl>",
                        uploadHeaders = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                value = "<value>",
                            }
                        },
                    },
                },
                uploadOptions = new
                {
                    uploadCondition = "tasksuccess",
                },
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        requiredSlots = 1234,
        killJobOnCompletion = true,
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        runExclusive = true,
        applicationPackageReferences = new object[]
        {
            new
            {
                applicationId = "<applicationId>",
                version = "<version>",
            }
        },
        authenticationTokenSettings = new
        {
            access = new object[]
            {
                "job"
            },
        },
        allowLowPriorityNode = true,
    },
    jobPreparationTask = new
    {
        id = "<id>",
        commandLine = "<commandLine>",
        resourceFiles = new object[]
        {
            null
        },
        environmentSettings = new object[]
        {
            null
        },
        waitForSuccess = true,
        rerunOnNodeRebootAfterSuccess = true,
    },
    jobReleaseTask = new
    {
        id = "<id>",
        commandLine = "<commandLine>",
        resourceFiles = new object[]
        {
            null
        },
        environmentSettings = new object[]
        {
            null
        },
        maxWallClockTime = "PT1H23M45S",
        retentionTime = "PT1H23M45S",
    },
    commonEnvironmentSettings = new object[]
    {
        null
    },
    poolInfo = new
    {
        poolId = "<poolId>",
        autoPoolSpecification = new
        {
            autoPoolIdPrefix = "<autoPoolIdPrefix>",
            poolLifetimeOption = "jobschedule",
            keepAlive = true,
            pool = new
            {
                displayName = "<displayName>",
                vmSize = "<vmSize>",
                virtualMachineConfiguration = new
                {
                    imageReference = new
                    {
                        publisher = "<publisher>",
                        offer = "<offer>",
                        sku = "<sku>",
                        version = "<version>",
                        virtualMachineImageId = "<virtualMachineImageId>",
                    },
                    nodeAgentSKUId = "<nodeAgentSKUId>",
                    windowsConfiguration = new
                    {
                        enableAutomaticUpdates = true,
                    },
                    dataDisks = new object[]
                    {
                        new
                        {
                            lun = 1234,
                            caching = "none",
                            diskSizeGB = 1234,
                            storageAccountType = "standard_lrs",
                        }
                    },
                    licenseType = "<licenseType>",
                    containerConfiguration = new
                    {
                        type = "dockerCompatible",
                        containerImageNames = new object[]
                        {
                            "<containerImageNames>"
                        },
                        containerRegistries = new object[]
                        {
                            null
                        },
                    },
                    diskEncryptionConfiguration = new
                    {
                        targets = new object[]
                        {
                            "osdisk"
                        },
                    },
                    nodePlacementConfiguration = new
                    {
                        policy = "regional",
                    },
                    extensions = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            publisher = "<publisher>",
                            type = "<type>",
                            typeHandlerVersion = "<typeHandlerVersion>",
                            autoUpgradeMinorVersion = true,
                            enableAutomaticUpgrade = true,
                            settings = new
                            {
                                key = "<settings>",
                            },
                            protectedSettings = new
                            {
                                key = "<protectedSettings>",
                            },
                            provisionAfterExtensions = new object[]
                            {
                                "<provisionAfterExtensions>"
                            },
                        }
                    },
                    osDisk = new
                    {
                        ephemeralOSDiskSettings = new
                        {
                            placement = "cachedisk",
                        },
                        caching = "none",
                        diskSizeGB = 1234,
                        managedDisk = new
                        {
                            storageAccountType = "standard_lrs",
                        },
                        writeAcceleratorEnabled = true,
                    },
                    securityProfile = new
                    {
                        encryptionAtHost = true,
                        securityType = "trustedLaunch",
                        uefiSettings = new
                        {
                            secureBootEnabled = true,
                            vTpmEnabled = true,
                        },
                    },
                    serviceArtifactReference = new
                    {
                        id = "<id>",
                    },
                },
                taskSlotsPerNode = 1234,
                taskSchedulingPolicy = new
                {
                    nodeFillType = "spread",
                },
                resizeTimeout = "PT1H23M45S",
                resourceTags = "<resourceTags>",
                targetDedicatedNodes = 1234,
                targetLowPriorityNodes = 1234,
                enableAutoScale = true,
                autoScaleFormula = "<autoScaleFormula>",
                autoScaleEvaluationInterval = "PT1H23M45S",
                enableInterNodeCommunication = true,
                networkConfiguration = new
                {
                    subnetId = "<subnetId>",
                    dynamicVNetAssignmentScope = "none",
                    endpointConfiguration = new
                    {
                        inboundNATPools = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                protocol = "tcp",
                                backendPort = 1234,
                                frontendPortRangeStart = 1234,
                                frontendPortRangeEnd = 1234,
                                networkSecurityGroupRules = new object[]
                                {
                                    new
                                    {
                                        priority = 1234,
                                        access = "allow",
                                        sourceAddressPrefix = "<sourceAddressPrefix>",
                                        sourcePortRanges = new object[]
                                        {
                                            "<sourcePortRanges>"
                                        },
                                    }
                                },
                            }
                        },
                    },
                    publicIPAddressConfiguration = new
                    {
                        provision = "batchmanaged",
                        ipAddressIds = new object[]
                        {
                            "<ipAddressIds>"
                        },
                    },
                    enableAcceleratedNetworking = true,
                },
                startTask = new
                {
                    commandLine = "<commandLine>",
                    resourceFiles = new object[]
                    {
                        null
                    },
                    environmentSettings = new object[]
                    {
                        null
                    },
                    maxTaskRetryCount = 1234,
                    waitForSuccess = true,
                },
                applicationPackageReferences = new object[]
                {
                    null
                },
                userAccounts = new object[]
                {
                    new
                    {
                        name = "<name>",
                        password = "<password>",
                        elevationLevel = "nonadmin",
                        linuxUserConfiguration = new
                        {
                            uid = 1234,
                            gid = 1234,
                            sshPrivateKey = "<sshPrivateKey>",
                        },
                        windowsUserConfiguration = new
                        {
                            loginMode = "batch",
                        },
                    }
                },
                metadata = new object[]
                {
                    new
                    {
                        name = "<name>",
                        value = "<value>",
                    }
                },
                mountConfiguration = new object[]
                {
                    new
                    {
                        azureBlobFileSystemConfiguration = new
                        {
                            accountName = "<accountName>",
                            containerName = "<containerName>",
                            accountKey = "<accountKey>",
                            sasKey = "<sasKey>",
                            blobfuseOptions = "<blobfuseOptions>",
                            relativeMountPath = "<relativeMountPath>",
                        },
                        nfsMountConfiguration = new
                        {
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                        cifsMountConfiguration = new
                        {
                            username = "<username>",
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                            password = "<password>",
                        },
                        azureFileShareConfiguration = new
                        {
                            accountName = "<accountName>",
                            azureFileUrl = "<azureFileUrl>",
                            accountKey = "<accountKey>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                    }
                },
                targetNodeCommunicationMode = "default",
                upgradePolicy = new
                {
                    mode = "automatic",
                    automaticOSUpgradePolicy = new
                    {
                        disableAutomaticRollback = true,
                        enableAutomaticOSUpgrade = true,
                        useRollingUpgradePolicy = true,
                        osRollingUpgradeDeferral = true,
                    },
                    rollingUpgradePolicy = new
                    {
                        enableCrossZoneUpgrade = true,
                        maxBatchInstancePercent = 1234,
                        maxUnhealthyInstancePercent = 1234,
                        maxUnhealthyUpgradedInstancePercent = 1234,
                        pauseTimeBetweenBatches = "PT1H23M45S",
                        prioritizeUnhealthyInstances = true,
                        rollbackFailedInstancesOnPolicyBreach = true,
                    },
                },
            },
        },
    },
    onAllTasksComplete = "noaction",
    onTaskFailure = "noaction",
    networkConfiguration = new
    {
        subnetId = "<subnetId>",
    },
    metadata = new object[]
    {
        null
    },
});
Response response = client.CreateJob(content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateJobAsync (Azure.Compute.Batch.BatchJobCreateContent job, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateJobAsync(class Azure.Compute.Batch.BatchJobCreateContent job, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateJobAsync(Azure.Compute.Batch.BatchJobCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateJobAsync (job As BatchJobCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateJobAsync : Azure.Compute.Batch.BatchJobCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateJobAsync : Azure.Compute.Batch.BatchJobCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateJobAsync (job, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="job" Type="Azure.Compute.Batch.BatchJobCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="job"> The Job to be created. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Creates a Job to the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>
            The Batch service supports two ways to control the work done as part of a Job.
            In the first approach, the user specifies a Job Manager Task. The Batch service
            launches this Task when it is ready to start the Job. The Job Manager Task
            controls all other Tasks that run under this Job, by using the Task APIs. In
            the second approach, the user directly controls the execution of Tasks under an
            active Job, by using the Task APIs. Also note: when naming Jobs, avoid
            including sensitive information such as user names or secret project names.
            This information may appear in telemetry logs accessible to Microsoft Support
            engineers.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="job" /> is null. </exception>
        <example>
This sample shows how to call CreateJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobCreateContent job = new BatchJobCreateContent("<id>", new BatchPoolInfo());
Response response = await client.CreateJobAsync(job);
]]></code>
This sample shows how to call CreateJobAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobCreateContent job = new BatchJobCreateContent("<id>", new BatchPoolInfo
{
    PoolId = "<poolId>",
    AutoPoolSpecification = new BatchAutoPoolSpecification(BatchPoolLifetimeOption.JobSchedule)
    {
        AutoPoolIdPrefix = "<autoPoolIdPrefix>",
        KeepAlive = true,
        Pool = new BatchPoolSpecification("<vmSize>")
        {
            DisplayName = "<displayName>",
            VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
            {
                Publisher = "<publisher>",
                Offer = "<offer>",
                Sku = "<sku>",
                Version = "<version>",
                VirtualMachineImageId = "<virtualMachineImageId>",
            }, "<nodeAgentSKUId>")
            {
                WindowsConfiguration = new WindowsConfiguration
                {
                    EnableAutomaticUpdates = true,
                },
                DataDisks = {new DataDisk(1234, 1234)
                {
                    Caching = CachingType.None,
                    StorageAccountType = StorageAccountType.StandardLRS,
                }},
                LicenseType = "<licenseType>",
                ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
                {
                    ContainerImageNames = { "<containerImageNames>" },
                    ContainerRegistries = { default },
                },
                DiskEncryptionConfiguration = new DiskEncryptionConfiguration
                {
                    Targets = { DiskEncryptionTarget.OsDisk },
                },
                NodePlacementConfiguration = new BatchNodePlacementConfiguration
                {
                    Policy = BatchNodePlacementPolicyType.Regional,
                },
                Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
                {
                    TypeHandlerVersion = "<typeHandlerVersion>",
                    AutoUpgradeMinorVersion = true,
                    EnableAutomaticUpgrade = true,
                    Settings =
                    {
                        ["key"] = "<settings>"
                    },
                    ProtectedSettings =
                    {
                        ["key"] = "<protectedSettings>"
                    },
                    ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
                }},
                OsDisk = new OSDisk
                {
                    EphemeralOSDiskSettings = new DiffDiskSettings
                    {
                        Placement = DiffDiskPlacement.CacheDisk,
                    },
                    Caching = CachingType.None,
                    DiskSizeGB = 1234,
                    ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
                    WriteAcceleratorEnabled = true,
                },
                SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
                {
                    SecureBootEnabled = true,
                    VTpmEnabled = true,
                }),
                ServiceArtifactReference = new ServiceArtifactReference("<id>"),
            },
            TaskSlotsPerNode = 1234,
            TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
            ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
            ResourceTags = "<resourceTags>",
            TargetDedicatedNodes = 1234,
            TargetLowPriorityNodes = 1234,
            EnableAutoScale = true,
            AutoScaleFormula = "<autoScaleFormula>",
            AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
            EnableInterNodeCommunication = true,
            NetworkConfiguration = new NetworkConfiguration
            {
                SubnetId = "<subnetId>",
                DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
                EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
                {
                    new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
                    {
                        NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                        {
                            SourcePortRanges = {"<sourcePortRanges>"},
                        }},
                    }
                }),
                PublicIpAddressConfiguration = new PublicIpAddressConfiguration
                {
                    IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
                    IpAddressIds = { "<ipAddressIds>" },
                },
                EnableAcceleratedNetworking = true,
            },
            StartTask = new BatchStartTask("<commandLine>")
            {
                ContainerSettings = default,
                ResourceFiles = { default },
                EnvironmentSettings = { default },
                UserIdentity = default,
                MaxTaskRetryCount = 1234,
                WaitForSuccess = true,
            },
            ApplicationPackageReferences = { default },
            UserAccounts = {new UserAccount("<name>", "<password>")
            {
                ElevationLevel = ElevationLevel.NonAdmin,
                LinuxUserConfiguration = new LinuxUserConfiguration
                {
                    Uid = 1234,
                    Gid = 1234,
                    SshPrivateKey = "<sshPrivateKey>",
                },
                WindowsUserConfiguration = new WindowsUserConfiguration
                {
                    LoginMode = LoginMode.Batch,
                },
            }},
            Metadata = { new MetadataItem("<name>", "<value>") },
            MountConfiguration = {new MountConfiguration
            {
                AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
                {
                    AccountKey = "<accountKey>",
                    SasKey = "<sasKey>",
                    BlobfuseOptions = "<blobfuseOptions>",
                    IdentityReference = default,
                },
                NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
                CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
                {
                    MountOptions = "<mountOptions>",
                },
                AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
            }},
            TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
            UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
            {
                AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
                {
                    DisableAutomaticRollback = true,
                    EnableAutomaticOsUpgrade = true,
                    UseRollingUpgradePolicy = true,
                    OsRollingUpgradeDeferral = true,
                },
                RollingUpgradePolicy = new RollingUpgradePolicy
                {
                    EnableCrossZoneUpgrade = true,
                    MaxBatchInstancePercent = 1234,
                    MaxUnhealthyInstancePercent = 1234,
                    MaxUnhealthyUpgradedInstancePercent = 1234,
                    PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
                    PrioritizeUnhealthyInstances = true,
                    RollbackFailedInstancesOnPolicyBreach = true,
                },
            },
        },
    },
})
{
    DisplayName = "<displayName>",
    UsesTaskDependencies = true,
    Priority = 1234,
    AllowTaskPreemption = true,
    MaxParallelTasks = 1234,
    Constraints = new BatchJobConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    JobManagerTask = new BatchJobManagerTask("<id>", "<commandLine>")
    {
        DisplayName = "<displayName>",
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
        {
            Container = new OutputFileBlobContainerDestination("<containerUrl>")
            {
                Path = "<path>",
                IdentityReference = default,
                UploadHeaders = {new HttpHeader("<name>")
                {
                    Value = "<value>",
                }},
            },
        }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        Constraints = new BatchTaskConstraints
        {
            MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            MaxTaskRetryCount = 1234,
        },
        RequiredSlots = 1234,
        KillJobOnCompletion = true,
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        RunExclusive = true,
        ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
        {
            Version = "<version>",
        }},
        AuthenticationTokenSettings = new AuthenticationTokenSettings
        {
            Access = { AccessScope.Job },
        },
        AllowLowPriorityNode = true,
    },
    JobPreparationTask = new BatchJobPreparationTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        Constraints = default,
        WaitForSuccess = true,
        UserIdentity = default,
        RerunOnNodeRebootAfterSuccess = true,
    },
    JobReleaseTask = new BatchJobReleaseTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        UserIdentity = default,
    },
    CommonEnvironmentSettings = { default },
    OnAllTasksComplete = OnAllBatchTasksComplete.NoAction,
    OnTaskFailure = OnBatchTaskFailure.NoAction,
    NetworkConfiguration = new BatchJobNetworkConfiguration("<subnetId>"),
    Metadata = { default },
};
Response response = await client.CreateJobAsync(job, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateJobAsync (Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateJobAsync(class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateJobAsync(Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateJobAsync (content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateJobAsync : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateJobAsync : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateJobAsync (content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a Job to the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateJobAsync(Azure.Compute.Batch.BatchJobCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    poolInfo = new object(),
});
Response response = await client.CreateJobAsync(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateJobAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    displayName = "<displayName>",
    usesTaskDependencies = true,
    priority = 1234,
    allowTaskPreemption = true,
    maxParallelTasks = 1234,
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    jobManagerTask = new
    {
        id = "<id>",
        displayName = "<displayName>",
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            registry = new
            {
                username = "<username>",
                password = "<password>",
                registryServer = "<registryServer>",
                identityReference = new
                {
                    resourceId = "<resourceId>",
                },
            },
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        outputFiles = new object[]
        {
            new
            {
                filePattern = "<filePattern>",
                destination = new
                {
                    container = new
                    {
                        path = "<path>",
                        containerUrl = "<containerUrl>",
                        uploadHeaders = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                value = "<value>",
                            }
                        },
                    },
                },
                uploadOptions = new
                {
                    uploadCondition = "tasksuccess",
                },
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        requiredSlots = 1234,
        killJobOnCompletion = true,
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        runExclusive = true,
        applicationPackageReferences = new object[]
        {
            new
            {
                applicationId = "<applicationId>",
                version = "<version>",
            }
        },
        authenticationTokenSettings = new
        {
            access = new object[]
            {
                "job"
            },
        },
        allowLowPriorityNode = true,
    },
    jobPreparationTask = new
    {
        id = "<id>",
        commandLine = "<commandLine>",
        resourceFiles = new object[]
        {
            null
        },
        environmentSettings = new object[]
        {
            null
        },
        waitForSuccess = true,
        rerunOnNodeRebootAfterSuccess = true,
    },
    jobReleaseTask = new
    {
        id = "<id>",
        commandLine = "<commandLine>",
        resourceFiles = new object[]
        {
            null
        },
        environmentSettings = new object[]
        {
            null
        },
        maxWallClockTime = "PT1H23M45S",
        retentionTime = "PT1H23M45S",
    },
    commonEnvironmentSettings = new object[]
    {
        null
    },
    poolInfo = new
    {
        poolId = "<poolId>",
        autoPoolSpecification = new
        {
            autoPoolIdPrefix = "<autoPoolIdPrefix>",
            poolLifetimeOption = "jobschedule",
            keepAlive = true,
            pool = new
            {
                displayName = "<displayName>",
                vmSize = "<vmSize>",
                virtualMachineConfiguration = new
                {
                    imageReference = new
                    {
                        publisher = "<publisher>",
                        offer = "<offer>",
                        sku = "<sku>",
                        version = "<version>",
                        virtualMachineImageId = "<virtualMachineImageId>",
                    },
                    nodeAgentSKUId = "<nodeAgentSKUId>",
                    windowsConfiguration = new
                    {
                        enableAutomaticUpdates = true,
                    },
                    dataDisks = new object[]
                    {
                        new
                        {
                            lun = 1234,
                            caching = "none",
                            diskSizeGB = 1234,
                            storageAccountType = "standard_lrs",
                        }
                    },
                    licenseType = "<licenseType>",
                    containerConfiguration = new
                    {
                        type = "dockerCompatible",
                        containerImageNames = new object[]
                        {
                            "<containerImageNames>"
                        },
                        containerRegistries = new object[]
                        {
                            null
                        },
                    },
                    diskEncryptionConfiguration = new
                    {
                        targets = new object[]
                        {
                            "osdisk"
                        },
                    },
                    nodePlacementConfiguration = new
                    {
                        policy = "regional",
                    },
                    extensions = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            publisher = "<publisher>",
                            type = "<type>",
                            typeHandlerVersion = "<typeHandlerVersion>",
                            autoUpgradeMinorVersion = true,
                            enableAutomaticUpgrade = true,
                            settings = new
                            {
                                key = "<settings>",
                            },
                            protectedSettings = new
                            {
                                key = "<protectedSettings>",
                            },
                            provisionAfterExtensions = new object[]
                            {
                                "<provisionAfterExtensions>"
                            },
                        }
                    },
                    osDisk = new
                    {
                        ephemeralOSDiskSettings = new
                        {
                            placement = "cachedisk",
                        },
                        caching = "none",
                        diskSizeGB = 1234,
                        managedDisk = new
                        {
                            storageAccountType = "standard_lrs",
                        },
                        writeAcceleratorEnabled = true,
                    },
                    securityProfile = new
                    {
                        encryptionAtHost = true,
                        securityType = "trustedLaunch",
                        uefiSettings = new
                        {
                            secureBootEnabled = true,
                            vTpmEnabled = true,
                        },
                    },
                    serviceArtifactReference = new
                    {
                        id = "<id>",
                    },
                },
                taskSlotsPerNode = 1234,
                taskSchedulingPolicy = new
                {
                    nodeFillType = "spread",
                },
                resizeTimeout = "PT1H23M45S",
                resourceTags = "<resourceTags>",
                targetDedicatedNodes = 1234,
                targetLowPriorityNodes = 1234,
                enableAutoScale = true,
                autoScaleFormula = "<autoScaleFormula>",
                autoScaleEvaluationInterval = "PT1H23M45S",
                enableInterNodeCommunication = true,
                networkConfiguration = new
                {
                    subnetId = "<subnetId>",
                    dynamicVNetAssignmentScope = "none",
                    endpointConfiguration = new
                    {
                        inboundNATPools = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                protocol = "tcp",
                                backendPort = 1234,
                                frontendPortRangeStart = 1234,
                                frontendPortRangeEnd = 1234,
                                networkSecurityGroupRules = new object[]
                                {
                                    new
                                    {
                                        priority = 1234,
                                        access = "allow",
                                        sourceAddressPrefix = "<sourceAddressPrefix>",
                                        sourcePortRanges = new object[]
                                        {
                                            "<sourcePortRanges>"
                                        },
                                    }
                                },
                            }
                        },
                    },
                    publicIPAddressConfiguration = new
                    {
                        provision = "batchmanaged",
                        ipAddressIds = new object[]
                        {
                            "<ipAddressIds>"
                        },
                    },
                    enableAcceleratedNetworking = true,
                },
                startTask = new
                {
                    commandLine = "<commandLine>",
                    resourceFiles = new object[]
                    {
                        null
                    },
                    environmentSettings = new object[]
                    {
                        null
                    },
                    maxTaskRetryCount = 1234,
                    waitForSuccess = true,
                },
                applicationPackageReferences = new object[]
                {
                    null
                },
                userAccounts = new object[]
                {
                    new
                    {
                        name = "<name>",
                        password = "<password>",
                        elevationLevel = "nonadmin",
                        linuxUserConfiguration = new
                        {
                            uid = 1234,
                            gid = 1234,
                            sshPrivateKey = "<sshPrivateKey>",
                        },
                        windowsUserConfiguration = new
                        {
                            loginMode = "batch",
                        },
                    }
                },
                metadata = new object[]
                {
                    new
                    {
                        name = "<name>",
                        value = "<value>",
                    }
                },
                mountConfiguration = new object[]
                {
                    new
                    {
                        azureBlobFileSystemConfiguration = new
                        {
                            accountName = "<accountName>",
                            containerName = "<containerName>",
                            accountKey = "<accountKey>",
                            sasKey = "<sasKey>",
                            blobfuseOptions = "<blobfuseOptions>",
                            relativeMountPath = "<relativeMountPath>",
                        },
                        nfsMountConfiguration = new
                        {
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                        cifsMountConfiguration = new
                        {
                            username = "<username>",
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                            password = "<password>",
                        },
                        azureFileShareConfiguration = new
                        {
                            accountName = "<accountName>",
                            azureFileUrl = "<azureFileUrl>",
                            accountKey = "<accountKey>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                    }
                },
                targetNodeCommunicationMode = "default",
                upgradePolicy = new
                {
                    mode = "automatic",
                    automaticOSUpgradePolicy = new
                    {
                        disableAutomaticRollback = true,
                        enableAutomaticOSUpgrade = true,
                        useRollingUpgradePolicy = true,
                        osRollingUpgradeDeferral = true,
                    },
                    rollingUpgradePolicy = new
                    {
                        enableCrossZoneUpgrade = true,
                        maxBatchInstancePercent = 1234,
                        maxUnhealthyInstancePercent = 1234,
                        maxUnhealthyUpgradedInstancePercent = 1234,
                        pauseTimeBetweenBatches = "PT1H23M45S",
                        prioritizeUnhealthyInstances = true,
                        rollbackFailedInstancesOnPolicyBreach = true,
                    },
                },
            },
        },
    },
    onAllTasksComplete = "noaction",
    onTaskFailure = "noaction",
    networkConfiguration = new
    {
        subnetId = "<subnetId>",
    },
    metadata = new object[]
    {
        null
    },
});
Response response = await client.CreateJobAsync(content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateJobSchedule (Azure.Compute.Batch.BatchJobScheduleCreateContent jobSchedule, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateJobSchedule(class Azure.Compute.Batch.BatchJobScheduleCreateContent jobSchedule, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateJobSchedule(Azure.Compute.Batch.BatchJobScheduleCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateJobSchedule (jobSchedule As BatchJobScheduleCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateJobSchedule : Azure.Compute.Batch.BatchJobScheduleCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.CreateJobSchedule : Azure.Compute.Batch.BatchJobScheduleCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.CreateJobSchedule (jobSchedule, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobSchedule" Type="Azure.Compute.Batch.BatchJobScheduleCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobSchedule"> The Job Schedule to be created. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Creates a Job Schedule to the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobSchedule" /> is null. </exception>
        <example>
This sample shows how to call CreateJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobScheduleCreateContent jobSchedule = new BatchJobScheduleCreateContent("<id>", new BatchJobScheduleConfiguration(), new BatchJobSpecification(new BatchPoolInfo()));
Response response = client.CreateJobSchedule(jobSchedule);
]]></code>
This sample shows how to call CreateJobSchedule with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobScheduleCreateContent jobSchedule = new BatchJobScheduleCreateContent("<id>", new BatchJobScheduleConfiguration
{
    DoNotRunUntil = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    DoNotRunAfter = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    StartWindow = XmlConvert.ToTimeSpan("PT1H23M45S"),
    RecurrenceInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
}, new BatchJobSpecification(new BatchPoolInfo
{
    PoolId = "<poolId>",
    AutoPoolSpecification = new BatchAutoPoolSpecification(BatchPoolLifetimeOption.JobSchedule)
    {
        AutoPoolIdPrefix = "<autoPoolIdPrefix>",
        KeepAlive = true,
        Pool = new BatchPoolSpecification("<vmSize>")
        {
            DisplayName = "<displayName>",
            VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
            {
                Publisher = "<publisher>",
                Offer = "<offer>",
                Sku = "<sku>",
                Version = "<version>",
                VirtualMachineImageId = "<virtualMachineImageId>",
            }, "<nodeAgentSKUId>")
            {
                WindowsConfiguration = new WindowsConfiguration
                {
                    EnableAutomaticUpdates = true,
                },
                DataDisks = {new DataDisk(1234, 1234)
                {
                    Caching = CachingType.None,
                    StorageAccountType = StorageAccountType.StandardLRS,
                }},
                LicenseType = "<licenseType>",
                ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
                {
                    ContainerImageNames = { "<containerImageNames>" },
                    ContainerRegistries = { default },
                },
                DiskEncryptionConfiguration = new DiskEncryptionConfiguration
                {
                    Targets = { DiskEncryptionTarget.OsDisk },
                },
                NodePlacementConfiguration = new BatchNodePlacementConfiguration
                {
                    Policy = BatchNodePlacementPolicyType.Regional,
                },
                Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
                {
                    TypeHandlerVersion = "<typeHandlerVersion>",
                    AutoUpgradeMinorVersion = true,
                    EnableAutomaticUpgrade = true,
                    Settings =
                    {
                        ["key"] = "<settings>"
                    },
                    ProtectedSettings =
                    {
                        ["key"] = "<protectedSettings>"
                    },
                    ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
                }},
                OsDisk = new OSDisk
                {
                    EphemeralOSDiskSettings = new DiffDiskSettings
                    {
                        Placement = DiffDiskPlacement.CacheDisk,
                    },
                    Caching = CachingType.None,
                    DiskSizeGB = 1234,
                    ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
                    WriteAcceleratorEnabled = true,
                },
                SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
                {
                    SecureBootEnabled = true,
                    VTpmEnabled = true,
                }),
                ServiceArtifactReference = new ServiceArtifactReference("<id>"),
            },
            TaskSlotsPerNode = 1234,
            TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
            ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
            ResourceTags = "<resourceTags>",
            TargetDedicatedNodes = 1234,
            TargetLowPriorityNodes = 1234,
            EnableAutoScale = true,
            AutoScaleFormula = "<autoScaleFormula>",
            AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
            EnableInterNodeCommunication = true,
            NetworkConfiguration = new NetworkConfiguration
            {
                SubnetId = "<subnetId>",
                DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
                EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
                {
                    new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
                    {
                        NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                        {
                            SourcePortRanges = {"<sourcePortRanges>"},
                        }},
                    }
                }),
                PublicIpAddressConfiguration = new PublicIpAddressConfiguration
                {
                    IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
                    IpAddressIds = { "<ipAddressIds>" },
                },
                EnableAcceleratedNetworking = true,
            },
            StartTask = new BatchStartTask("<commandLine>")
            {
                ContainerSettings = default,
                ResourceFiles = { default },
                EnvironmentSettings = { default },
                UserIdentity = default,
                MaxTaskRetryCount = 1234,
                WaitForSuccess = true,
            },
            ApplicationPackageReferences = { default },
            UserAccounts = {new UserAccount("<name>", "<password>")
            {
                ElevationLevel = ElevationLevel.NonAdmin,
                LinuxUserConfiguration = new LinuxUserConfiguration
                {
                    Uid = 1234,
                    Gid = 1234,
                    SshPrivateKey = "<sshPrivateKey>",
                },
                WindowsUserConfiguration = new WindowsUserConfiguration
                {
                    LoginMode = LoginMode.Batch,
                },
            }},
            Metadata = { new MetadataItem("<name>", "<value>") },
            MountConfiguration = {new MountConfiguration
            {
                AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
                {
                    AccountKey = "<accountKey>",
                    SasKey = "<sasKey>",
                    BlobfuseOptions = "<blobfuseOptions>",
                    IdentityReference = default,
                },
                NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
                CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
                {
                    MountOptions = "<mountOptions>",
                },
                AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
            }},
            TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
            UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
            {
                AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
                {
                    DisableAutomaticRollback = true,
                    EnableAutomaticOsUpgrade = true,
                    UseRollingUpgradePolicy = true,
                    OsRollingUpgradeDeferral = true,
                },
                RollingUpgradePolicy = new RollingUpgradePolicy
                {
                    EnableCrossZoneUpgrade = true,
                    MaxBatchInstancePercent = 1234,
                    MaxUnhealthyInstancePercent = 1234,
                    MaxUnhealthyUpgradedInstancePercent = 1234,
                    PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
                    PrioritizeUnhealthyInstances = true,
                    RollbackFailedInstancesOnPolicyBreach = true,
                },
            },
        },
    },
})
{
    Priority = 1234,
    AllowTaskPreemption = true,
    MaxParallelTasks = 1234,
    DisplayName = "<displayName>",
    UsesTaskDependencies = true,
    OnAllTasksComplete = OnAllBatchTasksComplete.NoAction,
    OnTaskFailure = OnBatchTaskFailure.NoAction,
    NetworkConfiguration = new BatchJobNetworkConfiguration("<subnetId>"),
    Constraints = new BatchJobConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    JobManagerTask = new BatchJobManagerTask("<id>", "<commandLine>")
    {
        DisplayName = "<displayName>",
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
        {
            Container = new OutputFileBlobContainerDestination("<containerUrl>")
            {
                Path = "<path>",
                IdentityReference = default,
                UploadHeaders = {new HttpHeader("<name>")
                {
                    Value = "<value>",
                }},
            },
        }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        Constraints = new BatchTaskConstraints
        {
            MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            MaxTaskRetryCount = 1234,
        },
        RequiredSlots = 1234,
        KillJobOnCompletion = true,
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        RunExclusive = true,
        ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
        {
            Version = "<version>",
        }},
        AuthenticationTokenSettings = new AuthenticationTokenSettings
        {
            Access = { AccessScope.Job },
        },
        AllowLowPriorityNode = true,
    },
    JobPreparationTask = new BatchJobPreparationTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        Constraints = default,
        WaitForSuccess = true,
        UserIdentity = default,
        RerunOnNodeRebootAfterSuccess = true,
    },
    JobReleaseTask = new BatchJobReleaseTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        UserIdentity = default,
    },
    CommonEnvironmentSettings = { default },
    Metadata = { default },
})
{
    DisplayName = "<displayName>",
    Metadata = { default },
};
Response response = client.CreateJobSchedule(jobSchedule, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateJobSchedule (Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateJobSchedule(class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateJobSchedule(Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateJobSchedule (content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateJobSchedule : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateJobSchedule : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.CreateJobSchedule (content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a Job Schedule to the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateJobSchedule(Azure.Compute.Batch.BatchJobScheduleCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    schedule = new object(),
    jobSpecification = new
    {
        poolInfo = new object(),
    },
});
Response response = client.CreateJobSchedule(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateJobSchedule with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    displayName = "<displayName>",
    schedule = new
    {
        doNotRunUntil = "2022-05-10T18:57:31.2311892Z",
        doNotRunAfter = "2022-05-10T18:57:31.2311892Z",
        startWindow = "PT1H23M45S",
        recurrenceInterval = "PT1H23M45S",
    },
    jobSpecification = new
    {
        priority = 1234,
        allowTaskPreemption = true,
        maxParallelTasks = 1234,
        displayName = "<displayName>",
        usesTaskDependencies = true,
        onAllTasksComplete = "noaction",
        onTaskFailure = "noaction",
        networkConfiguration = new
        {
            subnetId = "<subnetId>",
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        jobManagerTask = new
        {
            id = "<id>",
            displayName = "<displayName>",
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            killJobOnCompletion = true,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            runExclusive = true,
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
            allowLowPriorityNode = true,
        },
        jobPreparationTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            waitForSuccess = true,
            rerunOnNodeRebootAfterSuccess = true,
        },
        jobReleaseTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
        },
        commonEnvironmentSettings = new object[]
        {
            null
        },
        poolInfo = new
        {
            poolId = "<poolId>",
            autoPoolSpecification = new
            {
                autoPoolIdPrefix = "<autoPoolIdPrefix>",
                poolLifetimeOption = "jobschedule",
                keepAlive = true,
                pool = new
                {
                    displayName = "<displayName>",
                    vmSize = "<vmSize>",
                    virtualMachineConfiguration = new
                    {
                        imageReference = new
                        {
                            publisher = "<publisher>",
                            offer = "<offer>",
                            sku = "<sku>",
                            version = "<version>",
                            virtualMachineImageId = "<virtualMachineImageId>",
                        },
                        nodeAgentSKUId = "<nodeAgentSKUId>",
                        windowsConfiguration = new
                        {
                            enableAutomaticUpdates = true,
                        },
                        dataDisks = new object[]
                        {
                            new
                            {
                                lun = 1234,
                                caching = "none",
                                diskSizeGB = 1234,
                                storageAccountType = "standard_lrs",
                            }
                        },
                        licenseType = "<licenseType>",
                        containerConfiguration = new
                        {
                            type = "dockerCompatible",
                            containerImageNames = new object[]
                            {
                                "<containerImageNames>"
                            },
                            containerRegistries = new object[]
                            {
                                null
                            },
                        },
                        diskEncryptionConfiguration = new
                        {
                            targets = new object[]
                            {
                                "osdisk"
                            },
                        },
                        nodePlacementConfiguration = new
                        {
                            policy = "regional",
                        },
                        extensions = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                publisher = "<publisher>",
                                type = "<type>",
                                typeHandlerVersion = "<typeHandlerVersion>",
                                autoUpgradeMinorVersion = true,
                                enableAutomaticUpgrade = true,
                                settings = new
                                {
                                    key = "<settings>",
                                },
                                protectedSettings = new
                                {
                                    key = "<protectedSettings>",
                                },
                                provisionAfterExtensions = new object[]
                                {
                                    "<provisionAfterExtensions>"
                                },
                            }
                        },
                        osDisk = new
                        {
                            ephemeralOSDiskSettings = new
                            {
                                placement = "cachedisk",
                            },
                            caching = "none",
                            diskSizeGB = 1234,
                            managedDisk = new
                            {
                                storageAccountType = "standard_lrs",
                            },
                            writeAcceleratorEnabled = true,
                        },
                        securityProfile = new
                        {
                            encryptionAtHost = true,
                            securityType = "trustedLaunch",
                            uefiSettings = new
                            {
                                secureBootEnabled = true,
                                vTpmEnabled = true,
                            },
                        },
                        serviceArtifactReference = new
                        {
                            id = "<id>",
                        },
                    },
                    taskSlotsPerNode = 1234,
                    taskSchedulingPolicy = new
                    {
                        nodeFillType = "spread",
                    },
                    resizeTimeout = "PT1H23M45S",
                    resourceTags = "<resourceTags>",
                    targetDedicatedNodes = 1234,
                    targetLowPriorityNodes = 1234,
                    enableAutoScale = true,
                    autoScaleFormula = "<autoScaleFormula>",
                    autoScaleEvaluationInterval = "PT1H23M45S",
                    enableInterNodeCommunication = true,
                    networkConfiguration = new
                    {
                        subnetId = "<subnetId>",
                        dynamicVNetAssignmentScope = "none",
                        endpointConfiguration = new
                        {
                            inboundNATPools = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    protocol = "tcp",
                                    backendPort = 1234,
                                    frontendPortRangeStart = 1234,
                                    frontendPortRangeEnd = 1234,
                                    networkSecurityGroupRules = new object[]
                                    {
                                        new
                                        {
                                            priority = 1234,
                                            access = "allow",
                                            sourceAddressPrefix = "<sourceAddressPrefix>",
                                            sourcePortRanges = new object[]
                                            {
                                                "<sourcePortRanges>"
                                            },
                                        }
                                    },
                                }
                            },
                        },
                        publicIPAddressConfiguration = new
                        {
                            provision = "batchmanaged",
                            ipAddressIds = new object[]
                            {
                                "<ipAddressIds>"
                            },
                        },
                        enableAcceleratedNetworking = true,
                    },
                    startTask = new
                    {
                        commandLine = "<commandLine>",
                        resourceFiles = new object[]
                        {
                            null
                        },
                        environmentSettings = new object[]
                        {
                            null
                        },
                        maxTaskRetryCount = 1234,
                        waitForSuccess = true,
                    },
                    applicationPackageReferences = new object[]
                    {
                        null
                    },
                    userAccounts = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            password = "<password>",
                            elevationLevel = "nonadmin",
                            linuxUserConfiguration = new
                            {
                                uid = 1234,
                                gid = 1234,
                                sshPrivateKey = "<sshPrivateKey>",
                            },
                            windowsUserConfiguration = new
                            {
                                loginMode = "batch",
                            },
                        }
                    },
                    metadata = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    mountConfiguration = new object[]
                    {
                        new
                        {
                            azureBlobFileSystemConfiguration = new
                            {
                                accountName = "<accountName>",
                                containerName = "<containerName>",
                                accountKey = "<accountKey>",
                                sasKey = "<sasKey>",
                                blobfuseOptions = "<blobfuseOptions>",
                                relativeMountPath = "<relativeMountPath>",
                            },
                            nfsMountConfiguration = new
                            {
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                            cifsMountConfiguration = new
                            {
                                username = "<username>",
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                                password = "<password>",
                            },
                            azureFileShareConfiguration = new
                            {
                                accountName = "<accountName>",
                                azureFileUrl = "<azureFileUrl>",
                                accountKey = "<accountKey>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                        }
                    },
                    targetNodeCommunicationMode = "default",
                    upgradePolicy = new
                    {
                        mode = "automatic",
                        automaticOSUpgradePolicy = new
                        {
                            disableAutomaticRollback = true,
                            enableAutomaticOSUpgrade = true,
                            useRollingUpgradePolicy = true,
                            osRollingUpgradeDeferral = true,
                        },
                        rollingUpgradePolicy = new
                        {
                            enableCrossZoneUpgrade = true,
                            maxBatchInstancePercent = 1234,
                            maxUnhealthyInstancePercent = 1234,
                            maxUnhealthyUpgradedInstancePercent = 1234,
                            pauseTimeBetweenBatches = "PT1H23M45S",
                            prioritizeUnhealthyInstances = true,
                            rollbackFailedInstancesOnPolicyBreach = true,
                        },
                    },
                },
            },
        },
        metadata = new object[]
        {
            null
        },
    },
    metadata = new object[]
    {
        null
    },
});
Response response = client.CreateJobSchedule(content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateJobScheduleAsync (Azure.Compute.Batch.BatchJobScheduleCreateContent jobSchedule, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateJobScheduleAsync(class Azure.Compute.Batch.BatchJobScheduleCreateContent jobSchedule, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateJobScheduleAsync(Azure.Compute.Batch.BatchJobScheduleCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateJobScheduleAsync (jobSchedule As BatchJobScheduleCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateJobScheduleAsync : Azure.Compute.Batch.BatchJobScheduleCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateJobScheduleAsync : Azure.Compute.Batch.BatchJobScheduleCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateJobScheduleAsync (jobSchedule, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobSchedule" Type="Azure.Compute.Batch.BatchJobScheduleCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobSchedule"> The Job Schedule to be created. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Creates a Job Schedule to the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobSchedule" /> is null. </exception>
        <example>
This sample shows how to call CreateJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobScheduleCreateContent jobSchedule = new BatchJobScheduleCreateContent("<id>", new BatchJobScheduleConfiguration(), new BatchJobSpecification(new BatchPoolInfo()));
Response response = await client.CreateJobScheduleAsync(jobSchedule);
]]></code>
This sample shows how to call CreateJobScheduleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobScheduleCreateContent jobSchedule = new BatchJobScheduleCreateContent("<id>", new BatchJobScheduleConfiguration
{
    DoNotRunUntil = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    DoNotRunAfter = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    StartWindow = XmlConvert.ToTimeSpan("PT1H23M45S"),
    RecurrenceInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
}, new BatchJobSpecification(new BatchPoolInfo
{
    PoolId = "<poolId>",
    AutoPoolSpecification = new BatchAutoPoolSpecification(BatchPoolLifetimeOption.JobSchedule)
    {
        AutoPoolIdPrefix = "<autoPoolIdPrefix>",
        KeepAlive = true,
        Pool = new BatchPoolSpecification("<vmSize>")
        {
            DisplayName = "<displayName>",
            VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
            {
                Publisher = "<publisher>",
                Offer = "<offer>",
                Sku = "<sku>",
                Version = "<version>",
                VirtualMachineImageId = "<virtualMachineImageId>",
            }, "<nodeAgentSKUId>")
            {
                WindowsConfiguration = new WindowsConfiguration
                {
                    EnableAutomaticUpdates = true,
                },
                DataDisks = {new DataDisk(1234, 1234)
                {
                    Caching = CachingType.None,
                    StorageAccountType = StorageAccountType.StandardLRS,
                }},
                LicenseType = "<licenseType>",
                ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
                {
                    ContainerImageNames = { "<containerImageNames>" },
                    ContainerRegistries = { default },
                },
                DiskEncryptionConfiguration = new DiskEncryptionConfiguration
                {
                    Targets = { DiskEncryptionTarget.OsDisk },
                },
                NodePlacementConfiguration = new BatchNodePlacementConfiguration
                {
                    Policy = BatchNodePlacementPolicyType.Regional,
                },
                Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
                {
                    TypeHandlerVersion = "<typeHandlerVersion>",
                    AutoUpgradeMinorVersion = true,
                    EnableAutomaticUpgrade = true,
                    Settings =
                    {
                        ["key"] = "<settings>"
                    },
                    ProtectedSettings =
                    {
                        ["key"] = "<protectedSettings>"
                    },
                    ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
                }},
                OsDisk = new OSDisk
                {
                    EphemeralOSDiskSettings = new DiffDiskSettings
                    {
                        Placement = DiffDiskPlacement.CacheDisk,
                    },
                    Caching = CachingType.None,
                    DiskSizeGB = 1234,
                    ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
                    WriteAcceleratorEnabled = true,
                },
                SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
                {
                    SecureBootEnabled = true,
                    VTpmEnabled = true,
                }),
                ServiceArtifactReference = new ServiceArtifactReference("<id>"),
            },
            TaskSlotsPerNode = 1234,
            TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
            ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
            ResourceTags = "<resourceTags>",
            TargetDedicatedNodes = 1234,
            TargetLowPriorityNodes = 1234,
            EnableAutoScale = true,
            AutoScaleFormula = "<autoScaleFormula>",
            AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
            EnableInterNodeCommunication = true,
            NetworkConfiguration = new NetworkConfiguration
            {
                SubnetId = "<subnetId>",
                DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
                EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
                {
                    new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
                    {
                        NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                        {
                            SourcePortRanges = {"<sourcePortRanges>"},
                        }},
                    }
                }),
                PublicIpAddressConfiguration = new PublicIpAddressConfiguration
                {
                    IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
                    IpAddressIds = { "<ipAddressIds>" },
                },
                EnableAcceleratedNetworking = true,
            },
            StartTask = new BatchStartTask("<commandLine>")
            {
                ContainerSettings = default,
                ResourceFiles = { default },
                EnvironmentSettings = { default },
                UserIdentity = default,
                MaxTaskRetryCount = 1234,
                WaitForSuccess = true,
            },
            ApplicationPackageReferences = { default },
            UserAccounts = {new UserAccount("<name>", "<password>")
            {
                ElevationLevel = ElevationLevel.NonAdmin,
                LinuxUserConfiguration = new LinuxUserConfiguration
                {
                    Uid = 1234,
                    Gid = 1234,
                    SshPrivateKey = "<sshPrivateKey>",
                },
                WindowsUserConfiguration = new WindowsUserConfiguration
                {
                    LoginMode = LoginMode.Batch,
                },
            }},
            Metadata = { new MetadataItem("<name>", "<value>") },
            MountConfiguration = {new MountConfiguration
            {
                AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
                {
                    AccountKey = "<accountKey>",
                    SasKey = "<sasKey>",
                    BlobfuseOptions = "<blobfuseOptions>",
                    IdentityReference = default,
                },
                NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
                CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
                {
                    MountOptions = "<mountOptions>",
                },
                AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
            }},
            TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
            UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
            {
                AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
                {
                    DisableAutomaticRollback = true,
                    EnableAutomaticOsUpgrade = true,
                    UseRollingUpgradePolicy = true,
                    OsRollingUpgradeDeferral = true,
                },
                RollingUpgradePolicy = new RollingUpgradePolicy
                {
                    EnableCrossZoneUpgrade = true,
                    MaxBatchInstancePercent = 1234,
                    MaxUnhealthyInstancePercent = 1234,
                    MaxUnhealthyUpgradedInstancePercent = 1234,
                    PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
                    PrioritizeUnhealthyInstances = true,
                    RollbackFailedInstancesOnPolicyBreach = true,
                },
            },
        },
    },
})
{
    Priority = 1234,
    AllowTaskPreemption = true,
    MaxParallelTasks = 1234,
    DisplayName = "<displayName>",
    UsesTaskDependencies = true,
    OnAllTasksComplete = OnAllBatchTasksComplete.NoAction,
    OnTaskFailure = OnBatchTaskFailure.NoAction,
    NetworkConfiguration = new BatchJobNetworkConfiguration("<subnetId>"),
    Constraints = new BatchJobConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    JobManagerTask = new BatchJobManagerTask("<id>", "<commandLine>")
    {
        DisplayName = "<displayName>",
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
        {
            Container = new OutputFileBlobContainerDestination("<containerUrl>")
            {
                Path = "<path>",
                IdentityReference = default,
                UploadHeaders = {new HttpHeader("<name>")
                {
                    Value = "<value>",
                }},
            },
        }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        Constraints = new BatchTaskConstraints
        {
            MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            MaxTaskRetryCount = 1234,
        },
        RequiredSlots = 1234,
        KillJobOnCompletion = true,
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        RunExclusive = true,
        ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
        {
            Version = "<version>",
        }},
        AuthenticationTokenSettings = new AuthenticationTokenSettings
        {
            Access = { AccessScope.Job },
        },
        AllowLowPriorityNode = true,
    },
    JobPreparationTask = new BatchJobPreparationTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        Constraints = default,
        WaitForSuccess = true,
        UserIdentity = default,
        RerunOnNodeRebootAfterSuccess = true,
    },
    JobReleaseTask = new BatchJobReleaseTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        UserIdentity = default,
    },
    CommonEnvironmentSettings = { default },
    Metadata = { default },
})
{
    DisplayName = "<displayName>",
    Metadata = { default },
};
Response response = await client.CreateJobScheduleAsync(jobSchedule, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateJobScheduleAsync (Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateJobScheduleAsync(class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateJobScheduleAsync(Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateJobScheduleAsync (content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateJobScheduleAsync : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateJobScheduleAsync : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateJobScheduleAsync (content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a Job Schedule to the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateJobScheduleAsync(Azure.Compute.Batch.BatchJobScheduleCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    schedule = new object(),
    jobSpecification = new
    {
        poolInfo = new object(),
    },
});
Response response = await client.CreateJobScheduleAsync(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateJobScheduleAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    displayName = "<displayName>",
    schedule = new
    {
        doNotRunUntil = "2022-05-10T18:57:31.2311892Z",
        doNotRunAfter = "2022-05-10T18:57:31.2311892Z",
        startWindow = "PT1H23M45S",
        recurrenceInterval = "PT1H23M45S",
    },
    jobSpecification = new
    {
        priority = 1234,
        allowTaskPreemption = true,
        maxParallelTasks = 1234,
        displayName = "<displayName>",
        usesTaskDependencies = true,
        onAllTasksComplete = "noaction",
        onTaskFailure = "noaction",
        networkConfiguration = new
        {
            subnetId = "<subnetId>",
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        jobManagerTask = new
        {
            id = "<id>",
            displayName = "<displayName>",
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            killJobOnCompletion = true,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            runExclusive = true,
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
            allowLowPriorityNode = true,
        },
        jobPreparationTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            waitForSuccess = true,
            rerunOnNodeRebootAfterSuccess = true,
        },
        jobReleaseTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
        },
        commonEnvironmentSettings = new object[]
        {
            null
        },
        poolInfo = new
        {
            poolId = "<poolId>",
            autoPoolSpecification = new
            {
                autoPoolIdPrefix = "<autoPoolIdPrefix>",
                poolLifetimeOption = "jobschedule",
                keepAlive = true,
                pool = new
                {
                    displayName = "<displayName>",
                    vmSize = "<vmSize>",
                    virtualMachineConfiguration = new
                    {
                        imageReference = new
                        {
                            publisher = "<publisher>",
                            offer = "<offer>",
                            sku = "<sku>",
                            version = "<version>",
                            virtualMachineImageId = "<virtualMachineImageId>",
                        },
                        nodeAgentSKUId = "<nodeAgentSKUId>",
                        windowsConfiguration = new
                        {
                            enableAutomaticUpdates = true,
                        },
                        dataDisks = new object[]
                        {
                            new
                            {
                                lun = 1234,
                                caching = "none",
                                diskSizeGB = 1234,
                                storageAccountType = "standard_lrs",
                            }
                        },
                        licenseType = "<licenseType>",
                        containerConfiguration = new
                        {
                            type = "dockerCompatible",
                            containerImageNames = new object[]
                            {
                                "<containerImageNames>"
                            },
                            containerRegistries = new object[]
                            {
                                null
                            },
                        },
                        diskEncryptionConfiguration = new
                        {
                            targets = new object[]
                            {
                                "osdisk"
                            },
                        },
                        nodePlacementConfiguration = new
                        {
                            policy = "regional",
                        },
                        extensions = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                publisher = "<publisher>",
                                type = "<type>",
                                typeHandlerVersion = "<typeHandlerVersion>",
                                autoUpgradeMinorVersion = true,
                                enableAutomaticUpgrade = true,
                                settings = new
                                {
                                    key = "<settings>",
                                },
                                protectedSettings = new
                                {
                                    key = "<protectedSettings>",
                                },
                                provisionAfterExtensions = new object[]
                                {
                                    "<provisionAfterExtensions>"
                                },
                            }
                        },
                        osDisk = new
                        {
                            ephemeralOSDiskSettings = new
                            {
                                placement = "cachedisk",
                            },
                            caching = "none",
                            diskSizeGB = 1234,
                            managedDisk = new
                            {
                                storageAccountType = "standard_lrs",
                            },
                            writeAcceleratorEnabled = true,
                        },
                        securityProfile = new
                        {
                            encryptionAtHost = true,
                            securityType = "trustedLaunch",
                            uefiSettings = new
                            {
                                secureBootEnabled = true,
                                vTpmEnabled = true,
                            },
                        },
                        serviceArtifactReference = new
                        {
                            id = "<id>",
                        },
                    },
                    taskSlotsPerNode = 1234,
                    taskSchedulingPolicy = new
                    {
                        nodeFillType = "spread",
                    },
                    resizeTimeout = "PT1H23M45S",
                    resourceTags = "<resourceTags>",
                    targetDedicatedNodes = 1234,
                    targetLowPriorityNodes = 1234,
                    enableAutoScale = true,
                    autoScaleFormula = "<autoScaleFormula>",
                    autoScaleEvaluationInterval = "PT1H23M45S",
                    enableInterNodeCommunication = true,
                    networkConfiguration = new
                    {
                        subnetId = "<subnetId>",
                        dynamicVNetAssignmentScope = "none",
                        endpointConfiguration = new
                        {
                            inboundNATPools = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    protocol = "tcp",
                                    backendPort = 1234,
                                    frontendPortRangeStart = 1234,
                                    frontendPortRangeEnd = 1234,
                                    networkSecurityGroupRules = new object[]
                                    {
                                        new
                                        {
                                            priority = 1234,
                                            access = "allow",
                                            sourceAddressPrefix = "<sourceAddressPrefix>",
                                            sourcePortRanges = new object[]
                                            {
                                                "<sourcePortRanges>"
                                            },
                                        }
                                    },
                                }
                            },
                        },
                        publicIPAddressConfiguration = new
                        {
                            provision = "batchmanaged",
                            ipAddressIds = new object[]
                            {
                                "<ipAddressIds>"
                            },
                        },
                        enableAcceleratedNetworking = true,
                    },
                    startTask = new
                    {
                        commandLine = "<commandLine>",
                        resourceFiles = new object[]
                        {
                            null
                        },
                        environmentSettings = new object[]
                        {
                            null
                        },
                        maxTaskRetryCount = 1234,
                        waitForSuccess = true,
                    },
                    applicationPackageReferences = new object[]
                    {
                        null
                    },
                    userAccounts = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            password = "<password>",
                            elevationLevel = "nonadmin",
                            linuxUserConfiguration = new
                            {
                                uid = 1234,
                                gid = 1234,
                                sshPrivateKey = "<sshPrivateKey>",
                            },
                            windowsUserConfiguration = new
                            {
                                loginMode = "batch",
                            },
                        }
                    },
                    metadata = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    mountConfiguration = new object[]
                    {
                        new
                        {
                            azureBlobFileSystemConfiguration = new
                            {
                                accountName = "<accountName>",
                                containerName = "<containerName>",
                                accountKey = "<accountKey>",
                                sasKey = "<sasKey>",
                                blobfuseOptions = "<blobfuseOptions>",
                                relativeMountPath = "<relativeMountPath>",
                            },
                            nfsMountConfiguration = new
                            {
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                            cifsMountConfiguration = new
                            {
                                username = "<username>",
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                                password = "<password>",
                            },
                            azureFileShareConfiguration = new
                            {
                                accountName = "<accountName>",
                                azureFileUrl = "<azureFileUrl>",
                                accountKey = "<accountKey>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                        }
                    },
                    targetNodeCommunicationMode = "default",
                    upgradePolicy = new
                    {
                        mode = "automatic",
                        automaticOSUpgradePolicy = new
                        {
                            disableAutomaticRollback = true,
                            enableAutomaticOSUpgrade = true,
                            useRollingUpgradePolicy = true,
                            osRollingUpgradeDeferral = true,
                        },
                        rollingUpgradePolicy = new
                        {
                            enableCrossZoneUpgrade = true,
                            maxBatchInstancePercent = 1234,
                            maxUnhealthyInstancePercent = 1234,
                            maxUnhealthyUpgradedInstancePercent = 1234,
                            pauseTimeBetweenBatches = "PT1H23M45S",
                            prioritizeUnhealthyInstances = true,
                            rollbackFailedInstancesOnPolicyBreach = true,
                        },
                    },
                },
            },
        },
        metadata = new object[]
        {
            null
        },
    },
    metadata = new object[]
    {
        null
    },
});
Response response = await client.CreateJobScheduleAsync(content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateNodeUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateNodeUser (string poolId, string nodeId, Azure.Compute.Batch.BatchNodeUserCreateContent user, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateNodeUser(string poolId, string nodeId, class Azure.Compute.Batch.BatchNodeUserCreateContent user, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateNodeUser(System.String,System.String,Azure.Compute.Batch.BatchNodeUserCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNodeUser (poolId As String, nodeId As String, user As BatchNodeUserCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateNodeUser : string * string * Azure.Compute.Batch.BatchNodeUserCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.CreateNodeUser : string * string * Azure.Compute.Batch.BatchNodeUserCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.CreateNodeUser (poolId, nodeId, user, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="user" Type="Azure.Compute.Batch.BatchNodeUserCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        <param name="user"> The options to use for creating the user. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Adds a user Account to the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>
            You can add a user Account to a Compute Node only when it is in the idle or
            running state.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="user" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call CreateNodeUser.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeUserCreateContent user = new BatchNodeUserCreateContent("<name>");
Response response = client.CreateNodeUser("<poolId>", "<nodeId>", user);
]]></code>
This sample shows how to call CreateNodeUser with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeUserCreateContent user = new BatchNodeUserCreateContent("<name>")
{
    IsAdmin = true,
    ExpiryTime = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    Password = "<password>",
    SshPublicKey = "<sshPublicKey>",
};
Response response = client.CreateNodeUser("<poolId>", "<nodeId>", user, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateNodeUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateNodeUser (string poolId, string nodeId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateNodeUser(string poolId, string nodeId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateNodeUser(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNodeUser (poolId As String, nodeId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateNodeUser : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateNodeUser : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.CreateNodeUser (poolId, nodeId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Adds a user Account to the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateNodeUser(System.String,System.String,Azure.Compute.Batch.BatchNodeUserCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateNodeUser.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    name = "<name>",
});
Response response = client.CreateNodeUser("<poolId>", "<nodeId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateNodeUser with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    name = "<name>",
    isAdmin = true,
    expiryTime = "2022-05-10T18:57:31.2311892Z",
    password = "<password>",
    sshPublicKey = "<sshPublicKey>",
});
Response response = client.CreateNodeUser("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateNodeUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateNodeUserAsync (string poolId, string nodeId, Azure.Compute.Batch.BatchNodeUserCreateContent user, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateNodeUserAsync(string poolId, string nodeId, class Azure.Compute.Batch.BatchNodeUserCreateContent user, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateNodeUserAsync(System.String,System.String,Azure.Compute.Batch.BatchNodeUserCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNodeUserAsync (poolId As String, nodeId As String, user As BatchNodeUserCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateNodeUserAsync : string * string * Azure.Compute.Batch.BatchNodeUserCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateNodeUserAsync : string * string * Azure.Compute.Batch.BatchNodeUserCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateNodeUserAsync (poolId, nodeId, user, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="user" Type="Azure.Compute.Batch.BatchNodeUserCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        <param name="user"> The options to use for creating the user. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Adds a user Account to the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>
            You can add a user Account to a Compute Node only when it is in the idle or
            running state.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="user" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call CreateNodeUserAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeUserCreateContent user = new BatchNodeUserCreateContent("<name>");
Response response = await client.CreateNodeUserAsync("<poolId>", "<nodeId>", user);
]]></code>
This sample shows how to call CreateNodeUserAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeUserCreateContent user = new BatchNodeUserCreateContent("<name>")
{
    IsAdmin = true,
    ExpiryTime = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    Password = "<password>",
    SshPublicKey = "<sshPublicKey>",
};
Response response = await client.CreateNodeUserAsync("<poolId>", "<nodeId>", user, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateNodeUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateNodeUserAsync (string poolId, string nodeId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateNodeUserAsync(string poolId, string nodeId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateNodeUserAsync(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNodeUserAsync (poolId As String, nodeId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateNodeUserAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateNodeUserAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateNodeUserAsync (poolId, nodeId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Adds a user Account to the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateNodeUserAsync(System.String,System.String,Azure.Compute.Batch.BatchNodeUserCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateNodeUserAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    name = "<name>",
});
Response response = await client.CreateNodeUserAsync("<poolId>", "<nodeId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateNodeUserAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    name = "<name>",
    isAdmin = true,
    expiryTime = "2022-05-10T18:57:31.2311892Z",
    password = "<password>",
    sshPublicKey = "<sshPublicKey>",
});
Response response = await client.CreateNodeUserAsync("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreatePool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreatePool (Azure.Compute.Batch.BatchPoolCreateContent pool, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreatePool(class Azure.Compute.Batch.BatchPoolCreateContent pool, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreatePool(Azure.Compute.Batch.BatchPoolCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreatePool (pool As BatchPoolCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreatePool : Azure.Compute.Batch.BatchPoolCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.CreatePool : Azure.Compute.Batch.BatchPoolCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.CreatePool (pool, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pool" Type="Azure.Compute.Batch.BatchPoolCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="pool"> The Pool to be created. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Creates a Pool to the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>
            When naming Pools, avoid including sensitive information such as user names or
            secret project names. This information may appear in telemetry logs accessible
            to Microsoft Support engineers.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pool" /> is null. </exception>
        <example>
This sample shows how to call CreatePool.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolCreateContent pool = new BatchPoolCreateContent("<id>", "<vmSize>");
Response response = client.CreatePool(pool);
]]></code>
This sample shows how to call CreatePool with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolCreateContent pool = new BatchPoolCreateContent("<id>", "<vmSize>")
{
    DisplayName = "<displayName>",
    VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
    {
        Publisher = "<publisher>",
        Offer = "<offer>",
        Sku = "<sku>",
        Version = "<version>",
        VirtualMachineImageId = "<virtualMachineImageId>",
    }, "<nodeAgentSKUId>")
    {
        WindowsConfiguration = new WindowsConfiguration
        {
            EnableAutomaticUpdates = true,
        },
        DataDisks = {new DataDisk(1234, 1234)
        {
            Caching = CachingType.None,
            StorageAccountType = StorageAccountType.StandardLRS,
        }},
        LicenseType = "<licenseType>",
        ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
        {
            ContainerImageNames = { "<containerImageNames>" },
            ContainerRegistries = {new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            }},
        },
        DiskEncryptionConfiguration = new DiskEncryptionConfiguration
        {
            Targets = { DiskEncryptionTarget.OsDisk },
        },
        NodePlacementConfiguration = new BatchNodePlacementConfiguration
        {
            Policy = BatchNodePlacementPolicyType.Regional,
        },
        Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
        {
            TypeHandlerVersion = "<typeHandlerVersion>",
            AutoUpgradeMinorVersion = true,
            EnableAutomaticUpgrade = true,
            Settings =
            {
                ["key"] = "<settings>"
            },
            ProtectedSettings =
            {
                ["key"] = "<protectedSettings>"
            },
            ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
        }},
        OsDisk = new OSDisk
        {
            EphemeralOSDiskSettings = new DiffDiskSettings
            {
                Placement = DiffDiskPlacement.CacheDisk,
            },
            Caching = CachingType.None,
            DiskSizeGB = 1234,
            ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
            WriteAcceleratorEnabled = true,
        },
        SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
        {
            SecureBootEnabled = true,
            VTpmEnabled = true,
        }),
        ServiceArtifactReference = new ServiceArtifactReference("<id>"),
    },
    ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
    ResourceTags =
    {
        ["key"] = "<resourceTags>"
    },
    TargetDedicatedNodes = 1234,
    TargetLowPriorityNodes = 1234,
    EnableAutoScale = true,
    AutoScaleFormula = "<autoScaleFormula>",
    AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
    EnableInterNodeCommunication = true,
    NetworkConfiguration = new NetworkConfiguration
    {
        SubnetId = "<subnetId>",
        DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
        EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
        {
            new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
            {
                NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                {
                    SourcePortRanges = {"<sourcePortRanges>"},
                }},
            }
        }),
        PublicIpAddressConfiguration = new PublicIpAddressConfiguration
        {
            IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
            IpAddressIds = { "<ipAddressIds>" },
        },
        EnableAcceleratedNetworking = true,
    },
    StartTask = new BatchStartTask("<commandLine>")
    {
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = default,
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        MaxTaskRetryCount = 1234,
        WaitForSuccess = true,
    },
    ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
    {
        Version = "<version>",
    }},
    TaskSlotsPerNode = 1234,
    TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
    UserAccounts = {new UserAccount("<name>", "<password>")
    {
        ElevationLevel = ElevationLevel.NonAdmin,
        LinuxUserConfiguration = new LinuxUserConfiguration
        {
            Uid = 1234,
            Gid = 1234,
            SshPrivateKey = "<sshPrivateKey>",
        },
        WindowsUserConfiguration = new WindowsUserConfiguration
        {
            LoginMode = LoginMode.Batch,
        },
    }},
    Metadata = { new MetadataItem("<name>", "<value>") },
    MountConfiguration = {new MountConfiguration
    {
        AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
        {
            AccountKey = "<accountKey>",
            SasKey = "<sasKey>",
            BlobfuseOptions = "<blobfuseOptions>",
            IdentityReference = default,
        },
        NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
        {
            MountOptions = "<mountOptions>",
        },
        CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
        {
            MountOptions = "<mountOptions>",
        },
        AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
        {
            MountOptions = "<mountOptions>",
        },
    }},
    TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
    UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
    {
        AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
        {
            DisableAutomaticRollback = true,
            EnableAutomaticOsUpgrade = true,
            UseRollingUpgradePolicy = true,
            OsRollingUpgradeDeferral = true,
        },
        RollingUpgradePolicy = new RollingUpgradePolicy
        {
            EnableCrossZoneUpgrade = true,
            MaxBatchInstancePercent = 1234,
            MaxUnhealthyInstancePercent = 1234,
            MaxUnhealthyUpgradedInstancePercent = 1234,
            PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
            PrioritizeUnhealthyInstances = true,
            RollbackFailedInstancesOnPolicyBreach = true,
        },
    },
};
Response response = client.CreatePool(pool, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreatePool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreatePool (Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreatePool(class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreatePool(Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreatePool (content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreatePool : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreatePool : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.CreatePool (content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a Pool to the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreatePool(Azure.Compute.Batch.BatchPoolCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreatePool.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    vmSize = "<vmSize>",
});
Response response = client.CreatePool(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreatePool with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    displayName = "<displayName>",
    vmSize = "<vmSize>",
    virtualMachineConfiguration = new
    {
        imageReference = new
        {
            publisher = "<publisher>",
            offer = "<offer>",
            sku = "<sku>",
            version = "<version>",
            virtualMachineImageId = "<virtualMachineImageId>",
        },
        nodeAgentSKUId = "<nodeAgentSKUId>",
        windowsConfiguration = new
        {
            enableAutomaticUpdates = true,
        },
        dataDisks = new object[]
        {
            new
            {
                lun = 1234,
                caching = "none",
                diskSizeGB = 1234,
                storageAccountType = "standard_lrs",
            }
        },
        licenseType = "<licenseType>",
        containerConfiguration = new
        {
            type = "dockerCompatible",
            containerImageNames = new object[]
            {
                "<containerImageNames>"
            },
            containerRegistries = new object[]
            {
                new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                }
            },
        },
        diskEncryptionConfiguration = new
        {
            targets = new object[]
            {
                "osdisk"
            },
        },
        nodePlacementConfiguration = new
        {
            policy = "regional",
        },
        extensions = new object[]
        {
            new
            {
                name = "<name>",
                publisher = "<publisher>",
                type = "<type>",
                typeHandlerVersion = "<typeHandlerVersion>",
                autoUpgradeMinorVersion = true,
                enableAutomaticUpgrade = true,
                settings = new
                {
                    key = "<settings>",
                },
                protectedSettings = new
                {
                    key = "<protectedSettings>",
                },
                provisionAfterExtensions = new object[]
                {
                    "<provisionAfterExtensions>"
                },
            }
        },
        osDisk = new
        {
            ephemeralOSDiskSettings = new
            {
                placement = "cachedisk",
            },
            caching = "none",
            diskSizeGB = 1234,
            managedDisk = new
            {
                storageAccountType = "standard_lrs",
            },
            writeAcceleratorEnabled = true,
        },
        securityProfile = new
        {
            encryptionAtHost = true,
            securityType = "trustedLaunch",
            uefiSettings = new
            {
                secureBootEnabled = true,
                vTpmEnabled = true,
            },
        },
        serviceArtifactReference = new
        {
            id = "<id>",
        },
    },
    resizeTimeout = "PT1H23M45S",
    resourceTags = new
    {
        key = "<resourceTags>",
    },
    targetDedicatedNodes = 1234,
    targetLowPriorityNodes = 1234,
    enableAutoScale = true,
    autoScaleFormula = "<autoScaleFormula>",
    autoScaleEvaluationInterval = "PT1H23M45S",
    enableInterNodeCommunication = true,
    networkConfiguration = new
    {
        subnetId = "<subnetId>",
        dynamicVNetAssignmentScope = "none",
        endpointConfiguration = new
        {
            inboundNATPools = new object[]
            {
                new
                {
                    name = "<name>",
                    protocol = "tcp",
                    backendPort = 1234,
                    frontendPortRangeStart = 1234,
                    frontendPortRangeEnd = 1234,
                    networkSecurityGroupRules = new object[]
                    {
                        new
                        {
                            priority = 1234,
                            access = "allow",
                            sourceAddressPrefix = "<sourceAddressPrefix>",
                            sourcePortRanges = new object[]
                            {
                                "<sourcePortRanges>"
                            },
                        }
                    },
                }
            },
        },
        publicIPAddressConfiguration = new
        {
            provision = "batchmanaged",
            ipAddressIds = new object[]
            {
                "<ipAddressIds>"
            },
        },
        enableAcceleratedNetworking = true,
    },
    startTask = new
    {
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        maxTaskRetryCount = 1234,
        waitForSuccess = true,
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    taskSlotsPerNode = 1234,
    taskSchedulingPolicy = new
    {
        nodeFillType = "spread",
    },
    userAccounts = new object[]
    {
        new
        {
            name = "<name>",
            password = "<password>",
            elevationLevel = "nonadmin",
            linuxUserConfiguration = new
            {
                uid = 1234,
                gid = 1234,
                sshPrivateKey = "<sshPrivateKey>",
            },
            windowsUserConfiguration = new
            {
                loginMode = "batch",
            },
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    mountConfiguration = new object[]
    {
        new
        {
            azureBlobFileSystemConfiguration = new
            {
                accountName = "<accountName>",
                containerName = "<containerName>",
                accountKey = "<accountKey>",
                sasKey = "<sasKey>",
                blobfuseOptions = "<blobfuseOptions>",
                relativeMountPath = "<relativeMountPath>",
            },
            nfsMountConfiguration = new
            {
                source = "<source>",
                relativeMountPath = "<relativeMountPath>",
                mountOptions = "<mountOptions>",
            },
            cifsMountConfiguration = new
            {
                username = "<username>",
                source = "<source>",
                relativeMountPath = "<relativeMountPath>",
                mountOptions = "<mountOptions>",
                password = "<password>",
            },
            azureFileShareConfiguration = new
            {
                accountName = "<accountName>",
                azureFileUrl = "<azureFileUrl>",
                accountKey = "<accountKey>",
                relativeMountPath = "<relativeMountPath>",
                mountOptions = "<mountOptions>",
            },
        }
    },
    targetNodeCommunicationMode = "default",
    upgradePolicy = new
    {
        mode = "automatic",
        automaticOSUpgradePolicy = new
        {
            disableAutomaticRollback = true,
            enableAutomaticOSUpgrade = true,
            useRollingUpgradePolicy = true,
            osRollingUpgradeDeferral = true,
        },
        rollingUpgradePolicy = new
        {
            enableCrossZoneUpgrade = true,
            maxBatchInstancePercent = 1234,
            maxUnhealthyInstancePercent = 1234,
            maxUnhealthyUpgradedInstancePercent = 1234,
            pauseTimeBetweenBatches = "PT1H23M45S",
            prioritizeUnhealthyInstances = true,
            rollbackFailedInstancesOnPolicyBreach = true,
        },
    },
});
Response response = client.CreatePool(content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreatePoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreatePoolAsync (Azure.Compute.Batch.BatchPoolCreateContent pool, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreatePoolAsync(class Azure.Compute.Batch.BatchPoolCreateContent pool, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreatePoolAsync(Azure.Compute.Batch.BatchPoolCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreatePoolAsync (pool As BatchPoolCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreatePoolAsync : Azure.Compute.Batch.BatchPoolCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreatePoolAsync : Azure.Compute.Batch.BatchPoolCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreatePoolAsync (pool, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pool" Type="Azure.Compute.Batch.BatchPoolCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="pool"> The Pool to be created. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Creates a Pool to the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>
            When naming Pools, avoid including sensitive information such as user names or
            secret project names. This information may appear in telemetry logs accessible
            to Microsoft Support engineers.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pool" /> is null. </exception>
        <example>
This sample shows how to call CreatePoolAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolCreateContent pool = new BatchPoolCreateContent("<id>", "<vmSize>");
Response response = await client.CreatePoolAsync(pool);
]]></code>
This sample shows how to call CreatePoolAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolCreateContent pool = new BatchPoolCreateContent("<id>", "<vmSize>")
{
    DisplayName = "<displayName>",
    VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
    {
        Publisher = "<publisher>",
        Offer = "<offer>",
        Sku = "<sku>",
        Version = "<version>",
        VirtualMachineImageId = "<virtualMachineImageId>",
    }, "<nodeAgentSKUId>")
    {
        WindowsConfiguration = new WindowsConfiguration
        {
            EnableAutomaticUpdates = true,
        },
        DataDisks = {new DataDisk(1234, 1234)
        {
            Caching = CachingType.None,
            StorageAccountType = StorageAccountType.StandardLRS,
        }},
        LicenseType = "<licenseType>",
        ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
        {
            ContainerImageNames = { "<containerImageNames>" },
            ContainerRegistries = {new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            }},
        },
        DiskEncryptionConfiguration = new DiskEncryptionConfiguration
        {
            Targets = { DiskEncryptionTarget.OsDisk },
        },
        NodePlacementConfiguration = new BatchNodePlacementConfiguration
        {
            Policy = BatchNodePlacementPolicyType.Regional,
        },
        Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
        {
            TypeHandlerVersion = "<typeHandlerVersion>",
            AutoUpgradeMinorVersion = true,
            EnableAutomaticUpgrade = true,
            Settings =
            {
                ["key"] = "<settings>"
            },
            ProtectedSettings =
            {
                ["key"] = "<protectedSettings>"
            },
            ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
        }},
        OsDisk = new OSDisk
        {
            EphemeralOSDiskSettings = new DiffDiskSettings
            {
                Placement = DiffDiskPlacement.CacheDisk,
            },
            Caching = CachingType.None,
            DiskSizeGB = 1234,
            ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
            WriteAcceleratorEnabled = true,
        },
        SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
        {
            SecureBootEnabled = true,
            VTpmEnabled = true,
        }),
        ServiceArtifactReference = new ServiceArtifactReference("<id>"),
    },
    ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
    ResourceTags =
    {
        ["key"] = "<resourceTags>"
    },
    TargetDedicatedNodes = 1234,
    TargetLowPriorityNodes = 1234,
    EnableAutoScale = true,
    AutoScaleFormula = "<autoScaleFormula>",
    AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
    EnableInterNodeCommunication = true,
    NetworkConfiguration = new NetworkConfiguration
    {
        SubnetId = "<subnetId>",
        DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
        EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
        {
            new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
            {
                NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                {
                    SourcePortRanges = {"<sourcePortRanges>"},
                }},
            }
        }),
        PublicIpAddressConfiguration = new PublicIpAddressConfiguration
        {
            IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
            IpAddressIds = { "<ipAddressIds>" },
        },
        EnableAcceleratedNetworking = true,
    },
    StartTask = new BatchStartTask("<commandLine>")
    {
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = default,
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        MaxTaskRetryCount = 1234,
        WaitForSuccess = true,
    },
    ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
    {
        Version = "<version>",
    }},
    TaskSlotsPerNode = 1234,
    TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
    UserAccounts = {new UserAccount("<name>", "<password>")
    {
        ElevationLevel = ElevationLevel.NonAdmin,
        LinuxUserConfiguration = new LinuxUserConfiguration
        {
            Uid = 1234,
            Gid = 1234,
            SshPrivateKey = "<sshPrivateKey>",
        },
        WindowsUserConfiguration = new WindowsUserConfiguration
        {
            LoginMode = LoginMode.Batch,
        },
    }},
    Metadata = { new MetadataItem("<name>", "<value>") },
    MountConfiguration = {new MountConfiguration
    {
        AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
        {
            AccountKey = "<accountKey>",
            SasKey = "<sasKey>",
            BlobfuseOptions = "<blobfuseOptions>",
            IdentityReference = default,
        },
        NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
        {
            MountOptions = "<mountOptions>",
        },
        CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
        {
            MountOptions = "<mountOptions>",
        },
        AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
        {
            MountOptions = "<mountOptions>",
        },
    }},
    TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
    UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
    {
        AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
        {
            DisableAutomaticRollback = true,
            EnableAutomaticOsUpgrade = true,
            UseRollingUpgradePolicy = true,
            OsRollingUpgradeDeferral = true,
        },
        RollingUpgradePolicy = new RollingUpgradePolicy
        {
            EnableCrossZoneUpgrade = true,
            MaxBatchInstancePercent = 1234,
            MaxUnhealthyInstancePercent = 1234,
            MaxUnhealthyUpgradedInstancePercent = 1234,
            PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
            PrioritizeUnhealthyInstances = true,
            RollbackFailedInstancesOnPolicyBreach = true,
        },
    },
};
Response response = await client.CreatePoolAsync(pool, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreatePoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreatePoolAsync (Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreatePoolAsync(class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreatePoolAsync(Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreatePoolAsync (content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreatePoolAsync : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreatePoolAsync : Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreatePoolAsync (content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a Pool to the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreatePoolAsync(Azure.Compute.Batch.BatchPoolCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreatePoolAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    vmSize = "<vmSize>",
});
Response response = await client.CreatePoolAsync(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreatePoolAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    displayName = "<displayName>",
    vmSize = "<vmSize>",
    virtualMachineConfiguration = new
    {
        imageReference = new
        {
            publisher = "<publisher>",
            offer = "<offer>",
            sku = "<sku>",
            version = "<version>",
            virtualMachineImageId = "<virtualMachineImageId>",
        },
        nodeAgentSKUId = "<nodeAgentSKUId>",
        windowsConfiguration = new
        {
            enableAutomaticUpdates = true,
        },
        dataDisks = new object[]
        {
            new
            {
                lun = 1234,
                caching = "none",
                diskSizeGB = 1234,
                storageAccountType = "standard_lrs",
            }
        },
        licenseType = "<licenseType>",
        containerConfiguration = new
        {
            type = "dockerCompatible",
            containerImageNames = new object[]
            {
                "<containerImageNames>"
            },
            containerRegistries = new object[]
            {
                new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                }
            },
        },
        diskEncryptionConfiguration = new
        {
            targets = new object[]
            {
                "osdisk"
            },
        },
        nodePlacementConfiguration = new
        {
            policy = "regional",
        },
        extensions = new object[]
        {
            new
            {
                name = "<name>",
                publisher = "<publisher>",
                type = "<type>",
                typeHandlerVersion = "<typeHandlerVersion>",
                autoUpgradeMinorVersion = true,
                enableAutomaticUpgrade = true,
                settings = new
                {
                    key = "<settings>",
                },
                protectedSettings = new
                {
                    key = "<protectedSettings>",
                },
                provisionAfterExtensions = new object[]
                {
                    "<provisionAfterExtensions>"
                },
            }
        },
        osDisk = new
        {
            ephemeralOSDiskSettings = new
            {
                placement = "cachedisk",
            },
            caching = "none",
            diskSizeGB = 1234,
            managedDisk = new
            {
                storageAccountType = "standard_lrs",
            },
            writeAcceleratorEnabled = true,
        },
        securityProfile = new
        {
            encryptionAtHost = true,
            securityType = "trustedLaunch",
            uefiSettings = new
            {
                secureBootEnabled = true,
                vTpmEnabled = true,
            },
        },
        serviceArtifactReference = new
        {
            id = "<id>",
        },
    },
    resizeTimeout = "PT1H23M45S",
    resourceTags = new
    {
        key = "<resourceTags>",
    },
    targetDedicatedNodes = 1234,
    targetLowPriorityNodes = 1234,
    enableAutoScale = true,
    autoScaleFormula = "<autoScaleFormula>",
    autoScaleEvaluationInterval = "PT1H23M45S",
    enableInterNodeCommunication = true,
    networkConfiguration = new
    {
        subnetId = "<subnetId>",
        dynamicVNetAssignmentScope = "none",
        endpointConfiguration = new
        {
            inboundNATPools = new object[]
            {
                new
                {
                    name = "<name>",
                    protocol = "tcp",
                    backendPort = 1234,
                    frontendPortRangeStart = 1234,
                    frontendPortRangeEnd = 1234,
                    networkSecurityGroupRules = new object[]
                    {
                        new
                        {
                            priority = 1234,
                            access = "allow",
                            sourceAddressPrefix = "<sourceAddressPrefix>",
                            sourcePortRanges = new object[]
                            {
                                "<sourcePortRanges>"
                            },
                        }
                    },
                }
            },
        },
        publicIPAddressConfiguration = new
        {
            provision = "batchmanaged",
            ipAddressIds = new object[]
            {
                "<ipAddressIds>"
            },
        },
        enableAcceleratedNetworking = true,
    },
    startTask = new
    {
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        maxTaskRetryCount = 1234,
        waitForSuccess = true,
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    taskSlotsPerNode = 1234,
    taskSchedulingPolicy = new
    {
        nodeFillType = "spread",
    },
    userAccounts = new object[]
    {
        new
        {
            name = "<name>",
            password = "<password>",
            elevationLevel = "nonadmin",
            linuxUserConfiguration = new
            {
                uid = 1234,
                gid = 1234,
                sshPrivateKey = "<sshPrivateKey>",
            },
            windowsUserConfiguration = new
            {
                loginMode = "batch",
            },
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    mountConfiguration = new object[]
    {
        new
        {
            azureBlobFileSystemConfiguration = new
            {
                accountName = "<accountName>",
                containerName = "<containerName>",
                accountKey = "<accountKey>",
                sasKey = "<sasKey>",
                blobfuseOptions = "<blobfuseOptions>",
                relativeMountPath = "<relativeMountPath>",
            },
            nfsMountConfiguration = new
            {
                source = "<source>",
                relativeMountPath = "<relativeMountPath>",
                mountOptions = "<mountOptions>",
            },
            cifsMountConfiguration = new
            {
                username = "<username>",
                source = "<source>",
                relativeMountPath = "<relativeMountPath>",
                mountOptions = "<mountOptions>",
                password = "<password>",
            },
            azureFileShareConfiguration = new
            {
                accountName = "<accountName>",
                azureFileUrl = "<azureFileUrl>",
                accountKey = "<accountKey>",
                relativeMountPath = "<relativeMountPath>",
                mountOptions = "<mountOptions>",
            },
        }
    },
    targetNodeCommunicationMode = "default",
    upgradePolicy = new
    {
        mode = "automatic",
        automaticOSUpgradePolicy = new
        {
            disableAutomaticRollback = true,
            enableAutomaticOSUpgrade = true,
            useRollingUpgradePolicy = true,
            osRollingUpgradeDeferral = true,
        },
        rollingUpgradePolicy = new
        {
            enableCrossZoneUpgrade = true,
            maxBatchInstancePercent = 1234,
            maxUnhealthyInstancePercent = 1234,
            maxUnhealthyUpgradedInstancePercent = 1234,
            pauseTimeBetweenBatches = "PT1H23M45S",
            prioritizeUnhealthyInstances = true,
            rollbackFailedInstancesOnPolicyBreach = true,
        },
    },
});
Response response = await client.CreatePoolAsync(content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateTask (string jobId, Azure.Compute.Batch.BatchTaskCreateContent task, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateTask(string jobId, class Azure.Compute.Batch.BatchTaskCreateContent task, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateTask(System.String,Azure.Compute.Batch.BatchTaskCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTask (jobId As String, task As BatchTaskCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateTask : string * Azure.Compute.Batch.BatchTaskCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.CreateTask : string * Azure.Compute.Batch.BatchTaskCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.CreateTask (jobId, task, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="task" Type="Azure.Compute.Batch.BatchTaskCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to which the Task is to be created. </param>
        <param name="task"> The Task to be created. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Creates a Task to the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            The maximum lifetime of a Task from addition to completion is 180 days. If a
            Task has not completed within 180 days of being added it will be terminated by
            the Batch service and left in whatever state it was in at that time.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="task" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call CreateTask.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTaskCreateContent task = new BatchTaskCreateContent("<id>", "<commandLine>");
Response response = client.CreateTask("<jobId>", task);
]]></code>
This sample shows how to call CreateTask with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTaskCreateContent task = new BatchTaskCreateContent("<id>", "<commandLine>")
{
    DisplayName = "<displayName>",
    ExitConditions = new ExitConditions
    {
        ExitCodes = {new ExitCodeMapping(1234, new ExitOptions
        {
            JobAction = BatchJobAction.None,
            DependencyAction = DependencyAction.Satisfy,
        })},
        ExitCodeRanges = { new ExitCodeRangeMapping(1234, 1234, default) },
        PreProcessingError = default,
        FileUploadError = default,
        Default = default,
    },
    ContainerSettings = new BatchTaskContainerSettings("<imageName>")
    {
        ContainerRunOptions = "<containerRunOptions>",
        Registry = new ContainerRegistryReference
        {
            Username = "<username>",
            Password = "<password>",
            RegistryServer = "<registryServer>",
            IdentityReference = new BatchNodeIdentityReference
            {
                ResourceId = "<resourceId>",
            },
        },
        WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
    },
    ResourceFiles = {new ResourceFile
    {
        AutoStorageContainerName = "<autoStorageContainerName>",
        StorageContainerUrl = "<storageContainerUrl>",
        HttpUrl = "<httpUrl>",
        BlobPrefix = "<blobPrefix>",
        FilePath = "<filePath>",
        FileMode = "<fileMode>",
        IdentityReference = default,
    }},
    OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
    {
        Container = new OutputFileBlobContainerDestination("<containerUrl>")
        {
            Path = "<path>",
            IdentityReference = default,
            UploadHeaders = {new HttpHeader("<name>")
            {
                Value = "<value>",
            }},
        },
    }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
    EnvironmentSettings = {new EnvironmentSetting("<name>")
    {
        Value = "<value>",
    }},
    AffinityInfo = new AffinityInfo("<affinityId>"),
    Constraints = new BatchTaskConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    RequiredSlots = 1234,
    UserIdentity = new UserIdentity
    {
        Username = "<username>",
        AutoUser = new AutoUserSpecification
        {
            Scope = AutoUserScope.Task,
            ElevationLevel = ElevationLevel.NonAdmin,
        },
    },
    MultiInstanceSettings = new MultiInstanceSettings("<coordinationCommandLine>")
    {
        NumberOfInstances = 1234,
        CommonResourceFiles = { default },
    },
    DependsOn = new BatchTaskDependencies
    {
        TaskIds = { "<taskIds>" },
        TaskIdRanges = { new BatchTaskIdRange(1234, 1234) },
    },
    ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
    {
        Version = "<version>",
    }},
    AuthenticationTokenSettings = new AuthenticationTokenSettings
    {
        Access = { AccessScope.Job },
    },
};
Response response = client.CreateTask("<jobId>", task, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateTask (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateTask(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateTask(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTask (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateTask : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateTask : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.CreateTask (jobId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to which the Task is to be created. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a Task to the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateTask(System.String,Azure.Compute.Batch.BatchTaskCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateTask.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    commandLine = "<commandLine>",
});
Response response = client.CreateTask("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateTask with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    displayName = "<displayName>",
    exitConditions = new Dictionary<string, object>
    {
        ["exitCodes"] = new object[]
        {
            new
            {
                code = 1234,
                exitOptions = new
                {
                    jobAction = "none",
                    dependencyAction = "satisfy",
                },
            }
        },
        ["exitCodeRanges"] = new object[]
        {
            new
            {
                start = 1234,
                end = 1234,
            }
        },
        ["preProcessingError"] = null,
        ["fileUploadError"] = null,
        ["default"] = null
    },
    commandLine = "<commandLine>",
    containerSettings = new
    {
        containerRunOptions = "<containerRunOptions>",
        imageName = "<imageName>",
        registry = new
        {
            username = "<username>",
            password = "<password>",
            registryServer = "<registryServer>",
            identityReference = new
            {
                resourceId = "<resourceId>",
            },
        },
        workingDirectory = "taskWorkingDirectory",
    },
    resourceFiles = new object[]
    {
        new
        {
            autoStorageContainerName = "<autoStorageContainerName>",
            storageContainerUrl = "<storageContainerUrl>",
            httpUrl = "<httpUrl>",
            blobPrefix = "<blobPrefix>",
            filePath = "<filePath>",
            fileMode = "<fileMode>",
        }
    },
    outputFiles = new object[]
    {
        new
        {
            filePattern = "<filePattern>",
            destination = new
            {
                container = new
                {
                    path = "<path>",
                    containerUrl = "<containerUrl>",
                    uploadHeaders = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                },
            },
            uploadOptions = new
            {
                uploadCondition = "tasksuccess",
            },
        }
    },
    environmentSettings = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    affinityInfo = new
    {
        affinityId = "<affinityId>",
    },
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        retentionTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    requiredSlots = 1234,
    userIdentity = new
    {
        username = "<username>",
        autoUser = new
        {
            scope = "task",
            elevationLevel = "nonadmin",
        },
    },
    multiInstanceSettings = new
    {
        numberOfInstances = 1234,
        coordinationCommandLine = "<coordinationCommandLine>",
        commonResourceFiles = new object[]
        {
            null
        },
    },
    dependsOn = new
    {
        taskIds = new object[]
        {
            "<taskIds>"
        },
        taskIdRanges = new object[]
        {
            new
            {
                start = 1234,
                end = 1234,
            }
        },
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    authenticationTokenSettings = new
    {
        access = new object[]
        {
            "job"
        },
    },
});
Response response = client.CreateTask("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateTaskAsync (string jobId, Azure.Compute.Batch.BatchTaskCreateContent task, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateTaskAsync(string jobId, class Azure.Compute.Batch.BatchTaskCreateContent task, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateTaskAsync(System.String,Azure.Compute.Batch.BatchTaskCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTaskAsync (jobId As String, task As BatchTaskCreateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateTaskAsync : string * Azure.Compute.Batch.BatchTaskCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateTaskAsync : string * Azure.Compute.Batch.BatchTaskCreateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateTaskAsync (jobId, task, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="task" Type="Azure.Compute.Batch.BatchTaskCreateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to which the Task is to be created. </param>
        <param name="task"> The Task to be created. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Creates a Task to the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            The maximum lifetime of a Task from addition to completion is 180 days. If a
            Task has not completed within 180 days of being added it will be terminated by
            the Batch service and left in whatever state it was in at that time.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="task" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call CreateTaskAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTaskCreateContent task = new BatchTaskCreateContent("<id>", "<commandLine>");
Response response = await client.CreateTaskAsync("<jobId>", task);
]]></code>
This sample shows how to call CreateTaskAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTaskCreateContent task = new BatchTaskCreateContent("<id>", "<commandLine>")
{
    DisplayName = "<displayName>",
    ExitConditions = new ExitConditions
    {
        ExitCodes = {new ExitCodeMapping(1234, new ExitOptions
        {
            JobAction = BatchJobAction.None,
            DependencyAction = DependencyAction.Satisfy,
        })},
        ExitCodeRanges = { new ExitCodeRangeMapping(1234, 1234, default) },
        PreProcessingError = default,
        FileUploadError = default,
        Default = default,
    },
    ContainerSettings = new BatchTaskContainerSettings("<imageName>")
    {
        ContainerRunOptions = "<containerRunOptions>",
        Registry = new ContainerRegistryReference
        {
            Username = "<username>",
            Password = "<password>",
            RegistryServer = "<registryServer>",
            IdentityReference = new BatchNodeIdentityReference
            {
                ResourceId = "<resourceId>",
            },
        },
        WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
    },
    ResourceFiles = {new ResourceFile
    {
        AutoStorageContainerName = "<autoStorageContainerName>",
        StorageContainerUrl = "<storageContainerUrl>",
        HttpUrl = "<httpUrl>",
        BlobPrefix = "<blobPrefix>",
        FilePath = "<filePath>",
        FileMode = "<fileMode>",
        IdentityReference = default,
    }},
    OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
    {
        Container = new OutputFileBlobContainerDestination("<containerUrl>")
        {
            Path = "<path>",
            IdentityReference = default,
            UploadHeaders = {new HttpHeader("<name>")
            {
                Value = "<value>",
            }},
        },
    }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
    EnvironmentSettings = {new EnvironmentSetting("<name>")
    {
        Value = "<value>",
    }},
    AffinityInfo = new AffinityInfo("<affinityId>"),
    Constraints = new BatchTaskConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    RequiredSlots = 1234,
    UserIdentity = new UserIdentity
    {
        Username = "<username>",
        AutoUser = new AutoUserSpecification
        {
            Scope = AutoUserScope.Task,
            ElevationLevel = ElevationLevel.NonAdmin,
        },
    },
    MultiInstanceSettings = new MultiInstanceSettings("<coordinationCommandLine>")
    {
        NumberOfInstances = 1234,
        CommonResourceFiles = { default },
    },
    DependsOn = new BatchTaskDependencies
    {
        TaskIds = { "<taskIds>" },
        TaskIdRanges = { new BatchTaskIdRange(1234, 1234) },
    },
    ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
    {
        Version = "<version>",
    }},
    AuthenticationTokenSettings = new AuthenticationTokenSettings
    {
        Access = { AccessScope.Job },
    },
};
Response response = await client.CreateTaskAsync("<jobId>", task, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateTaskAsync (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateTaskAsync(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateTaskAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTaskAsync (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateTaskAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateTaskAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateTaskAsync (jobId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to which the Task is to be created. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a Task to the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateTaskAsync(System.String,Azure.Compute.Batch.BatchTaskCreateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateTaskAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    commandLine = "<commandLine>",
});
Response response = await client.CreateTaskAsync("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateTaskAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    id = "<id>",
    displayName = "<displayName>",
    exitConditions = new Dictionary<string, object>
    {
        ["exitCodes"] = new object[]
        {
            new
            {
                code = 1234,
                exitOptions = new
                {
                    jobAction = "none",
                    dependencyAction = "satisfy",
                },
            }
        },
        ["exitCodeRanges"] = new object[]
        {
            new
            {
                start = 1234,
                end = 1234,
            }
        },
        ["preProcessingError"] = null,
        ["fileUploadError"] = null,
        ["default"] = null
    },
    commandLine = "<commandLine>",
    containerSettings = new
    {
        containerRunOptions = "<containerRunOptions>",
        imageName = "<imageName>",
        registry = new
        {
            username = "<username>",
            password = "<password>",
            registryServer = "<registryServer>",
            identityReference = new
            {
                resourceId = "<resourceId>",
            },
        },
        workingDirectory = "taskWorkingDirectory",
    },
    resourceFiles = new object[]
    {
        new
        {
            autoStorageContainerName = "<autoStorageContainerName>",
            storageContainerUrl = "<storageContainerUrl>",
            httpUrl = "<httpUrl>",
            blobPrefix = "<blobPrefix>",
            filePath = "<filePath>",
            fileMode = "<fileMode>",
        }
    },
    outputFiles = new object[]
    {
        new
        {
            filePattern = "<filePattern>",
            destination = new
            {
                container = new
                {
                    path = "<path>",
                    containerUrl = "<containerUrl>",
                    uploadHeaders = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                },
            },
            uploadOptions = new
            {
                uploadCondition = "tasksuccess",
            },
        }
    },
    environmentSettings = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    affinityInfo = new
    {
        affinityId = "<affinityId>",
    },
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        retentionTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    requiredSlots = 1234,
    userIdentity = new
    {
        username = "<username>",
        autoUser = new
        {
            scope = "task",
            elevationLevel = "nonadmin",
        },
    },
    multiInstanceSettings = new
    {
        numberOfInstances = 1234,
        coordinationCommandLine = "<coordinationCommandLine>",
        commonResourceFiles = new object[]
        {
            null
        },
    },
    dependsOn = new
    {
        taskIds = new object[]
        {
            "<taskIds>"
        },
        taskIdRanges = new object[]
        {
            new
            {
                start = 1234,
                end = 1234,
            }
        },
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    authenticationTokenSettings = new
    {
        access = new object[]
        {
            "job"
        },
    },
});
Response response = await client.CreateTaskAsync("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateTaskCollection">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchTaskAddCollectionResult&gt; CreateTaskCollection (string jobId, Azure.Compute.Batch.BatchTaskGroup taskCollection, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchTaskAddCollectionResult&gt; CreateTaskCollection(string jobId, class Azure.Compute.Batch.BatchTaskGroup taskCollection, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateTaskCollection(System.String,Azure.Compute.Batch.BatchTaskGroup,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTaskCollection (jobId As String, taskCollection As BatchTaskGroup, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchTaskAddCollectionResult)" />
      <MemberSignature Language="F#" Value="abstract member CreateTaskCollection : string * Azure.Compute.Batch.BatchTaskGroup * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchTaskAddCollectionResult&gt;&#xA;override this.CreateTaskCollection : string * Azure.Compute.Batch.BatchTaskGroup * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchTaskAddCollectionResult&gt;" Usage="batchClient.CreateTaskCollection (jobId, taskCollection, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchTaskAddCollectionResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskCollection" Type="Azure.Compute.Batch.BatchTaskGroup" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        <param name="taskCollection"> The Tasks to be added. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Adds a collection of Tasks to the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            Note that each Task must have a unique ID. The Batch service may not return the
            results for each Task in the same order the Tasks were submitted in this
            request. If the server times out or the connection is closed during the
            request, the request may have been partially or fully processed, or not at all.
            In such cases, the user should re-issue the request. Note that it is up to the
            user to correctly handle failures when re-issuing a request. For example, you
            should use the same Task IDs during a retry so that if the prior operation
            succeeded, the retry will not create extra Tasks unexpectedly. If the response
            contains any Tasks which failed to add, a client can retry the request. In a
            retry, it is most efficient to resubmit only Tasks that failed to add, and to
            omit Tasks that were successfully added on the first attempt. The maximum
            lifetime of a Task from addition to completion is 180 days. If a Task has not
            completed within 180 days of being added it will be terminated by the Batch
            service and left in whatever state it was in at that time.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskCollection" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call CreateTaskCollection.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTaskGroup taskCollection = new BatchTaskGroup(new BatchTaskCreateContent[]
{
    new BatchTaskCreateContent("<id>", "<commandLine>")
});
Response<BatchTaskAddCollectionResult> response = client.CreateTaskCollection("<jobId>", taskCollection);
]]></code>
This sample shows how to call CreateTaskCollection with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTaskGroup taskCollection = new BatchTaskGroup(new BatchTaskCreateContent[]
{
    new BatchTaskCreateContent("<id>", "<commandLine>")
    {
        DisplayName = "<displayName>",
        ExitConditions = new ExitConditions
        {
            ExitCodes = {new ExitCodeMapping(1234, new ExitOptions
            {
                JobAction = BatchJobAction.None,
                DependencyAction = DependencyAction.Satisfy,
            })},
            ExitCodeRanges = {new ExitCodeRangeMapping(1234, 1234, default)},
            PreProcessingError = default,
            FileUploadError = default,
            Default = default,
        },
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
        {
            Container = new OutputFileBlobContainerDestination("<containerUrl>")
            {
                Path = "<path>",
                IdentityReference = default,
                UploadHeaders = {new HttpHeader("<name>")
                {
                    Value = "<value>",
                }},
            },
        }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        AffinityInfo = new AffinityInfo("<affinityId>"),
        Constraints = new BatchTaskConstraints
        {
            MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            MaxTaskRetryCount = 1234,
        },
        RequiredSlots = 1234,
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        MultiInstanceSettings = new MultiInstanceSettings("<coordinationCommandLine>")
        {
            NumberOfInstances = 1234,
            CommonResourceFiles = {default},
        },
        DependsOn = new BatchTaskDependencies
        {
            TaskIds = {"<taskIds>"},
            TaskIdRanges = {new BatchTaskIdRange(1234, 1234)},
        },
        ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
        {
            Version = "<version>",
        }},
        AuthenticationTokenSettings = new AuthenticationTokenSettings
        {
            Access = {AccessScope.Job},
        },
    }
});
Response<BatchTaskAddCollectionResult> response = client.CreateTaskCollection("<jobId>", taskCollection, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateTaskCollection">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateTaskCollection (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateTaskCollection(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateTaskCollection(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTaskCollection (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateTaskCollection : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateTaskCollection : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.CreateTaskCollection (jobId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Adds a collection of Tasks to the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateTaskCollection(System.String,Azure.Compute.Batch.BatchTaskGroup,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateTaskCollection and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    value = new object[]
    {
        new
        {
            id = "<id>",
            commandLine = "<commandLine>",
        }
    },
});
Response response = client.CreateTaskCollection("<jobId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateTaskCollection with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    value = new object[]
    {
        new
        {
            id = "<id>",
            displayName = "<displayName>",
            exitConditions = new Dictionary<string, object>
            {
                ["exitCodes"] = new object[]
                {
                    new
                    {
                        code = 1234,
                        exitOptions = new
                        {
                            jobAction = "none",
                            dependencyAction = "satisfy",
                        },
                    }
                },
                ["exitCodeRanges"] = new object[]
                {
                    new
                    {
                        start = 1234,
                        end = 1234,
                    }
                },
                ["preProcessingError"] = null,
                ["fileUploadError"] = null,
                ["default"] = null
            },
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            affinityInfo = new
            {
                affinityId = "<affinityId>",
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            multiInstanceSettings = new
            {
                numberOfInstances = 1234,
                coordinationCommandLine = "<coordinationCommandLine>",
                commonResourceFiles = new object[]
                {
                    null
                },
            },
            dependsOn = new
            {
                taskIds = new object[]
                {
                    "<taskIds>"
                },
                taskIdRanges = new object[]
                {
                    new
                    {
                        start = 1234,
                        end = 1234,
                    }
                },
            },
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
        }
    },
});
Response response = client.CreateTaskCollection("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("taskId").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("location").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("message").GetProperty("lang").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("message").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("values")[0].GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("values")[0].GetProperty("value").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateTaskCollectionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTaskAddCollectionResult&gt;&gt; CreateTaskCollectionAsync (string jobId, Azure.Compute.Batch.BatchTaskGroup taskCollection, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchTaskAddCollectionResult&gt;&gt; CreateTaskCollectionAsync(string jobId, class Azure.Compute.Batch.BatchTaskGroup taskCollection, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateTaskCollectionAsync(System.String,Azure.Compute.Batch.BatchTaskGroup,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTaskCollectionAsync (jobId As String, taskCollection As BatchTaskGroup, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchTaskAddCollectionResult))" />
      <MemberSignature Language="F#" Value="abstract member CreateTaskCollectionAsync : string * Azure.Compute.Batch.BatchTaskGroup * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTaskAddCollectionResult&gt;&gt;&#xA;override this.CreateTaskCollectionAsync : string * Azure.Compute.Batch.BatchTaskGroup * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTaskAddCollectionResult&gt;&gt;" Usage="batchClient.CreateTaskCollectionAsync (jobId, taskCollection, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTaskAddCollectionResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskCollection" Type="Azure.Compute.Batch.BatchTaskGroup" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        <param name="taskCollection"> The Tasks to be added. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Adds a collection of Tasks to the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            Note that each Task must have a unique ID. The Batch service may not return the
            results for each Task in the same order the Tasks were submitted in this
            request. If the server times out or the connection is closed during the
            request, the request may have been partially or fully processed, or not at all.
            In such cases, the user should re-issue the request. Note that it is up to the
            user to correctly handle failures when re-issuing a request. For example, you
            should use the same Task IDs during a retry so that if the prior operation
            succeeded, the retry will not create extra Tasks unexpectedly. If the response
            contains any Tasks which failed to add, a client can retry the request. In a
            retry, it is most efficient to resubmit only Tasks that failed to add, and to
            omit Tasks that were successfully added on the first attempt. The maximum
            lifetime of a Task from addition to completion is 180 days. If a Task has not
            completed within 180 days of being added it will be terminated by the Batch
            service and left in whatever state it was in at that time.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskCollection" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call CreateTaskCollectionAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTaskGroup taskCollection = new BatchTaskGroup(new BatchTaskCreateContent[]
{
    new BatchTaskCreateContent("<id>", "<commandLine>")
});
Response<BatchTaskAddCollectionResult> response = await client.CreateTaskCollectionAsync("<jobId>", taskCollection);
]]></code>
This sample shows how to call CreateTaskCollectionAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTaskGroup taskCollection = new BatchTaskGroup(new BatchTaskCreateContent[]
{
    new BatchTaskCreateContent("<id>", "<commandLine>")
    {
        DisplayName = "<displayName>",
        ExitConditions = new ExitConditions
        {
            ExitCodes = {new ExitCodeMapping(1234, new ExitOptions
            {
                JobAction = BatchJobAction.None,
                DependencyAction = DependencyAction.Satisfy,
            })},
            ExitCodeRanges = {new ExitCodeRangeMapping(1234, 1234, default)},
            PreProcessingError = default,
            FileUploadError = default,
            Default = default,
        },
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
        {
            Container = new OutputFileBlobContainerDestination("<containerUrl>")
            {
                Path = "<path>",
                IdentityReference = default,
                UploadHeaders = {new HttpHeader("<name>")
                {
                    Value = "<value>",
                }},
            },
        }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        AffinityInfo = new AffinityInfo("<affinityId>"),
        Constraints = new BatchTaskConstraints
        {
            MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            MaxTaskRetryCount = 1234,
        },
        RequiredSlots = 1234,
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        MultiInstanceSettings = new MultiInstanceSettings("<coordinationCommandLine>")
        {
            NumberOfInstances = 1234,
            CommonResourceFiles = {default},
        },
        DependsOn = new BatchTaskDependencies
        {
            TaskIds = {"<taskIds>"},
            TaskIdRanges = {new BatchTaskIdRange(1234, 1234)},
        },
        ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
        {
            Version = "<version>",
        }},
        AuthenticationTokenSettings = new AuthenticationTokenSettings
        {
            Access = {AccessScope.Job},
        },
    }
});
Response<BatchTaskAddCollectionResult> response = await client.CreateTaskCollectionAsync("<jobId>", taskCollection, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateTaskCollectionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateTaskCollectionAsync (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateTaskCollectionAsync(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.CreateTaskCollectionAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTaskCollectionAsync (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateTaskCollectionAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateTaskCollectionAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.CreateTaskCollectionAsync (jobId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Adds a collection of Tasks to the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.CreateTaskCollectionAsync(System.String,Azure.Compute.Batch.BatchTaskGroup,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateTaskCollectionAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    value = new object[]
    {
        new
        {
            id = "<id>",
            commandLine = "<commandLine>",
        }
    },
});
Response response = await client.CreateTaskCollectionAsync("<jobId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateTaskCollectionAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    value = new object[]
    {
        new
        {
            id = "<id>",
            displayName = "<displayName>",
            exitConditions = new Dictionary<string, object>
            {
                ["exitCodes"] = new object[]
                {
                    new
                    {
                        code = 1234,
                        exitOptions = new
                        {
                            jobAction = "none",
                            dependencyAction = "satisfy",
                        },
                    }
                },
                ["exitCodeRanges"] = new object[]
                {
                    new
                    {
                        start = 1234,
                        end = 1234,
                    }
                },
                ["preProcessingError"] = null,
                ["fileUploadError"] = null,
                ["default"] = null
            },
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            affinityInfo = new
            {
                affinityId = "<affinityId>",
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            multiInstanceSettings = new
            {
                numberOfInstances = 1234,
                coordinationCommandLine = "<coordinationCommandLine>",
                commonResourceFiles = new object[]
                {
                    null
                },
            },
            dependsOn = new
            {
                taskIds = new object[]
                {
                    "<taskIds>"
                },
                taskIdRanges = new object[]
                {
                    new
                    {
                        start = 1234,
                        end = 1234,
                    }
                },
            },
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
        }
    },
});
Response response = await client.CreateTaskCollectionAsync("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("taskId").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("location").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("message").GetProperty("lang").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("message").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("values")[0].GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("error").GetProperty("values")[0].GetProperty("value").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteJob (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteJob(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteJob(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteJob (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteJob : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteJob : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DeleteJob (jobId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to delete. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteJob("<jobId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteJob with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteJob("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteJobAsync (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteJobAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteJobAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteJobAsync (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteJobAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteJobAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DeleteJobAsync (jobId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to delete. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteJobAsync("<jobId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteJobAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteJobAsync("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteJobSchedule (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteJobSchedule(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteJobSchedule(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteJobSchedule (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DeleteJobSchedule (jobScheduleId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to delete. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a Job Schedule from the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteJobSchedule("<jobScheduleId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteJobSchedule with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteJobSchedule("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteJobScheduleAsync (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteJobScheduleAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteJobScheduleAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteJobScheduleAsync (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DeleteJobScheduleAsync (jobScheduleId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to delete. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a Job Schedule from the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteJobScheduleAsync("<jobScheduleId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteJobScheduleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteJobScheduleAsync("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteNodeFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteNodeFile (string poolId, string nodeId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, bool? recursive = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteNodeFile(string poolId, string nodeId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;bool&gt; recursive, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteNodeFile(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteNodeFile (poolId As String, nodeId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional recursive As Nullable(Of Boolean) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteNodeFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteNodeFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DeleteNodeFile (poolId, nodeId, filePath, timeOutInSeconds, ocpdate, recursive, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node. </param>
        <param name="filePath"> The path to the file or directory. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="recursive">
            Whether to delete children of a directory. If the filePath parameter represents
            a directory instead of a file, you can set recursive to true to delete the
            directory and all of the files and subdirectories in it. If recursive is false
            then the directory must be empty or deletion will fail.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes the specified file from the Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteNodeFile.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteNodeFile("<poolId>", "<nodeId>", "<filePath>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteNodeFile with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteNodeFile("<poolId>", "<nodeId>", "<filePath>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), recursive: true);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteNodeFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteNodeFileAsync (string poolId, string nodeId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, bool? recursive = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteNodeFileAsync(string poolId, string nodeId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;bool&gt; recursive, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteNodeFileAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteNodeFileAsync (poolId As String, nodeId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional recursive As Nullable(Of Boolean) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteNodeFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteNodeFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DeleteNodeFileAsync (poolId, nodeId, filePath, timeOutInSeconds, ocpdate, recursive, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node. </param>
        <param name="filePath"> The path to the file or directory. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="recursive">
            Whether to delete children of a directory. If the filePath parameter represents
            a directory instead of a file, you can set recursive to true to delete the
            directory and all of the files and subdirectories in it. If recursive is false
            then the directory must be empty or deletion will fail.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes the specified file from the Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteNodeFileAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteNodeFileAsync("<poolId>", "<nodeId>", "<filePath>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteNodeFileAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteNodeFileAsync("<poolId>", "<nodeId>", "<filePath>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), recursive: true);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteNodeUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteNodeUser (string poolId, string nodeId, string userName, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteNodeUser(string poolId, string nodeId, string userName, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteNodeUser(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteNodeUser (poolId As String, nodeId As String, userName As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteNodeUser : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteNodeUser : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DeleteNodeUser (poolId, nodeId, userName, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        <param name="userName"> The name of the user Account to delete. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a user Account from the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="userName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="userName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteNodeUser.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteNodeUser("<poolId>", "<nodeId>", "<userName>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteNodeUser with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteNodeUser("<poolId>", "<nodeId>", "<userName>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteNodeUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteNodeUserAsync (string poolId, string nodeId, string userName, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteNodeUserAsync(string poolId, string nodeId, string userName, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteNodeUserAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteNodeUserAsync (poolId As String, nodeId As String, userName As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteNodeUserAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteNodeUserAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DeleteNodeUserAsync (poolId, nodeId, userName, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        <param name="userName"> The name of the user Account to delete. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a user Account from the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="userName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="userName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteNodeUserAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteNodeUserAsync("<poolId>", "<nodeId>", "<userName>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteNodeUserAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteNodeUserAsync("<poolId>", "<nodeId>", "<userName>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeletePool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeletePool (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeletePool(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeletePool(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeletePool (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeletePool : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeletePool : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DeletePool (poolId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a Pool from the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeletePool.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeletePool("<poolId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeletePool with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeletePool("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeletePoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeletePoolAsync (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeletePoolAsync(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeletePoolAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeletePoolAsync (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeletePoolAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeletePoolAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DeletePoolAsync (poolId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a Pool from the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeletePoolAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeletePoolAsync("<poolId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeletePoolAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeletePoolAsync("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteTask (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteTask(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteTask(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTask (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DeleteTask (jobId, taskId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        <param name="taskId"> The ID of the Task to delete. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a Task from the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteTask.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteTask("<jobId>", "<taskId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTask with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteTask("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteTaskAsync (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteTaskAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteTaskAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTaskAsync (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DeleteTaskAsync (jobId, taskId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        <param name="taskId"> The ID of the Task to delete. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a Task from the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteTaskAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteTaskAsync("<jobId>", "<taskId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTaskAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteTaskAsync("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteTaskFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteTaskFile (string jobId, string taskId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, bool? recursive = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteTaskFile(string jobId, string taskId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;bool&gt; recursive, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteTaskFile(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTaskFile (jobId As String, taskId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional recursive As Nullable(Of Boolean) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteTaskFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteTaskFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DeleteTaskFile (jobId, taskId, filePath, timeOutInSeconds, ocpdate, recursive, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="recursive">
            Whether to delete children of a directory. If the filePath parameter represents
            a directory instead of a file, you can set recursive to true to delete the
            directory and all of the files and subdirectories in it. If recursive is false
            then the directory must be empty or deletion will fail.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes the specified Task file from the Compute Node where the Task ran.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteTaskFile.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteTaskFile("<jobId>", "<taskId>", "<filePath>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTaskFile with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DeleteTaskFile("<jobId>", "<taskId>", "<filePath>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), recursive: true);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteTaskFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteTaskFileAsync (string jobId, string taskId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, bool? recursive = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteTaskFileAsync(string jobId, string taskId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;bool&gt; recursive, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DeleteTaskFileAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTaskFileAsync (jobId As String, taskId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional recursive As Nullable(Of Boolean) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteTaskFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteTaskFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DeleteTaskFileAsync (jobId, taskId, filePath, timeOutInSeconds, ocpdate, recursive, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="recursive">
            Whether to delete children of a directory. If the filePath parameter represents
            a directory instead of a file, you can set recursive to true to delete the
            directory and all of the files and subdirectories in it. If recursive is false
            then the directory must be empty or deletion will fail.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes the specified Task file from the Compute Node where the Task ran.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteTaskFileAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteTaskFileAsync("<jobId>", "<taskId>", "<filePath>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTaskFileAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DeleteTaskFileAsync("<jobId>", "<taskId>", "<filePath>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), recursive: true);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DisableJob (string jobId, Azure.Compute.Batch.BatchJobDisableContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DisableJob(string jobId, class Azure.Compute.Batch.BatchJobDisableContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableJob(System.String,Azure.Compute.Batch.BatchJobDisableContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableJob (jobId As String, content As BatchJobDisableContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DisableJob : string * Azure.Compute.Batch.BatchJobDisableContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.DisableJob : string * Azure.Compute.Batch.BatchJobDisableContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.DisableJob (jobId, content, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchJobDisableContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to disable. </param>
        <param name="content"> The options to use for disabling the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Disables the specified Job, preventing new Tasks from running. </summary>
        <returns>To be added.</returns>
        <remarks>
            The Batch Service immediately moves the Job to the disabling state. Batch then
            uses the disableTasks parameter to determine what to do with the currently
            running Tasks of the Job. The Job remains in the disabling state until the
            disable operation is completed and all Tasks have been dealt with according to
            the disableTasks option; the Job then moves to the disabled state. No new Tasks
            are started under the Job until it moves back to active state. If you try to
            disable a Job that is in any state other than active, disabling, or disabled,
            the request fails with status code 409.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call DisableJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobDisableContent content = new BatchJobDisableContent(DisableBatchJobOption.Requeue);
Response response = client.DisableJob("<jobId>", content);
]]></code>
This sample shows how to call DisableJob with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobDisableContent content = new BatchJobDisableContent(DisableBatchJobOption.Requeue);
Response response = client.DisableJob("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DisableJob (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DisableJob(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableJob(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableJob (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DisableJob : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DisableJob : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DisableJob (jobId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to disable. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Disables the specified Job, preventing new Tasks from running.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.DisableJob(System.String,Azure.Compute.Batch.BatchJobDisableContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DisableJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    disableTasks = "requeue",
});
Response response = client.DisableJob("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DisableJob with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    disableTasks = "requeue",
});
Response response = client.DisableJob("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DisableJobAsync (string jobId, Azure.Compute.Batch.BatchJobDisableContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DisableJobAsync(string jobId, class Azure.Compute.Batch.BatchJobDisableContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableJobAsync(System.String,Azure.Compute.Batch.BatchJobDisableContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableJobAsync (jobId As String, content As BatchJobDisableContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DisableJobAsync : string * Azure.Compute.Batch.BatchJobDisableContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DisableJobAsync : string * Azure.Compute.Batch.BatchJobDisableContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DisableJobAsync (jobId, content, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchJobDisableContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to disable. </param>
        <param name="content"> The options to use for disabling the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Disables the specified Job, preventing new Tasks from running. </summary>
        <returns>To be added.</returns>
        <remarks>
            The Batch Service immediately moves the Job to the disabling state. Batch then
            uses the disableTasks parameter to determine what to do with the currently
            running Tasks of the Job. The Job remains in the disabling state until the
            disable operation is completed and all Tasks have been dealt with according to
            the disableTasks option; the Job then moves to the disabled state. No new Tasks
            are started under the Job until it moves back to active state. If you try to
            disable a Job that is in any state other than active, disabling, or disabled,
            the request fails with status code 409.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call DisableJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobDisableContent content = new BatchJobDisableContent(DisableBatchJobOption.Requeue);
Response response = await client.DisableJobAsync("<jobId>", content);
]]></code>
This sample shows how to call DisableJobAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobDisableContent content = new BatchJobDisableContent(DisableBatchJobOption.Requeue);
Response response = await client.DisableJobAsync("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DisableJobAsync (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DisableJobAsync(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableJobAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableJobAsync (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DisableJobAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DisableJobAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DisableJobAsync (jobId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to disable. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Disables the specified Job, preventing new Tasks from running.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.DisableJobAsync(System.String,Azure.Compute.Batch.BatchJobDisableContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DisableJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    disableTasks = "requeue",
});
Response response = await client.DisableJobAsync("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DisableJobAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    disableTasks = "requeue",
});
Response response = await client.DisableJobAsync("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DisableJobSchedule (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DisableJobSchedule(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableJobSchedule(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableJobSchedule (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DisableJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DisableJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DisableJobSchedule (jobScheduleId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to disable. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Disables a Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DisableJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DisableJobSchedule("<jobScheduleId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DisableJobSchedule with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DisableJobSchedule("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DisableJobScheduleAsync (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DisableJobScheduleAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableJobScheduleAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableJobScheduleAsync (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DisableJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DisableJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DisableJobScheduleAsync (jobScheduleId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to disable. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Disables a Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DisableJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DisableJobScheduleAsync("<jobScheduleId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DisableJobScheduleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DisableJobScheduleAsync("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableNodeScheduling">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DisableNodeScheduling (string poolId, string nodeId, Azure.Compute.Batch.BatchNodeDisableSchedulingContent parameters = default, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DisableNodeScheduling(string poolId, string nodeId, class Azure.Compute.Batch.BatchNodeDisableSchedulingContent parameters, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableNodeScheduling(System.String,System.String,Azure.Compute.Batch.BatchNodeDisableSchedulingContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableNodeScheduling (poolId As String, nodeId As String, Optional parameters As BatchNodeDisableSchedulingContent = Nothing, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DisableNodeScheduling : string * string * Azure.Compute.Batch.BatchNodeDisableSchedulingContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.DisableNodeScheduling : string * string * Azure.Compute.Batch.BatchNodeDisableSchedulingContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.DisableNodeScheduling (poolId, nodeId, parameters, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="parameters" Type="Azure.Compute.Batch.BatchNodeDisableSchedulingContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        <param name="parameters"> The options to use for disabling scheduling on the Compute Node. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Disables Task scheduling on the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>
            You can disable Task scheduling on a Compute Node only if its current
            scheduling state is enabled.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call DisableNodeScheduling.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DisableNodeScheduling("<poolId>", "<nodeId>");
]]></code>
This sample shows how to call DisableNodeScheduling with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeDisableSchedulingContent parameters = new BatchNodeDisableSchedulingContent
{
    NodeDisableSchedulingOption = BatchNodeDisableSchedulingOption.Requeue,
};
Response response = client.DisableNodeScheduling("<poolId>", "<nodeId>", parameters: parameters, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableNodeScheduling">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DisableNodeScheduling (string poolId, string nodeId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DisableNodeScheduling(string poolId, string nodeId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableNodeScheduling(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableNodeScheduling (poolId As String, nodeId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DisableNodeScheduling : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DisableNodeScheduling : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DisableNodeScheduling (poolId, nodeId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Disables Task scheduling on the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.DisableNodeScheduling(System.String,System.String,Azure.Compute.Batch.BatchNodeDisableSchedulingContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DisableNodeScheduling.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = null;
Response response = client.DisableNodeScheduling("<poolId>", "<nodeId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DisableNodeScheduling with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    nodeDisableSchedulingOption = "requeue",
});
Response response = client.DisableNodeScheduling("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableNodeSchedulingAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DisableNodeSchedulingAsync (string poolId, string nodeId, Azure.Compute.Batch.BatchNodeDisableSchedulingContent parameters = default, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DisableNodeSchedulingAsync(string poolId, string nodeId, class Azure.Compute.Batch.BatchNodeDisableSchedulingContent parameters, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableNodeSchedulingAsync(System.String,System.String,Azure.Compute.Batch.BatchNodeDisableSchedulingContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableNodeSchedulingAsync (poolId As String, nodeId As String, Optional parameters As BatchNodeDisableSchedulingContent = Nothing, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DisableNodeSchedulingAsync : string * string * Azure.Compute.Batch.BatchNodeDisableSchedulingContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DisableNodeSchedulingAsync : string * string * Azure.Compute.Batch.BatchNodeDisableSchedulingContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DisableNodeSchedulingAsync (poolId, nodeId, parameters, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="parameters" Type="Azure.Compute.Batch.BatchNodeDisableSchedulingContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        <param name="parameters"> The options to use for disabling scheduling on the Compute Node. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Disables Task scheduling on the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>
            You can disable Task scheduling on a Compute Node only if its current
            scheduling state is enabled.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call DisableNodeSchedulingAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DisableNodeSchedulingAsync("<poolId>", "<nodeId>");
]]></code>
This sample shows how to call DisableNodeSchedulingAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeDisableSchedulingContent parameters = new BatchNodeDisableSchedulingContent
{
    NodeDisableSchedulingOption = BatchNodeDisableSchedulingOption.Requeue,
};
Response response = await client.DisableNodeSchedulingAsync("<poolId>", "<nodeId>", parameters: parameters, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisableNodeSchedulingAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DisableNodeSchedulingAsync (string poolId, string nodeId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DisableNodeSchedulingAsync(string poolId, string nodeId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisableNodeSchedulingAsync(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisableNodeSchedulingAsync (poolId As String, nodeId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DisableNodeSchedulingAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DisableNodeSchedulingAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DisableNodeSchedulingAsync (poolId, nodeId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Disables Task scheduling on the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.DisableNodeSchedulingAsync(System.String,System.String,Azure.Compute.Batch.BatchNodeDisableSchedulingContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DisableNodeSchedulingAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = null;
Response response = await client.DisableNodeSchedulingAsync("<poolId>", "<nodeId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DisableNodeSchedulingAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    nodeDisableSchedulingOption = "requeue",
});
Response response = await client.DisableNodeSchedulingAsync("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisablePoolAutoScale">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DisablePoolAutoScale (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DisablePoolAutoScale(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisablePoolAutoScale(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisablePoolAutoScale (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DisablePoolAutoScale : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DisablePoolAutoScale : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.DisablePoolAutoScale (poolId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Disables automatic scaling for a Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DisablePoolAutoScale.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DisablePoolAutoScale("<poolId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DisablePoolAutoScale with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.DisablePoolAutoScale("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DisablePoolAutoScaleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DisablePoolAutoScaleAsync (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DisablePoolAutoScaleAsync(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.DisablePoolAutoScaleAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisablePoolAutoScaleAsync (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DisablePoolAutoScaleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DisablePoolAutoScaleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.DisablePoolAutoScaleAsync (poolId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Disables automatic scaling for a Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DisablePoolAutoScaleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DisablePoolAutoScaleAsync("<poolId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DisablePoolAutoScaleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.DisablePoolAutoScaleAsync("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnableJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response EnableJob (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response EnableJob(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnableJob(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnableJob (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member EnableJob : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.EnableJob : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.EnableJob (jobId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to enable. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Enables the specified Job, allowing new Tasks to run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EnableJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.EnableJob("<jobId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call EnableJob with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.EnableJob("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnableJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; EnableJobAsync (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; EnableJobAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnableJobAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnableJobAsync (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member EnableJobAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.EnableJobAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.EnableJobAsync (jobId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to enable. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Enables the specified Job, allowing new Tasks to run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EnableJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.EnableJobAsync("<jobId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call EnableJobAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.EnableJobAsync("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnableJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response EnableJobSchedule (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response EnableJobSchedule(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnableJobSchedule(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnableJobSchedule (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member EnableJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.EnableJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.EnableJobSchedule (jobScheduleId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to enable. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Enables a Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EnableJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.EnableJobSchedule("<jobScheduleId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call EnableJobSchedule with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.EnableJobSchedule("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnableJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; EnableJobScheduleAsync (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; EnableJobScheduleAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnableJobScheduleAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnableJobScheduleAsync (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member EnableJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.EnableJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.EnableJobScheduleAsync (jobScheduleId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to enable. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Enables a Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EnableJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.EnableJobScheduleAsync("<jobScheduleId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call EnableJobScheduleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.EnableJobScheduleAsync("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnableNodeScheduling">
      <MemberSignature Language="C#" Value="public virtual Azure.Response EnableNodeScheduling (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response EnableNodeScheduling(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnableNodeScheduling(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnableNodeScheduling (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member EnableNodeScheduling : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.EnableNodeScheduling : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.EnableNodeScheduling (poolId, nodeId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Enables Task scheduling on the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EnableNodeScheduling.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.EnableNodeScheduling("<poolId>", "<nodeId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call EnableNodeScheduling with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.EnableNodeScheduling("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnableNodeSchedulingAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; EnableNodeSchedulingAsync (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; EnableNodeSchedulingAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnableNodeSchedulingAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnableNodeSchedulingAsync (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member EnableNodeSchedulingAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.EnableNodeSchedulingAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.EnableNodeSchedulingAsync (poolId, nodeId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Enables Task scheduling on the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EnableNodeSchedulingAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.EnableNodeSchedulingAsync("<poolId>", "<nodeId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call EnableNodeSchedulingAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.EnableNodeSchedulingAsync("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnablePoolAutoScale">
      <MemberSignature Language="C#" Value="public virtual Azure.Response EnablePoolAutoScale (string poolId, Azure.Compute.Batch.BatchPoolEnableAutoScaleContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response EnablePoolAutoScale(string poolId, class Azure.Compute.Batch.BatchPoolEnableAutoScaleContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnablePoolAutoScale(System.String,Azure.Compute.Batch.BatchPoolEnableAutoScaleContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnablePoolAutoScale (poolId As String, content As BatchPoolEnableAutoScaleContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member EnablePoolAutoScale : string * Azure.Compute.Batch.BatchPoolEnableAutoScaleContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.EnablePoolAutoScale : string * Azure.Compute.Batch.BatchPoolEnableAutoScaleContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.EnablePoolAutoScale (poolId, content, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchPoolEnableAutoScaleContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The options to use for enabling automatic scaling. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Enables automatic scaling for a Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            You cannot enable automatic scaling on a Pool if a resize operation is in
            progress on the Pool. If automatic scaling of the Pool is currently disabled,
            you must specify a valid autoscale formula as part of the request. If automatic
            scaling of the Pool is already enabled, you may specify a new autoscale formula
            and/or a new evaluation interval. You cannot call this API for the same Pool
            more than once every 30 seconds.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call EnablePoolAutoScale.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolEnableAutoScaleContent content = new BatchPoolEnableAutoScaleContent();
Response response = client.EnablePoolAutoScale("<poolId>", content);
]]></code>
This sample shows how to call EnablePoolAutoScale with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolEnableAutoScaleContent content = new BatchPoolEnableAutoScaleContent
{
    AutoScaleFormula = "<autoScaleFormula>",
    AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
};
Response response = client.EnablePoolAutoScale("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnablePoolAutoScale">
      <MemberSignature Language="C#" Value="public virtual Azure.Response EnablePoolAutoScale (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response EnablePoolAutoScale(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnablePoolAutoScale(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnablePoolAutoScale (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member EnablePoolAutoScale : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.EnablePoolAutoScale : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.EnablePoolAutoScale (poolId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Enables automatic scaling for a Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.EnablePoolAutoScale(System.String,Azure.Compute.Batch.BatchPoolEnableAutoScaleContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EnablePoolAutoScale.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.EnablePoolAutoScale("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call EnablePoolAutoScale with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    autoScaleFormula = "<autoScaleFormula>",
    autoScaleEvaluationInterval = "PT1H23M45S",
});
Response response = client.EnablePoolAutoScale("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnablePoolAutoScaleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; EnablePoolAutoScaleAsync (string poolId, Azure.Compute.Batch.BatchPoolEnableAutoScaleContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; EnablePoolAutoScaleAsync(string poolId, class Azure.Compute.Batch.BatchPoolEnableAutoScaleContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnablePoolAutoScaleAsync(System.String,Azure.Compute.Batch.BatchPoolEnableAutoScaleContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnablePoolAutoScaleAsync (poolId As String, content As BatchPoolEnableAutoScaleContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member EnablePoolAutoScaleAsync : string * Azure.Compute.Batch.BatchPoolEnableAutoScaleContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.EnablePoolAutoScaleAsync : string * Azure.Compute.Batch.BatchPoolEnableAutoScaleContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.EnablePoolAutoScaleAsync (poolId, content, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchPoolEnableAutoScaleContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The options to use for enabling automatic scaling. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Enables automatic scaling for a Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            You cannot enable automatic scaling on a Pool if a resize operation is in
            progress on the Pool. If automatic scaling of the Pool is currently disabled,
            you must specify a valid autoscale formula as part of the request. If automatic
            scaling of the Pool is already enabled, you may specify a new autoscale formula
            and/or a new evaluation interval. You cannot call this API for the same Pool
            more than once every 30 seconds.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call EnablePoolAutoScaleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolEnableAutoScaleContent content = new BatchPoolEnableAutoScaleContent();
Response response = await client.EnablePoolAutoScaleAsync("<poolId>", content);
]]></code>
This sample shows how to call EnablePoolAutoScaleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolEnableAutoScaleContent content = new BatchPoolEnableAutoScaleContent
{
    AutoScaleFormula = "<autoScaleFormula>",
    AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
};
Response response = await client.EnablePoolAutoScaleAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EnablePoolAutoScaleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; EnablePoolAutoScaleAsync (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; EnablePoolAutoScaleAsync(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EnablePoolAutoScaleAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EnablePoolAutoScaleAsync (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member EnablePoolAutoScaleAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.EnablePoolAutoScaleAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.EnablePoolAutoScaleAsync (poolId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Enables automatic scaling for a Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.EnablePoolAutoScaleAsync(System.String,Azure.Compute.Batch.BatchPoolEnableAutoScaleContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EnablePoolAutoScaleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.EnablePoolAutoScaleAsync("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call EnablePoolAutoScaleAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    autoScaleFormula = "<autoScaleFormula>",
    autoScaleEvaluationInterval = "PT1H23M45S",
});
Response response = await client.EnablePoolAutoScaleAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EvaluatePoolAutoScale">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.AutoScaleRun&gt; EvaluatePoolAutoScale (string poolId, Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.AutoScaleRun&gt; EvaluatePoolAutoScale(string poolId, class Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EvaluatePoolAutoScale(System.String,Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EvaluatePoolAutoScale (poolId As String, content As BatchPoolEvaluateAutoScaleContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of AutoScaleRun)" />
      <MemberSignature Language="F#" Value="abstract member EvaluatePoolAutoScale : string * Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.AutoScaleRun&gt;&#xA;override this.EvaluatePoolAutoScale : string * Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.AutoScaleRun&gt;" Usage="batchClient.EvaluatePoolAutoScale (poolId, content, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.AutoScaleRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        <param name="content"> The options to use for evaluating the automatic scaling formula. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets the result of evaluating an automatic scaling formula on the Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            This API is primarily for validating an autoscale formula, as it simply returns
            the result without applying the formula to the Pool. The Pool must have auto
            scaling enabled in order to evaluate a formula.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call EvaluatePoolAutoScale.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolEvaluateAutoScaleContent content = new BatchPoolEvaluateAutoScaleContent("<autoScaleFormula>");
Response<AutoScaleRun> response = client.EvaluatePoolAutoScale("<poolId>", content);
]]></code>
This sample shows how to call EvaluatePoolAutoScale with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolEvaluateAutoScaleContent content = new BatchPoolEvaluateAutoScaleContent("<autoScaleFormula>");
Response<AutoScaleRun> response = client.EvaluatePoolAutoScale("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EvaluatePoolAutoScale">
      <MemberSignature Language="C#" Value="public virtual Azure.Response EvaluatePoolAutoScale (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response EvaluatePoolAutoScale(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EvaluatePoolAutoScale(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EvaluatePoolAutoScale (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member EvaluatePoolAutoScale : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.EvaluatePoolAutoScale : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.EvaluatePoolAutoScale (poolId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the result of evaluating an automatic scaling formula on the Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.EvaluatePoolAutoScale(System.String,Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EvaluatePoolAutoScale and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    autoScaleFormula = "<autoScaleFormula>",
});
Response response = client.EvaluatePoolAutoScale("<poolId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("timestamp").ToString());
]]></code>
This sample shows how to call EvaluatePoolAutoScale with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    autoScaleFormula = "<autoScaleFormula>",
});
Response response = client.EvaluatePoolAutoScale("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("timestamp").ToString());
Console.WriteLine(result.GetProperty("results").ToString());
Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("error").GetProperty("values")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("error").GetProperty("values")[0].GetProperty("value").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EvaluatePoolAutoScaleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.AutoScaleRun&gt;&gt; EvaluatePoolAutoScaleAsync (string poolId, Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.AutoScaleRun&gt;&gt; EvaluatePoolAutoScaleAsync(string poolId, class Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EvaluatePoolAutoScaleAsync(System.String,Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EvaluatePoolAutoScaleAsync (poolId As String, content As BatchPoolEvaluateAutoScaleContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of AutoScaleRun))" />
      <MemberSignature Language="F#" Value="abstract member EvaluatePoolAutoScaleAsync : string * Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.AutoScaleRun&gt;&gt;&#xA;override this.EvaluatePoolAutoScaleAsync : string * Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.AutoScaleRun&gt;&gt;" Usage="batchClient.EvaluatePoolAutoScaleAsync (poolId, content, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.AutoScaleRun&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        <param name="content"> The options to use for evaluating the automatic scaling formula. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets the result of evaluating an automatic scaling formula on the Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            This API is primarily for validating an autoscale formula, as it simply returns
            the result without applying the formula to the Pool. The Pool must have auto
            scaling enabled in order to evaluate a formula.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call EvaluatePoolAutoScaleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolEvaluateAutoScaleContent content = new BatchPoolEvaluateAutoScaleContent("<autoScaleFormula>");
Response<AutoScaleRun> response = await client.EvaluatePoolAutoScaleAsync("<poolId>", content);
]]></code>
This sample shows how to call EvaluatePoolAutoScaleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolEvaluateAutoScaleContent content = new BatchPoolEvaluateAutoScaleContent("<autoScaleFormula>");
Response<AutoScaleRun> response = await client.EvaluatePoolAutoScaleAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="EvaluatePoolAutoScaleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; EvaluatePoolAutoScaleAsync (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; EvaluatePoolAutoScaleAsync(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.EvaluatePoolAutoScaleAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EvaluatePoolAutoScaleAsync (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member EvaluatePoolAutoScaleAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.EvaluatePoolAutoScaleAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.EvaluatePoolAutoScaleAsync (poolId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the result of evaluating an automatic scaling formula on the Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.EvaluatePoolAutoScaleAsync(System.String,Azure.Compute.Batch.BatchPoolEvaluateAutoScaleContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call EvaluatePoolAutoScaleAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    autoScaleFormula = "<autoScaleFormula>",
});
Response response = await client.EvaluatePoolAutoScaleAsync("<poolId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("timestamp").ToString());
]]></code>
This sample shows how to call EvaluatePoolAutoScaleAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    autoScaleFormula = "<autoScaleFormula>",
});
Response response = await client.EvaluatePoolAutoScaleAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("timestamp").ToString());
Console.WriteLine(result.GetProperty("results").ToString());
Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("error").GetProperty("values")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("error").GetProperty("values")[0].GetProperty("value").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetApplication">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetApplication (string applicationId, int? timeOutInSeconds, DateTimeOffset? ocpdate, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetApplication(string applicationId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetApplication(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetApplication (applicationId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetApplication : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetApplication : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetApplication (applicationId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="applicationId"> The ID of the Application. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Application.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetApplication(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="applicationId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetApplication and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetApplication("<applicationId>", null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("versions")[0].ToString());
]]></code>
This sample shows how to call GetApplication with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetApplication("<applicationId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("versions")[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetApplication">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchApplication&gt; GetApplication (string applicationId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchApplication&gt; GetApplication(string applicationId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetApplication(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetApplication (applicationId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchApplication)" />
      <MemberSignature Language="F#" Value="abstract member GetApplication : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchApplication&gt;&#xA;override this.GetApplication : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchApplication&gt;" Usage="batchClient.GetApplication (applicationId, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchApplication&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="applicationId"> The ID of the Application. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Application. </summary>
        <returns>To be added.</returns>
        <remarks>
            This operation returns only Applications and versions that are available for
            use on Compute Nodes; that is, that can be used in an Package reference. For
            administrator information about Applications and versions that are not yet
            available to Compute Nodes, use the Azure portal or the Azure Resource Manager
            API.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="applicationId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetApplication.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchApplication> response = client.GetApplication("<applicationId>");
]]></code>
This sample shows how to call GetApplication with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchApplication> response = client.GetApplication("<applicationId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetApplicationAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetApplicationAsync (string applicationId, int? timeOutInSeconds, DateTimeOffset? ocpdate, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetApplicationAsync(string applicationId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetApplicationAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetApplicationAsync (applicationId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetApplicationAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetApplicationAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetApplicationAsync (applicationId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="applicationId"> The ID of the Application. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Application.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetApplicationAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="applicationId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetApplicationAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetApplicationAsync("<applicationId>", null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("versions")[0].ToString());
]]></code>
This sample shows how to call GetApplicationAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetApplicationAsync("<applicationId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("versions")[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetApplicationAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchApplication&gt;&gt; GetApplicationAsync (string applicationId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchApplication&gt;&gt; GetApplicationAsync(string applicationId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetApplicationAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetApplicationAsync (applicationId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchApplication))" />
      <MemberSignature Language="F#" Value="abstract member GetApplicationAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchApplication&gt;&gt;&#xA;override this.GetApplicationAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchApplication&gt;&gt;" Usage="batchClient.GetApplicationAsync (applicationId, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchApplication&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="applicationId"> The ID of the Application. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Application. </summary>
        <returns>To be added.</returns>
        <remarks>
            This operation returns only Applications and versions that are available for
            use on Compute Nodes; that is, that can be used in an Package reference. For
            administrator information about Applications and versions that are not yet
            available to Compute Nodes, use the Azure portal or the Azure Resource Manager
            API.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="applicationId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetApplicationAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchApplication> response = await client.GetApplicationAsync("<applicationId>");
]]></code>
This sample shows how to call GetApplicationAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchApplication> response = await client.GetApplicationAsync("<applicationId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetApplications">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetApplications (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetApplications(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetApplications(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetApplications (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetApplications : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetApplications : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetApplications (timeOutInSeconds, ocpdate, maxresults, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the applications available in the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetApplications(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetApplications and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetApplications(null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("versions")[0].ToString());
}
]]></code>
This sample shows how to call GetApplications with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetApplications(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("versions")[0].ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetApplications">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchApplication&gt; GetApplications (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchApplication&gt; GetApplications(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetApplications(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetApplications (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchApplication)" />
      <MemberSignature Language="F#" Value="abstract member GetApplications : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchApplication&gt;&#xA;override this.GetApplications : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchApplication&gt;" Usage="batchClient.GetApplications (timeOutInSeconds, ocpdate, maxresults, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchApplication&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the applications available in the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>
            This operation returns only Applications and versions that are available for
            use on Compute Nodes; that is, that can be used in an Package reference. For
            administrator information about applications and versions that are not yet
            available to Compute Nodes, use the Azure portal or the Azure Resource Manager
            API.
            </remarks>
        <example>
This sample shows how to call GetApplications.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchApplication item in client.GetApplications())
{
}
]]></code>
This sample shows how to call GetApplications with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchApplication item in client.GetApplications(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetApplicationsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetApplicationsAsync (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetApplicationsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetApplicationsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetApplicationsAsync (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetApplicationsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetApplicationsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetApplicationsAsync (timeOutInSeconds, ocpdate, maxresults, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the applications available in the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetApplicationsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetApplicationsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetApplicationsAsync(null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("versions")[0].ToString());
}
]]></code>
This sample shows how to call GetApplicationsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetApplicationsAsync(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("versions")[0].ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetApplicationsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchApplication&gt; GetApplicationsAsync (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchApplication&gt; GetApplicationsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetApplicationsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetApplicationsAsync (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchApplication)" />
      <MemberSignature Language="F#" Value="abstract member GetApplicationsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchApplication&gt;&#xA;override this.GetApplicationsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchApplication&gt;" Usage="batchClient.GetApplicationsAsync (timeOutInSeconds, ocpdate, maxresults, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchApplication&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the applications available in the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>
            This operation returns only Applications and versions that are available for
            use on Compute Nodes; that is, that can be used in an Package reference. For
            administrator information about applications and versions that are not yet
            available to Compute Nodes, use the Azure portal or the Azure Resource Manager
            API.
            </remarks>
        <example>
This sample shows how to call GetApplicationsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchApplication item in client.GetApplicationsAsync())
{
}
]]></code>
This sample shows how to call GetApplicationsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchApplication item in client.GetApplicationsAsync(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetJob (string jobId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetJob(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJob(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJob (jobId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), expand As IEnumerable(Of String), requestConditions As RequestConditions, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetJob : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetJob : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetJob (jobId, timeOutInSeconds, ocpdate, select, expand, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJob(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJob and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetJob("<jobId>", null, null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("poolInfo").ToString());
]]></code>
This sample shows how to call GetJob with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetJob("<jobId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, new string[] { "<expand>" }, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("usesTaskDependencies").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("creationTime").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("previousState").ToString());
Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("allowTaskPreemption").ToString());
Console.WriteLine(result.GetProperty("maxParallelTasks").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("poolId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
Console.WriteLine(result.GetProperty("onAllTasksComplete").ToString());
Console.WriteLine(result.GetProperty("onTaskFailure").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("poolId").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("terminateReason").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchJob&gt; GetJob (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchJob&gt; GetJob(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJob(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJob (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchJob)" />
      <MemberSignature Language="F#" Value="abstract member GetJob : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchJob&gt;&#xA;override this.GetJob : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchJob&gt;" Usage="batchClient.GetJob (jobId, timeOutInSeconds, ocpdate, select, expand, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchJob&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchJob> response = client.GetJob("<jobId>");
]]></code>
This sample shows how to call GetJob with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchJob> response = client.GetJob("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }, expand: new string[] { "<expand>" }, requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetJobAsync (string jobId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetJobAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobAsync (jobId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), expand As IEnumerable(Of String), requestConditions As RequestConditions, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetJobAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetJobAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetJobAsync (jobId, timeOutInSeconds, ocpdate, select, expand, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetJobAsync("<jobId>", null, null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("poolInfo").ToString());
]]></code>
This sample shows how to call GetJobAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetJobAsync("<jobId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, new string[] { "<expand>" }, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("usesTaskDependencies").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("creationTime").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("previousState").ToString());
Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("allowTaskPreemption").ToString());
Console.WriteLine(result.GetProperty("maxParallelTasks").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("poolId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
Console.WriteLine(result.GetProperty("onAllTasksComplete").ToString());
Console.WriteLine(result.GetProperty("onTaskFailure").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("poolId").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("terminateReason").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchJob&gt;&gt; GetJobAsync (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchJob&gt;&gt; GetJobAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobAsync (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchJob))" />
      <MemberSignature Language="F#" Value="abstract member GetJobAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchJob&gt;&gt;&#xA;override this.GetJobAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchJob&gt;&gt;" Usage="batchClient.GetJobAsync (jobId, timeOutInSeconds, ocpdate, select, expand, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchJob&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchJob> response = await client.GetJobAsync("<jobId>");
]]></code>
This sample shows how to call GetJobAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchJob> response = await client.GetJobAsync("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }, expand: new string[] { "<expand>" }, requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobPreparationAndReleaseTaskStatuses">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetJobPreparationAndReleaseTaskStatuses (string jobId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetJobPreparationAndReleaseTaskStatuses(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobPreparationAndReleaseTaskStatuses(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobPreparationAndReleaseTaskStatuses (jobId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetJobPreparationAndReleaseTaskStatuses : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetJobPreparationAndReleaseTaskStatuses : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetJobPreparationAndReleaseTaskStatuses (jobId, timeOutInSeconds, ocpdate, maxresults, filter, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the execution status of the Job Preparation and Job Release Task for the
            specified Job across the Compute Nodes where the Job has run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobPreparationAndReleaseTaskStatuses(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobPreparationAndReleaseTaskStatuses and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetJobPreparationAndReleaseTaskStatuses("<jobId>", null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetJobPreparationAndReleaseTaskStatuses with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetJobPreparationAndReleaseTaskStatuses("<jobId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("nodeId").ToString());
    Console.WriteLine(result.GetProperty("nodeUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("taskRootDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("taskRootDirectoryUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("retryCount").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("lastRetryTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("result").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("taskRootDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("taskRootDirectoryUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("result").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobPreparationAndReleaseTaskStatuses">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt; GetJobPreparationAndReleaseTaskStatuses (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt; GetJobPreparationAndReleaseTaskStatuses(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobPreparationAndReleaseTaskStatuses(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobPreparationAndReleaseTaskStatuses (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchJobPreparationAndReleaseTaskStatus)" />
      <MemberSignature Language="F#" Value="abstract member GetJobPreparationAndReleaseTaskStatuses : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt;&#xA;override this.GetJobPreparationAndReleaseTaskStatuses : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt;" Usage="batchClient.GetJobPreparationAndReleaseTaskStatuses (jobId, timeOutInSeconds, ocpdate, maxresults, filter, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Lists the execution status of the Job Preparation and Job Release Task for the
            specified Job across the Compute Nodes where the Job has run.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            This API returns the Job Preparation and Job Release Task status on all Compute
            Nodes that have run the Job Preparation or Job Release Task. This includes
            Compute Nodes which have since been removed from the Pool. If this API is
            invoked on a Job which has no Job Preparation or Job Release Task, the Batch
            service returns HTTP status code 409 (Conflict) with an error code of
            JobPreparationTaskNotSpecified.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobPreparationAndReleaseTaskStatuses.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchJobPreparationAndReleaseTaskStatus item in client.GetJobPreparationAndReleaseTaskStatuses("<jobId>"))
{
}
]]></code>
This sample shows how to call GetJobPreparationAndReleaseTaskStatuses with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchJobPreparationAndReleaseTaskStatus item in client.GetJobPreparationAndReleaseTaskStatuses("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobPreparationAndReleaseTaskStatusesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetJobPreparationAndReleaseTaskStatusesAsync (string jobId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetJobPreparationAndReleaseTaskStatusesAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobPreparationAndReleaseTaskStatusesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobPreparationAndReleaseTaskStatusesAsync (jobId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetJobPreparationAndReleaseTaskStatusesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetJobPreparationAndReleaseTaskStatusesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetJobPreparationAndReleaseTaskStatusesAsync (jobId, timeOutInSeconds, ocpdate, maxresults, filter, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the execution status of the Job Preparation and Job Release Task for the
            specified Job across the Compute Nodes where the Job has run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobPreparationAndReleaseTaskStatusesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobPreparationAndReleaseTaskStatusesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetJobPreparationAndReleaseTaskStatusesAsync("<jobId>", null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetJobPreparationAndReleaseTaskStatusesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetJobPreparationAndReleaseTaskStatusesAsync("<jobId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("nodeId").ToString());
    Console.WriteLine(result.GetProperty("nodeUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("taskRootDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("taskRootDirectoryUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("retryCount").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("lastRetryTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTaskExecutionInfo").GetProperty("result").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("taskRootDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("taskRootDirectoryUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTaskExecutionInfo").GetProperty("result").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobPreparationAndReleaseTaskStatusesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt; GetJobPreparationAndReleaseTaskStatusesAsync (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt; GetJobPreparationAndReleaseTaskStatusesAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobPreparationAndReleaseTaskStatusesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobPreparationAndReleaseTaskStatusesAsync (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchJobPreparationAndReleaseTaskStatus)" />
      <MemberSignature Language="F#" Value="abstract member GetJobPreparationAndReleaseTaskStatusesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt;&#xA;override this.GetJobPreparationAndReleaseTaskStatusesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt;" Usage="batchClient.GetJobPreparationAndReleaseTaskStatusesAsync (jobId, timeOutInSeconds, ocpdate, maxresults, filter, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJobPreparationAndReleaseTaskStatus&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Lists the execution status of the Job Preparation and Job Release Task for the
            specified Job across the Compute Nodes where the Job has run.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            This API returns the Job Preparation and Job Release Task status on all Compute
            Nodes that have run the Job Preparation or Job Release Task. This includes
            Compute Nodes which have since been removed from the Pool. If this API is
            invoked on a Job which has no Job Preparation or Job Release Task, the Batch
            service returns HTTP status code 409 (Conflict) with an error code of
            JobPreparationTaskNotSpecified.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobPreparationAndReleaseTaskStatusesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchJobPreparationAndReleaseTaskStatus item in client.GetJobPreparationAndReleaseTaskStatusesAsync("<jobId>"))
{
}
]]></code>
This sample shows how to call GetJobPreparationAndReleaseTaskStatusesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchJobPreparationAndReleaseTaskStatus item in client.GetJobPreparationAndReleaseTaskStatusesAsync("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobs">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetJobs (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetJobs(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobs(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobs (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetJobs : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetJobs : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetJobs (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the Jobs in the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobs(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobs and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetJobs(null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolInfo").ToString());
}
]]></code>
This sample shows how to call GetJobs with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetJobs(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("usesTaskDependencies").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("allowTaskPreemption").ToString());
    Console.WriteLine(result.GetProperty("maxParallelTasks").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
    Console.WriteLine(result.GetProperty("onAllTasksComplete").ToString());
    Console.WriteLine(result.GetProperty("onTaskFailure").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("terminateReason").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobs">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchJob&gt; GetJobs (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchJob&gt; GetJobs(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobs(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobs (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchJob)" />
      <MemberSignature Language="F#" Value="abstract member GetJobs : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchJob&gt;&#xA;override this.GetJobs : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchJob&gt;" Usage="batchClient.GetJobs (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchJob&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the Jobs in the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetJobs.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchJob item in client.GetJobs())
{
}
]]></code>
This sample shows how to call GetJobs with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchJob item in client.GetJobs(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetJobsAsync (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetJobsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobsAsync (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetJobsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetJobsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetJobsAsync (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the Jobs in the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetJobsAsync(null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolInfo").ToString());
}
]]></code>
This sample shows how to call GetJobsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetJobsAsync(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("usesTaskDependencies").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("allowTaskPreemption").ToString());
    Console.WriteLine(result.GetProperty("maxParallelTasks").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
    Console.WriteLine(result.GetProperty("onAllTasksComplete").ToString());
    Console.WriteLine(result.GetProperty("onTaskFailure").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("terminateReason").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJob&gt; GetJobsAsync (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchJob&gt; GetJobsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobsAsync (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchJob)" />
      <MemberSignature Language="F#" Value="abstract member GetJobsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJob&gt;&#xA;override this.GetJobsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJob&gt;" Usage="batchClient.GetJobsAsync (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJob&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the Jobs in the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetJobsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchJob item in client.GetJobsAsync())
{
}
]]></code>
This sample shows how to call GetJobsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchJob item in client.GetJobsAsync(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetJobSchedule (string jobScheduleId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetJobSchedule(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobSchedule(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobSchedule (jobScheduleId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), expand As IEnumerable(Of String), requestConditions As RequestConditions, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetJobSchedule (jobScheduleId, timeOutInSeconds, ocpdate, select, expand, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobSchedule(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobSchedule and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetJobSchedule("<jobScheduleId>", null, null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").ToString());
]]></code>
This sample shows how to call GetJobSchedule with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetJobSchedule("<jobScheduleId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, new string[] { "<expand>" }, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("creationTime").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("previousState").ToString());
Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("schedule").GetProperty("doNotRunUntil").ToString());
Console.WriteLine(result.GetProperty("schedule").GetProperty("doNotRunAfter").ToString());
Console.WriteLine(result.GetProperty("schedule").GetProperty("startWindow").ToString());
Console.WriteLine(result.GetProperty("schedule").GetProperty("recurrenceInterval").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("allowTaskPreemption").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("maxParallelTasks").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("usesTaskDependencies").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("onAllTasksComplete").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("onTaskFailure").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("poolId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("nextRunTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("recentJob").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("recentJob").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchJobSchedule&gt; GetJobSchedule (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchJobSchedule&gt; GetJobSchedule(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobSchedule(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobSchedule (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchJobSchedule)" />
      <MemberSignature Language="F#" Value="abstract member GetJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchJobSchedule&gt;&#xA;override this.GetJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchJobSchedule&gt;" Usage="batchClient.GetJobSchedule (jobScheduleId, timeOutInSeconds, ocpdate, select, expand, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchJobSchedule&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Job Schedule. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchJobSchedule> response = client.GetJobSchedule("<jobScheduleId>");
]]></code>
This sample shows how to call GetJobSchedule with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchJobSchedule> response = client.GetJobSchedule("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }, expand: new string[] { "<expand>" }, requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetJobScheduleAsync (string jobScheduleId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetJobScheduleAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobScheduleAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobScheduleAsync (jobScheduleId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), expand As IEnumerable(Of String), requestConditions As RequestConditions, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetJobScheduleAsync (jobScheduleId, timeOutInSeconds, ocpdate, select, expand, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobScheduleAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobScheduleAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetJobScheduleAsync("<jobScheduleId>", null, null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").ToString());
]]></code>
This sample shows how to call GetJobScheduleAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetJobScheduleAsync("<jobScheduleId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, new string[] { "<expand>" }, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("creationTime").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("previousState").ToString());
Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("schedule").GetProperty("doNotRunUntil").ToString());
Console.WriteLine(result.GetProperty("schedule").GetProperty("doNotRunAfter").ToString());
Console.WriteLine(result.GetProperty("schedule").GetProperty("startWindow").ToString());
Console.WriteLine(result.GetProperty("schedule").GetProperty("recurrenceInterval").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("allowTaskPreemption").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("maxParallelTasks").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("usesTaskDependencies").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("onAllTasksComplete").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("onTaskFailure").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("poolId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("nextRunTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("recentJob").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("recentJob").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchJobSchedule&gt;&gt; GetJobScheduleAsync (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchJobSchedule&gt;&gt; GetJobScheduleAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobScheduleAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobScheduleAsync (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchJobSchedule))" />
      <MemberSignature Language="F#" Value="abstract member GetJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchJobSchedule&gt;&gt;&#xA;override this.GetJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchJobSchedule&gt;&gt;" Usage="batchClient.GetJobScheduleAsync (jobScheduleId, timeOutInSeconds, ocpdate, select, expand, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchJobSchedule&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Job Schedule. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchJobSchedule> response = await client.GetJobScheduleAsync("<jobScheduleId>");
]]></code>
This sample shows how to call GetJobScheduleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchJobSchedule> response = await client.GetJobScheduleAsync("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }, expand: new string[] { "<expand>" }, requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobSchedules">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetJobSchedules (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetJobSchedules(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobSchedules(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobSchedules (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetJobSchedules : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetJobSchedules : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetJobSchedules (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the Job Schedules in the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobSchedules(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobSchedules and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetJobSchedules(null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").ToString());
}
]]></code>
This sample shows how to call GetJobSchedules with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetJobSchedules(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("schedule").GetProperty("doNotRunUntil").ToString());
    Console.WriteLine(result.GetProperty("schedule").GetProperty("doNotRunAfter").ToString());
    Console.WriteLine(result.GetProperty("schedule").GetProperty("startWindow").ToString());
    Console.WriteLine(result.GetProperty("schedule").GetProperty("recurrenceInterval").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("allowTaskPreemption").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("maxParallelTasks").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("usesTaskDependencies").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("onAllTasksComplete").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("onTaskFailure").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("nextRunTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("recentJob").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("recentJob").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobSchedules">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchJobSchedule&gt; GetJobSchedules (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchJobSchedule&gt; GetJobSchedules(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobSchedules(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobSchedules (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchJobSchedule)" />
      <MemberSignature Language="F#" Value="abstract member GetJobSchedules : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchJobSchedule&gt;&#xA;override this.GetJobSchedules : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchJobSchedule&gt;" Usage="batchClient.GetJobSchedules (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchJobSchedule&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the Job Schedules in the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetJobSchedules.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchJobSchedule item in client.GetJobSchedules())
{
}
]]></code>
This sample shows how to call GetJobSchedules with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchJobSchedule item in client.GetJobSchedules(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobSchedulesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetJobSchedulesAsync (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetJobSchedulesAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobSchedulesAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobSchedulesAsync (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetJobSchedulesAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetJobSchedulesAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetJobSchedulesAsync (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the Job Schedules in the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobSchedulesAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobSchedulesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetJobSchedulesAsync(null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").ToString());
}
]]></code>
This sample shows how to call GetJobSchedulesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetJobSchedulesAsync(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("schedule").GetProperty("doNotRunUntil").ToString());
    Console.WriteLine(result.GetProperty("schedule").GetProperty("doNotRunAfter").ToString());
    Console.WriteLine(result.GetProperty("schedule").GetProperty("startWindow").ToString());
    Console.WriteLine(result.GetProperty("schedule").GetProperty("recurrenceInterval").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("allowTaskPreemption").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("maxParallelTasks").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("usesTaskDependencies").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("onAllTasksComplete").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("onTaskFailure").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobSpecification").GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("nextRunTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("recentJob").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("recentJob").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobSchedulesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJobSchedule&gt; GetJobSchedulesAsync (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchJobSchedule&gt; GetJobSchedulesAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobSchedulesAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobSchedulesAsync (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchJobSchedule)" />
      <MemberSignature Language="F#" Value="abstract member GetJobSchedulesAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJobSchedule&gt;&#xA;override this.GetJobSchedulesAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJobSchedule&gt;" Usage="batchClient.GetJobSchedulesAsync (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJobSchedule&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the Job Schedules in the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetJobSchedulesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchJobSchedule item in client.GetJobSchedulesAsync())
{
}
]]></code>
This sample shows how to call GetJobSchedulesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchJobSchedule item in client.GetJobSchedulesAsync(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobsFromSchedules">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetJobsFromSchedules (string jobScheduleId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetJobsFromSchedules(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobsFromSchedules(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobsFromSchedules (jobScheduleId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetJobsFromSchedules : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetJobsFromSchedules : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetJobsFromSchedules (jobScheduleId, timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the Jobs that have been created under the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobsFromSchedules(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobsFromSchedules and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetJobsFromSchedules("<jobScheduleId>", null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolInfo").ToString());
}
]]></code>
This sample shows how to call GetJobsFromSchedules with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetJobsFromSchedules("<jobScheduleId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("usesTaskDependencies").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("allowTaskPreemption").ToString());
    Console.WriteLine(result.GetProperty("maxParallelTasks").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
    Console.WriteLine(result.GetProperty("onAllTasksComplete").ToString());
    Console.WriteLine(result.GetProperty("onTaskFailure").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("terminateReason").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobsFromSchedules">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchJob&gt; GetJobsFromSchedules (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchJob&gt; GetJobsFromSchedules(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobsFromSchedules(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobsFromSchedules (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchJob)" />
      <MemberSignature Language="F#" Value="abstract member GetJobsFromSchedules : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchJob&gt;&#xA;override this.GetJobsFromSchedules : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchJob&gt;" Usage="batchClient.GetJobsFromSchedules (jobScheduleId, timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchJob&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists the Jobs that have been created under the specified Job Schedule. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobsFromSchedules.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchJob item in client.GetJobsFromSchedules("<jobScheduleId>"))
{
}
]]></code>
This sample shows how to call GetJobsFromSchedules with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchJob item in client.GetJobsFromSchedules("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobsFromSchedulesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetJobsFromSchedulesAsync (string jobScheduleId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetJobsFromSchedulesAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobsFromSchedulesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobsFromSchedulesAsync (jobScheduleId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetJobsFromSchedulesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetJobsFromSchedulesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetJobsFromSchedulesAsync (jobScheduleId, timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the Jobs that have been created under the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobsFromSchedulesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobsFromSchedulesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetJobsFromSchedulesAsync("<jobScheduleId>", null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolInfo").ToString());
}
]]></code>
This sample shows how to call GetJobsFromSchedulesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetJobsFromSchedulesAsync("<jobScheduleId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("usesTaskDependencies").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("allowTaskPreemption").ToString());
    Console.WriteLine(result.GetProperty("maxParallelTasks").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("requiredSlots").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("killJobOnCompletion").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("runExclusive").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
    Console.WriteLine(result.GetProperty("jobManagerTask").GetProperty("allowLowPriorityNode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("jobPreparationTask").GetProperty("rerunOnNodeRebootAfterSuccess").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("jobReleaseTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("commonEnvironmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("autoPoolIdPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("poolLifetimeOption").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("keepAlive").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSlotsPerNode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resizeTimeout").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("resourceTags").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableAutoScale").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleFormula").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("autoScaleEvaluationInterval").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("enableInterNodeCommunication").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("targetNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("mode").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
    Console.WriteLine(result.GetProperty("poolInfo").GetProperty("autoPoolSpecification").GetProperty("pool").GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
    Console.WriteLine(result.GetProperty("onAllTasksComplete").ToString());
    Console.WriteLine(result.GetProperty("onTaskFailure").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("schedulingError").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("terminateReason").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numSucceededTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numFailedTasks").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("numTaskRetries").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobsFromSchedulesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJob&gt; GetJobsFromSchedulesAsync (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchJob&gt; GetJobsFromSchedulesAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobsFromSchedulesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobsFromSchedulesAsync (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchJob)" />
      <MemberSignature Language="F#" Value="abstract member GetJobsFromSchedulesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJob&gt;&#xA;override this.GetJobsFromSchedulesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJob&gt;" Usage="batchClient.GetJobsFromSchedulesAsync (jobScheduleId, timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchJob&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists the Jobs that have been created under the specified Job Schedule. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobsFromSchedulesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchJob item in client.GetJobsFromSchedulesAsync("<jobScheduleId>"))
{
}
]]></code>
This sample shows how to call GetJobsFromSchedulesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchJob item in client.GetJobsFromSchedulesAsync("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobTaskCounts">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetJobTaskCounts (string jobId, int? timeOutInSeconds, DateTimeOffset? ocpdate, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetJobTaskCounts(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobTaskCounts(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobTaskCounts (jobId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetJobTaskCounts : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetJobTaskCounts : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetJobTaskCounts (jobId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the Task counts for the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobTaskCounts(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobTaskCounts and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetJobTaskCounts("<jobId>", null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("active").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("running").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("completed").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("succeeded").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("failed").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("active").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("running").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("completed").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("succeeded").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("failed").ToString());
]]></code>
This sample shows how to call GetJobTaskCounts with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetJobTaskCounts("<jobId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("active").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("running").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("completed").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("succeeded").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("failed").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("active").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("running").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("completed").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("succeeded").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("failed").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobTaskCounts">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchTaskCountsResult&gt; GetJobTaskCounts (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchTaskCountsResult&gt; GetJobTaskCounts(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobTaskCounts(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobTaskCounts (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchTaskCountsResult)" />
      <MemberSignature Language="F#" Value="abstract member GetJobTaskCounts : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchTaskCountsResult&gt;&#xA;override this.GetJobTaskCounts : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchTaskCountsResult&gt;" Usage="batchClient.GetJobTaskCounts (jobId, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchTaskCountsResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets the Task counts for the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            Task counts provide a count of the Tasks by active, running or completed Task
            state, and a count of Tasks which succeeded or failed. Tasks in the preparing
            state are counted as running. Note that the numbers returned may not always be
            up to date. If you need exact task counts, use a list query.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobTaskCounts.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchTaskCountsResult> response = client.GetJobTaskCounts("<jobId>");
]]></code>
This sample shows how to call GetJobTaskCounts with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchTaskCountsResult> response = client.GetJobTaskCounts("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobTaskCountsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetJobTaskCountsAsync (string jobId, int? timeOutInSeconds, DateTimeOffset? ocpdate, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetJobTaskCountsAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobTaskCountsAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobTaskCountsAsync (jobId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetJobTaskCountsAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetJobTaskCountsAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetJobTaskCountsAsync (jobId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the Task counts for the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetJobTaskCountsAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetJobTaskCountsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetJobTaskCountsAsync("<jobId>", null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("active").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("running").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("completed").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("succeeded").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("failed").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("active").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("running").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("completed").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("succeeded").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("failed").ToString());
]]></code>
This sample shows how to call GetJobTaskCountsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetJobTaskCountsAsync("<jobId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("active").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("running").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("completed").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("succeeded").ToString());
Console.WriteLine(result.GetProperty("taskCounts").GetProperty("failed").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("active").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("running").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("completed").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("succeeded").ToString());
Console.WriteLine(result.GetProperty("taskSlotCounts").GetProperty("failed").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetJobTaskCountsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTaskCountsResult&gt;&gt; GetJobTaskCountsAsync (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchTaskCountsResult&gt;&gt; GetJobTaskCountsAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetJobTaskCountsAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetJobTaskCountsAsync (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchTaskCountsResult))" />
      <MemberSignature Language="F#" Value="abstract member GetJobTaskCountsAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTaskCountsResult&gt;&gt;&#xA;override this.GetJobTaskCountsAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTaskCountsResult&gt;&gt;" Usage="batchClient.GetJobTaskCountsAsync (jobId, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTaskCountsResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets the Task counts for the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            Task counts provide a count of the Tasks by active, running or completed Task
            state, and a count of Tasks which succeeded or failed. Tasks in the preparing
            state are counted as running. Note that the numbers returned may not always be
            up to date. If you need exact task counts, use a list query.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetJobTaskCountsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchTaskCountsResult> response = await client.GetJobTaskCountsAsync("<jobId>");
]]></code>
This sample shows how to call GetJobTaskCountsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchTaskCountsResult> response = await client.GetJobTaskCountsAsync("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNode">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetNode (string poolId, string nodeId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetNode(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNode(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNode (poolId As String, nodeId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetNode : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetNode : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetNode (poolId, nodeId, timeOutInSeconds, ocpdate, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNode(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNode and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetNode("<poolId>", "<nodeId>", null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetNode with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetNode("<poolId>", "<nodeId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("schedulingState").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("lastBootTime").ToString());
Console.WriteLine(result.GetProperty("allocationTime").ToString());
Console.WriteLine(result.GetProperty("ipAddress").ToString());
Console.WriteLine(result.GetProperty("affinityId").ToString());
Console.WriteLine(result.GetProperty("vmSize").ToString());
Console.WriteLine(result.GetProperty("totalTasksRun").ToString());
Console.WriteLine(result.GetProperty("runningTasksCount").ToString());
Console.WriteLine(result.GetProperty("runningTaskSlotsCount").ToString());
Console.WriteLine(result.GetProperty("totalTasksSucceeded").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskUrl").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("jobId").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskId").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("subtaskId").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskState").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("exitCode").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("retryCount").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("lastRetryTime").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("requeueCount").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("lastRequeueTime").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("exitCode").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("error").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("retryCount").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("lastRetryTime").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("errors")[0].GetProperty("errorDetails")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("errors")[0].GetProperty("errorDetails")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("isDedicated").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("publicIPAddress").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("publicFQDN").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("frontendPort").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("backendPort").ToString());
Console.WriteLine(result.GetProperty("nodeAgentInfo").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("nodeAgentInfo").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("offer").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("sku").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("exactVersion").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("scaleSetVmResourceId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNode">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchNode&gt; GetNode (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchNode&gt; GetNode(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNode(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNode (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchNode)" />
      <MemberSignature Language="F#" Value="abstract member GetNode : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchNode&gt;&#xA;override this.GetNode : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchNode&gt;" Usage="batchClient.GetNode (poolId, nodeId, timeOutInSeconds, ocpdate, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNode.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNode> response = client.GetNode("<poolId>", "<nodeId>");
]]></code>
This sample shows how to call GetNode with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNode> response = client.GetNode("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetNodeAsync (string poolId, string nodeId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetNodeAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeAsync (poolId As String, nodeId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetNodeAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetNodeAsync (poolId, nodeId, timeOutInSeconds, ocpdate, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetNodeAsync("<poolId>", "<nodeId>", null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetNodeAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetNodeAsync("<poolId>", "<nodeId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("schedulingState").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("lastBootTime").ToString());
Console.WriteLine(result.GetProperty("allocationTime").ToString());
Console.WriteLine(result.GetProperty("ipAddress").ToString());
Console.WriteLine(result.GetProperty("affinityId").ToString());
Console.WriteLine(result.GetProperty("vmSize").ToString());
Console.WriteLine(result.GetProperty("totalTasksRun").ToString());
Console.WriteLine(result.GetProperty("runningTasksCount").ToString());
Console.WriteLine(result.GetProperty("runningTaskSlotsCount").ToString());
Console.WriteLine(result.GetProperty("totalTasksSucceeded").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskUrl").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("jobId").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskId").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("subtaskId").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskState").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("exitCode").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("retryCount").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("lastRetryTime").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("requeueCount").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("lastRequeueTime").ToString());
Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("exitCode").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("error").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("retryCount").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("lastRetryTime").ToString());
Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("errors")[0].GetProperty("errorDetails")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("errors")[0].GetProperty("errorDetails")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("isDedicated").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("publicIPAddress").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("publicFQDN").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("frontendPort").ToString());
Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("backendPort").ToString());
Console.WriteLine(result.GetProperty("nodeAgentInfo").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("nodeAgentInfo").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("offer").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("sku").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("exactVersion").ToString());
Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("scaleSetVmResourceId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNode&gt;&gt; GetNodeAsync (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchNode&gt;&gt; GetNodeAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeAsync (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchNode))" />
      <MemberSignature Language="F#" Value="abstract member GetNodeAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNode&gt;&gt;&#xA;override this.GetNodeAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNode&gt;&gt;" Usage="batchClient.GetNodeAsync (poolId, nodeId, timeOutInSeconds, ocpdate, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNode&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNode> response = await client.GetNodeAsync("<poolId>", "<nodeId>");
]]></code>
This sample shows how to call GetNodeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNode> response = await client.GetNodeAsync("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeExtension">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetNodeExtension (string poolId, string nodeId, string extensionName, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetNodeExtension(string poolId, string nodeId, string extensionName, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeExtension(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeExtension (poolId As String, nodeId As String, extensionName As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetNodeExtension : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetNodeExtension : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetNodeExtension (poolId, nodeId, extensionName, timeOutInSeconds, ocpdate, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="extensionName" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        <param name="extensionName"> The name of the Compute Node Extension that you want to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Compute Node Extension.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeExtension(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="extensionName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="extensionName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeExtension and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetNodeExtension("<poolId>", "<nodeId>", "<extensionName>", null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetNodeExtension with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetNodeExtension("<poolId>", "<nodeId>", "<extensionName>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("provisioningState").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("typeHandlerVersion").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("autoUpgradeMinorVersion").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("enableAutomaticUpgrade").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("settings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("protectedSettings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("provisionAfterExtensions")[0].ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("displayStatus").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("level").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("time").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("displayStatus").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("level").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("time").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeExtension">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt; GetNodeExtension (string poolId, string nodeId, string extensionName, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchNodeVMExtension&gt; GetNodeExtension(string poolId, string nodeId, string extensionName, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeExtension(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeExtension (poolId As String, nodeId As String, extensionName As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchNodeVMExtension)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeExtension : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;&#xA;override this.GetNodeExtension : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;" Usage="batchClient.GetNodeExtension (poolId, nodeId, extensionName, timeOutInSeconds, ocpdate, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="extensionName" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        <param name="extensionName"> The name of the Compute Node Extension that you want to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Compute Node Extension. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="extensionName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="extensionName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeExtension.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNodeVMExtension> response = client.GetNodeExtension("<poolId>", "<nodeId>", "<extensionName>");
]]></code>
This sample shows how to call GetNodeExtension with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNodeVMExtension> response = client.GetNodeExtension("<poolId>", "<nodeId>", "<extensionName>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeExtensionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetNodeExtensionAsync (string poolId, string nodeId, string extensionName, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetNodeExtensionAsync(string poolId, string nodeId, string extensionName, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeExtensionAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeExtensionAsync (poolId As String, nodeId As String, extensionName As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeExtensionAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetNodeExtensionAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetNodeExtensionAsync (poolId, nodeId, extensionName, timeOutInSeconds, ocpdate, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="extensionName" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        <param name="extensionName"> The name of the Compute Node Extension that you want to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Compute Node Extension.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeExtensionAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="extensionName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="extensionName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeExtensionAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetNodeExtensionAsync("<poolId>", "<nodeId>", "<extensionName>", null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetNodeExtensionAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetNodeExtensionAsync("<poolId>", "<nodeId>", "<extensionName>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("provisioningState").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("typeHandlerVersion").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("autoUpgradeMinorVersion").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("enableAutomaticUpgrade").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("settings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("protectedSettings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("vmExtension").GetProperty("provisionAfterExtensions")[0].ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("displayStatus").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("level").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("time").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("displayStatus").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("level").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("time").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeExtensionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;&gt; GetNodeExtensionAsync (string poolId, string nodeId, string extensionName, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchNodeVMExtension&gt;&gt; GetNodeExtensionAsync(string poolId, string nodeId, string extensionName, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeExtensionAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeExtensionAsync (poolId As String, nodeId As String, extensionName As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchNodeVMExtension))" />
      <MemberSignature Language="F#" Value="abstract member GetNodeExtensionAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;&gt;&#xA;override this.GetNodeExtensionAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;&gt;" Usage="batchClient.GetNodeExtensionAsync (poolId, nodeId, extensionName, timeOutInSeconds, ocpdate, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="extensionName" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        <param name="extensionName"> The name of the Compute Node Extension that you want to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Compute Node Extension. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="extensionName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="extensionName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeExtensionAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNodeVMExtension> response = await client.GetNodeExtensionAsync("<poolId>", "<nodeId>", "<extensionName>");
]]></code>
This sample shows how to call GetNodeExtensionAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNodeVMExtension> response = await client.GetNodeExtensionAsync("<poolId>", "<nodeId>", "<extensionName>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" });
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeExtensions">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetNodeExtensions (string poolId, string nodeId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetNodeExtensions(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeExtensions(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeExtensions (poolId As String, nodeId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), select As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeExtensions : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetNodeExtensions : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetNodeExtensions (poolId, nodeId, timeOutInSeconds, ocpdate, maxresults, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the Compute Nodes Extensions in the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeExtensions(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeExtensions and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetNodeExtensions("<poolId>", "<nodeId>", null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetNodeExtensions with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetNodeExtensions("<poolId>", "<nodeId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, new string[] { "<select>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("provisioningState").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("displayStatus").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("level").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("time").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("displayStatus").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("level").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("time").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeExtensions">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt; GetNodeExtensions (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchNodeVMExtension&gt; GetNodeExtensions(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeExtensions(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeExtensions (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchNodeVMExtension)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeExtensions : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;&#xA;override this.GetNodeExtensions : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;" Usage="batchClient.GetNodeExtensions (poolId, nodeId, timeOutInSeconds, ocpdate, maxresults, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists the Compute Nodes Extensions in the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeExtensions.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchNodeVMExtension item in client.GetNodeExtensions("<poolId>", "<nodeId>"))
{
}
]]></code>
This sample shows how to call GetNodeExtensions with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchNodeVMExtension item in client.GetNodeExtensions("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, select: new string[] { "<select>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeExtensionsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetNodeExtensionsAsync (string poolId, string nodeId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetNodeExtensionsAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeExtensionsAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeExtensionsAsync (poolId As String, nodeId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), select As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeExtensionsAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetNodeExtensionsAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetNodeExtensionsAsync (poolId, nodeId, timeOutInSeconds, ocpdate, maxresults, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the Compute Nodes Extensions in the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeExtensionsAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeExtensionsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetNodeExtensionsAsync("<poolId>", "<nodeId>", null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetNodeExtensionsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetNodeExtensionsAsync("<poolId>", "<nodeId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, new string[] { "<select>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("provisioningState").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("vmExtension").GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("displayStatus").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("level").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("time").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("displayStatus").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("level").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("time").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeExtensionsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt; GetNodeExtensionsAsync (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchNodeVMExtension&gt; GetNodeExtensionsAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeExtensionsAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeExtensionsAsync (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchNodeVMExtension)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeExtensionsAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;&#xA;override this.GetNodeExtensionsAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;" Usage="batchClient.GetNodeExtensionsAsync (poolId, nodeId, timeOutInSeconds, ocpdate, maxresults, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeVMExtension&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists the Compute Nodes Extensions in the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeExtensionsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchNodeVMExtension item in client.GetNodeExtensionsAsync("<poolId>", "<nodeId>"))
{
}
]]></code>
This sample shows how to call GetNodeExtensionsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchNodeVMExtension item in client.GetNodeExtensionsAsync("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, select: new string[] { "<select>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetNodeFile (string poolId, string nodeId, string filePath, int? timeOutInSeconds, DateTimeOffset? ocpdate, string ocpRange, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetNodeFile(string poolId, string nodeId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, string ocpRange, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFile(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFile (poolId As String, nodeId As String, filePath As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), ocpRange As String, requestConditions As RequestConditions, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetNodeFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetNodeFile (poolId, nodeId, filePath, timeOutInSeconds, ocpdate, ocpRange, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="ocpRange" Type="System.String" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node. </param>
        <param name="filePath"> The path to the file or directory. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="ocpRange">
            The byte range to be retrieved. The default is to retrieve the entire file. The
            format is bytes=startRange-endRange.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Returns the content of the specified Compute Node file.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeFile(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeFile and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetNodeFile("<poolId>", "<nodeId>", "<filePath>", null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetNodeFile with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetNodeFile("<poolId>", "<nodeId>", "<filePath>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), "<ocp-range>", null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;BinaryData&gt; GetNodeFile (string poolId, string nodeId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, string ocpRange = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class System.BinaryData&gt; GetNodeFile(string poolId, string nodeId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, string ocpRange, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFile(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFile (poolId As String, nodeId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional ocpRange As String = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;BinaryData&gt;&#xA;override this.GetNodeFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;BinaryData&gt;" Usage="batchClient.GetNodeFile (poolId, nodeId, filePath, timeOutInSeconds, ocpdate, ocpRange, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="ocpRange" Type="System.String" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node. </param>
        <param name="filePath"> The path to the file or directory. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="ocpRange">
            The byte range to be retrieved. The default is to retrieve the entire file. The
            format is bytes=startRange-endRange.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Returns the content of the specified Compute Node file. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeFile.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BinaryData> response = client.GetNodeFile("<poolId>", "<nodeId>", "<filePath>");
]]></code>
This sample shows how to call GetNodeFile with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BinaryData> response = client.GetNodeFile("<poolId>", "<nodeId>", "<filePath>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), ocpRange: "<ocp-range>", requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetNodeFileAsync (string poolId, string nodeId, string filePath, int? timeOutInSeconds, DateTimeOffset? ocpdate, string ocpRange, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetNodeFileAsync(string poolId, string nodeId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, string ocpRange, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFileAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFileAsync (poolId As String, nodeId As String, filePath As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), ocpRange As String, requestConditions As RequestConditions, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetNodeFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetNodeFileAsync (poolId, nodeId, filePath, timeOutInSeconds, ocpdate, ocpRange, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="ocpRange" Type="System.String" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node. </param>
        <param name="filePath"> The path to the file or directory. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="ocpRange">
            The byte range to be retrieved. The default is to retrieve the entire file. The
            format is bytes=startRange-endRange.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Returns the content of the specified Compute Node file.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeFileAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeFileAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetNodeFileAsync("<poolId>", "<nodeId>", "<filePath>", null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetNodeFileAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetNodeFileAsync("<poolId>", "<nodeId>", "<filePath>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), "<ocp-range>", null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt; GetNodeFileAsync (string poolId, string nodeId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, string ocpRange = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class System.BinaryData&gt;&gt; GetNodeFileAsync(string poolId, string nodeId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, string ocpRange, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFileAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFileAsync (poolId As String, nodeId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional ocpRange As String = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BinaryData))" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt;&#xA;override this.GetNodeFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt;" Usage="batchClient.GetNodeFileAsync (poolId, nodeId, filePath, timeOutInSeconds, ocpdate, ocpRange, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;System.BinaryData&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="ocpRange" Type="System.String" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node. </param>
        <param name="filePath"> The path to the file or directory. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="ocpRange">
            The byte range to be retrieved. The default is to retrieve the entire file. The
            format is bytes=startRange-endRange.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Returns the content of the specified Compute Node file. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeFileAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BinaryData> response = await client.GetNodeFileAsync("<poolId>", "<nodeId>", "<filePath>");
]]></code>
This sample shows how to call GetNodeFileAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BinaryData> response = await client.GetNodeFileAsync("<poolId>", "<nodeId>", "<filePath>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), ocpRange: "<ocp-range>", requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFileProperties">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt; GetNodeFileProperties (string poolId, string nodeId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchFileProperties&gt; GetNodeFileProperties(string poolId, string nodeId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFileProperties(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFileProperties (poolId As String, nodeId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchFileProperties)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFileProperties : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&#xA;override this.GetNodeFileProperties : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;" Usage="batchClient.GetNodeFileProperties (poolId, nodeId, filePath, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node. </param>
        <param name="filePath"> The path to the file or directory. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Gets the properties of the specified Compute Node file.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFilePropertiesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&gt; GetNodeFilePropertiesAsync (string poolId, string nodeId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchFileProperties&gt;&gt; GetNodeFilePropertiesAsync(string poolId, string nodeId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFilePropertiesAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFilePropertiesAsync (poolId As String, nodeId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchFileProperties))" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFilePropertiesAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&gt;&#xA;override this.GetNodeFilePropertiesAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&gt;" Usage="batchClient.GetNodeFilePropertiesAsync (poolId, nodeId, filePath, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node. </param>
        <param name="filePath"> The path to the file or directory. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Gets the properties of the specified Compute Node file.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFiles">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetNodeFiles (string poolId, string nodeId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, bool? recursive, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetNodeFiles(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Nullable`1&lt;bool&gt; recursive, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFiles(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFiles (poolId As String, nodeId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, recursive As Nullable(Of Boolean), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFiles : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetNodeFiles : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetNodeFiles (poolId, nodeId, timeOutInSeconds, ocpdate, maxresults, filter, recursive, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
            </param>
        <param name="recursive"> Whether to list children of a directory. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the files in Task directories on the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeFiles(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeFiles and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetNodeFiles("<poolId>", "<nodeId>", null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetNodeFiles with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetNodeFiles("<poolId>", "<nodeId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", true, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("isDirectory").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("contentLength").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("fileMode").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFiles">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeFile&gt; GetNodeFiles (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, bool? recursive = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchNodeFile&gt; GetNodeFiles(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Nullable`1&lt;bool&gt; recursive, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFiles(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFiles (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional recursive As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchNodeFile)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFiles : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;&#xA;override this.GetNodeFiles : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;" Usage="batchClient.GetNodeFiles (poolId, nodeId, timeOutInSeconds, ocpdate, maxresults, filter, recursive, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
            </param>
        <param name="recursive"> Whether to list children of a directory. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeFiles.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchNodeFile item in client.GetNodeFiles("<poolId>", "<nodeId>"))
{
}
]]></code>
This sample shows how to call GetNodeFiles with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchNodeFile item in client.GetNodeFiles("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", recursive: true))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFilesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetNodeFilesAsync (string poolId, string nodeId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, bool? recursive, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetNodeFilesAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Nullable`1&lt;bool&gt; recursive, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFilesAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFilesAsync (poolId As String, nodeId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, recursive As Nullable(Of Boolean), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFilesAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetNodeFilesAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetNodeFilesAsync (poolId, nodeId, timeOutInSeconds, ocpdate, maxresults, filter, recursive, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
            </param>
        <param name="recursive"> Whether to list children of a directory. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the files in Task directories on the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeFilesAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeFilesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetNodeFilesAsync("<poolId>", "<nodeId>", null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetNodeFilesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetNodeFilesAsync("<poolId>", "<nodeId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", true, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("isDirectory").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("contentLength").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("fileMode").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeFilesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeFile&gt; GetNodeFilesAsync (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, bool? recursive = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchNodeFile&gt; GetNodeFilesAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Nullable`1&lt;bool&gt; recursive, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeFilesAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeFilesAsync (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional recursive As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchNodeFile)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeFilesAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;&#xA;override this.GetNodeFilesAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;" Usage="batchClient.GetNodeFilesAsync (poolId, nodeId, timeOutInSeconds, ocpdate, maxresults, filter, recursive, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
            </param>
        <param name="recursive"> Whether to list children of a directory. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeFilesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchNodeFile item in client.GetNodeFilesAsync("<poolId>", "<nodeId>"))
{
}
]]></code>
This sample shows how to call GetNodeFilesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchNodeFile item in client.GetNodeFilesAsync("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", recursive: true))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeRemoteLoginSettings">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetNodeRemoteLoginSettings (string poolId, string nodeId, int? timeOutInSeconds, DateTimeOffset? ocpdate, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetNodeRemoteLoginSettings(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeRemoteLoginSettings(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeRemoteLoginSettings (poolId As String, nodeId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetNodeRemoteLoginSettings : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetNodeRemoteLoginSettings : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetNodeRemoteLoginSettings (poolId, nodeId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the settings required for remote login to a Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeRemoteLoginSettings(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeRemoteLoginSettings and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetNodeRemoteLoginSettings("<poolId>", "<nodeId>", null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("remoteLoginIPAddress").ToString());
Console.WriteLine(result.GetProperty("remoteLoginPort").ToString());
]]></code>
This sample shows how to call GetNodeRemoteLoginSettings with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetNodeRemoteLoginSettings("<poolId>", "<nodeId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("remoteLoginIPAddress").ToString());
Console.WriteLine(result.GetProperty("remoteLoginPort").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeRemoteLoginSettings">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt; GetNodeRemoteLoginSettings (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt; GetNodeRemoteLoginSettings(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeRemoteLoginSettings(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeRemoteLoginSettings (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchNodeRemoteLoginSettings)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeRemoteLoginSettings : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt;&#xA;override this.GetNodeRemoteLoginSettings : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt;" Usage="batchClient.GetNodeRemoteLoginSettings (poolId, nodeId, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets the settings required for remote login to a Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>
            Before you can remotely login to a Compute Node using the remote login
            settings, you must create a user Account on the Compute Node. This API can be
            invoked only on Pools created with the virtual machine configuration property.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeRemoteLoginSettings.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNodeRemoteLoginSettings> response = client.GetNodeRemoteLoginSettings("<poolId>", "<nodeId>");
]]></code>
This sample shows how to call GetNodeRemoteLoginSettings with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNodeRemoteLoginSettings> response = client.GetNodeRemoteLoginSettings("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeRemoteLoginSettingsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetNodeRemoteLoginSettingsAsync (string poolId, string nodeId, int? timeOutInSeconds, DateTimeOffset? ocpdate, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetNodeRemoteLoginSettingsAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeRemoteLoginSettingsAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeRemoteLoginSettingsAsync (poolId As String, nodeId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetNodeRemoteLoginSettingsAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetNodeRemoteLoginSettingsAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetNodeRemoteLoginSettingsAsync (poolId, nodeId, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the settings required for remote login to a Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodeRemoteLoginSettingsAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodeRemoteLoginSettingsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetNodeRemoteLoginSettingsAsync("<poolId>", "<nodeId>", null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("remoteLoginIPAddress").ToString());
Console.WriteLine(result.GetProperty("remoteLoginPort").ToString());
]]></code>
This sample shows how to call GetNodeRemoteLoginSettingsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetNodeRemoteLoginSettingsAsync("<poolId>", "<nodeId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("remoteLoginIPAddress").ToString());
Console.WriteLine(result.GetProperty("remoteLoginPort").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodeRemoteLoginSettingsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt;&gt; GetNodeRemoteLoginSettingsAsync (string poolId, string nodeId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt;&gt; GetNodeRemoteLoginSettingsAsync(string poolId, string nodeId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodeRemoteLoginSettingsAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodeRemoteLoginSettingsAsync (poolId As String, nodeId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchNodeRemoteLoginSettings))" />
      <MemberSignature Language="F#" Value="abstract member GetNodeRemoteLoginSettingsAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt;&gt;&#xA;override this.GetNodeRemoteLoginSettingsAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt;&gt;" Usage="batchClient.GetNodeRemoteLoginSettingsAsync (poolId, nodeId, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchNodeRemoteLoginSettings&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets the settings required for remote login to a Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>
            Before you can remotely login to a Compute Node using the remote login
            settings, you must create a user Account on the Compute Node. This API can be
            invoked only on Pools created with the virtual machine configuration property.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodeRemoteLoginSettingsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNodeRemoteLoginSettings> response = await client.GetNodeRemoteLoginSettingsAsync("<poolId>", "<nodeId>");
]]></code>
This sample shows how to call GetNodeRemoteLoginSettingsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchNodeRemoteLoginSettings> response = await client.GetNodeRemoteLoginSettingsAsync("<poolId>", "<nodeId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodes">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetNodes (string poolId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetNodes(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodes(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodes (poolId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetNodes : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetNodes : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetNodes (poolId, timeOutInSeconds, ocpdate, maxresults, filter, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the Compute Nodes in the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodes(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodes and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetNodes("<poolId>", null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetNodes with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetNodes("<poolId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("schedulingState").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("lastBootTime").ToString());
    Console.WriteLine(result.GetProperty("allocationTime").ToString());
    Console.WriteLine(result.GetProperty("ipAddress").ToString());
    Console.WriteLine(result.GetProperty("affinityId").ToString());
    Console.WriteLine(result.GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("totalTasksRun").ToString());
    Console.WriteLine(result.GetProperty("runningTasksCount").ToString());
    Console.WriteLine(result.GetProperty("runningTaskSlotsCount").ToString());
    Console.WriteLine(result.GetProperty("totalTasksSucceeded").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskUrl").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("jobId").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskId").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("subtaskId").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskState").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("retryCount").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("lastRetryTime").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("requeueCount").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("lastRequeueTime").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("result").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("retryCount").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("lastRetryTime").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("result").ToString());
    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("errorDetails")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("errorDetails")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("isDedicated").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("publicIPAddress").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("publicFQDN").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("frontendPort").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("nodeAgentInfo").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("nodeAgentInfo").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("scaleSetVmResourceId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodes">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchNode&gt; GetNodes (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchNode&gt; GetNodes(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodes(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodes (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchNode)" />
      <MemberSignature Language="F#" Value="abstract member GetNodes : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchNode&gt;&#xA;override this.GetNodes : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchNode&gt;" Usage="batchClient.GetNodes (poolId, timeOutInSeconds, ocpdate, maxresults, filter, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists the Compute Nodes in the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodes.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchNode item in client.GetNodes("<poolId>"))
{
}
]]></code>
This sample shows how to call GetNodes with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchNode item in client.GetNodes("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetNodesAsync (string poolId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetNodesAsync(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodesAsync (poolId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetNodesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetNodesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetNodesAsync (poolId, timeOutInSeconds, ocpdate, maxresults, filter, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the Compute Nodes in the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetNodesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetNodesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetNodesAsync("<poolId>", null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetNodesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetNodesAsync("<poolId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("schedulingState").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("lastBootTime").ToString());
    Console.WriteLine(result.GetProperty("allocationTime").ToString());
    Console.WriteLine(result.GetProperty("ipAddress").ToString());
    Console.WriteLine(result.GetProperty("affinityId").ToString());
    Console.WriteLine(result.GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("totalTasksRun").ToString());
    Console.WriteLine(result.GetProperty("runningTasksCount").ToString());
    Console.WriteLine(result.GetProperty("runningTaskSlotsCount").ToString());
    Console.WriteLine(result.GetProperty("totalTasksSucceeded").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskUrl").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("jobId").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskId").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("subtaskId").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("taskState").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("retryCount").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("lastRetryTime").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("requeueCount").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("lastRequeueTime").ToString());
    Console.WriteLine(result.GetProperty("recentTasks")[0].GetProperty("executionInfo").GetProperty("result").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("retryCount").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("lastRetryTime").ToString());
    Console.WriteLine(result.GetProperty("startTaskInfo").GetProperty("result").ToString());
    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("errorDetails")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("errorDetails")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("isDedicated").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("publicIPAddress").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("publicFQDN").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("frontendPort").ToString());
    Console.WriteLine(result.GetProperty("endpointConfiguration").GetProperty("inboundEndpoints")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("nodeAgentInfo").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("nodeAgentInfo").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineInfo").GetProperty("scaleSetVmResourceId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetNodesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNode&gt; GetNodesAsync (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchNode&gt; GetNodesAsync(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetNodesAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNodesAsync (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchNode)" />
      <MemberSignature Language="F#" Value="abstract member GetNodesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNode&gt;&#xA;override this.GetNodesAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNode&gt;" Usage="batchClient.GetNodesAsync (poolId, timeOutInSeconds, ocpdate, maxresults, filter, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists the Compute Nodes in the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetNodesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchNode item in client.GetNodesAsync("<poolId>"))
{
}
]]></code>
This sample shows how to call GetNodesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchNode item in client.GetNodesAsync("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetPool (string poolId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetPool(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPool(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPool (poolId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), expand As IEnumerable(Of String), requestConditions As RequestConditions, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetPool : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetPool : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetPool (poolId, timeOutInSeconds, ocpdate, select, expand, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetPool(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetPool and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetPool("<poolId>", null, null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetPool with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetPool("<poolId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, new string[] { "<expand>" }, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("creationTime").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("allocationState").ToString());
Console.WriteLine(result.GetProperty("allocationStateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("vmSize").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("resizeTimeout").ToString());
Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("values")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("values")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("resourceTags").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("currentDedicatedNodes").ToString());
Console.WriteLine(result.GetProperty("currentLowPriorityNodes").ToString());
Console.WriteLine(result.GetProperty("targetDedicatedNodes").ToString());
Console.WriteLine(result.GetProperty("targetLowPriorityNodes").ToString());
Console.WriteLine(result.GetProperty("enableAutoScale").ToString());
Console.WriteLine(result.GetProperty("autoScaleFormula").ToString());
Console.WriteLine(result.GetProperty("autoScaleEvaluationInterval").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("timestamp").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("results").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("values")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("values")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("enableInterNodeCommunication").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("taskSlotsPerNode").ToString());
Console.WriteLine(result.GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("dedicatedCoreTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgCPUPercentage").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgMemoryGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("peakMemoryGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgDiskGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("peakDiskGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskReadIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskWriteIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskReadGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskWriteGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("networkReadGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("networkWriteGiB").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("identity").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("clientId").ToString());
Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("principalId").ToString());
Console.WriteLine(result.GetProperty("targetNodeCommunicationMode").ToString());
Console.WriteLine(result.GetProperty("currentNodeCommunicationMode").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchPool&gt; GetPool (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchPool&gt; GetPool(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPool(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPool (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchPool)" />
      <MemberSignature Language="F#" Value="abstract member GetPool : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchPool&gt;&#xA;override this.GetPool : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchPool&gt;" Usage="batchClient.GetPool (poolId, timeOutInSeconds, ocpdate, select, expand, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchPool&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetPool.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchPool> response = client.GetPool("<poolId>");
]]></code>
This sample shows how to call GetPool with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchPool> response = client.GetPool("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }, expand: new string[] { "<expand>" }, requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetPoolAsync (string poolId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetPoolAsync(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolAsync (poolId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), expand As IEnumerable(Of String), requestConditions As RequestConditions, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetPoolAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetPoolAsync (poolId, timeOutInSeconds, ocpdate, select, expand, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetPoolAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetPoolAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetPoolAsync("<poolId>", null, null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetPoolAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetPoolAsync("<poolId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, new string[] { "<expand>" }, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("creationTime").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("allocationState").ToString());
Console.WriteLine(result.GetProperty("allocationStateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("vmSize").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("resizeTimeout").ToString());
Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("values")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("values")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("resourceTags").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("currentDedicatedNodes").ToString());
Console.WriteLine(result.GetProperty("currentLowPriorityNodes").ToString());
Console.WriteLine(result.GetProperty("targetDedicatedNodes").ToString());
Console.WriteLine(result.GetProperty("targetLowPriorityNodes").ToString());
Console.WriteLine(result.GetProperty("enableAutoScale").ToString());
Console.WriteLine(result.GetProperty("autoScaleFormula").ToString());
Console.WriteLine(result.GetProperty("autoScaleEvaluationInterval").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("timestamp").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("results").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("values")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("values")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("enableInterNodeCommunication").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("startTask").GetProperty("waitForSuccess").ToString());
Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("taskSlotsPerNode").ToString());
Console.WriteLine(result.GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("dedicatedCoreTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgCPUPercentage").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgMemoryGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("peakMemoryGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgDiskGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("peakDiskGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskReadIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskWriteIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskReadGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskWriteGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("networkReadGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("networkWriteGiB").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
Console.WriteLine(result.GetProperty("identity").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("clientId").ToString());
Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("principalId").ToString());
Console.WriteLine(result.GetProperty("targetNodeCommunicationMode").ToString());
Console.WriteLine(result.GetProperty("currentNodeCommunicationMode").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchPool&gt;&gt; GetPoolAsync (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchPool&gt;&gt; GetPoolAsync(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolAsync (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchPool))" />
      <MemberSignature Language="F#" Value="abstract member GetPoolAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchPool&gt;&gt;&#xA;override this.GetPoolAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchPool&gt;&gt;" Usage="batchClient.GetPoolAsync (poolId, timeOutInSeconds, ocpdate, select, expand, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchPool&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetPoolAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchPool> response = await client.GetPoolAsync("<poolId>");
]]></code>
This sample shows how to call GetPoolAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchPool> response = await client.GetPoolAsync("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }, expand: new string[] { "<expand>" }, requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolNodeCounts">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetPoolNodeCounts (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetPoolNodeCounts(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolNodeCounts(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolNodeCounts (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolNodeCounts : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetPoolNodeCounts : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetPoolNodeCounts (timeOutInSeconds, ocpdate, maxresults, filter, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
            numbers returned may not always be up to date. If you need exact node counts,
            use a list query.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetPoolNodeCounts(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetPoolNodeCounts and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetPoolNodeCounts(null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
}
]]></code>
This sample shows how to call GetPoolNodeCounts with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetPoolNodeCounts(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("creating").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("idle").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("offline").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("preempted").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("rebooting").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("reimaging").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("running").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("starting").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("startTaskFailed").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("leavingPool").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("unknown").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("unusable").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("waitingForStartTask").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("total").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("upgradingOS").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("creating").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("idle").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("offline").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("preempted").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("rebooting").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("reimaging").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("running").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("starting").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("startTaskFailed").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("leavingPool").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("unknown").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("unusable").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("waitingForStartTask").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("total").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("upgradingOS").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolNodeCounts">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchPoolNodeCounts&gt; GetPoolNodeCounts (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchPoolNodeCounts&gt; GetPoolNodeCounts(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolNodeCounts(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolNodeCounts (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchPoolNodeCounts)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolNodeCounts : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchPoolNodeCounts&gt;&#xA;override this.GetPoolNodeCounts : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchPoolNodeCounts&gt;" Usage="batchClient.GetPoolNodeCounts (timeOutInSeconds, ocpdate, maxresults, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchPoolNodeCounts&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
            numbers returned may not always be up to date. If you need exact node counts,
            use a list query.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetPoolNodeCounts.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchPoolNodeCounts item in client.GetPoolNodeCounts())
{
}
]]></code>
This sample shows how to call GetPoolNodeCounts with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchPoolNodeCounts item in client.GetPoolNodeCounts(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>"))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolNodeCountsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetPoolNodeCountsAsync (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetPoolNodeCountsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolNodeCountsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolNodeCountsAsync (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolNodeCountsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetPoolNodeCountsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetPoolNodeCountsAsync (timeOutInSeconds, ocpdate, maxresults, filter, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
            numbers returned may not always be up to date. If you need exact node counts,
            use a list query.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetPoolNodeCountsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetPoolNodeCountsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetPoolNodeCountsAsync(null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
}
]]></code>
This sample shows how to call GetPoolNodeCountsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetPoolNodeCountsAsync(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("creating").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("idle").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("offline").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("preempted").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("rebooting").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("reimaging").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("running").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("starting").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("startTaskFailed").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("leavingPool").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("unknown").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("unusable").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("waitingForStartTask").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("total").ToString());
    Console.WriteLine(result.GetProperty("dedicated").GetProperty("upgradingOS").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("creating").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("idle").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("offline").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("preempted").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("rebooting").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("reimaging").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("running").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("starting").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("startTaskFailed").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("leavingPool").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("unknown").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("unusable").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("waitingForStartTask").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("total").ToString());
    Console.WriteLine(result.GetProperty("lowPriority").GetProperty("upgradingOS").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolNodeCountsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPoolNodeCounts&gt; GetPoolNodeCountsAsync (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchPoolNodeCounts&gt; GetPoolNodeCountsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolNodeCountsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolNodeCountsAsync (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchPoolNodeCounts)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolNodeCountsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPoolNodeCounts&gt;&#xA;override this.GetPoolNodeCountsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPoolNodeCounts&gt;" Usage="batchClient.GetPoolNodeCountsAsync (timeOutInSeconds, ocpdate, maxresults, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPoolNodeCounts&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
            numbers returned may not always be up to date. If you need exact node counts,
            use a list query.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetPoolNodeCountsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchPoolNodeCounts item in client.GetPoolNodeCountsAsync())
{
}
]]></code>
This sample shows how to call GetPoolNodeCountsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchPoolNodeCounts item in client.GetPoolNodeCountsAsync(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>"))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPools">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetPools (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetPools(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPools(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPools (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetPools : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetPools : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetPools (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the Pools in the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetPools(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetPools and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetPools(null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetPools with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetPools(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("allocationState").ToString());
    Console.WriteLine(result.GetProperty("allocationStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("resizeTimeout").ToString());
    Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("values")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("values")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("resourceTags").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("currentDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("currentLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("targetDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("targetLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("enableAutoScale").ToString());
    Console.WriteLine(result.GetProperty("autoScaleFormula").ToString());
    Console.WriteLine(result.GetProperty("autoScaleEvaluationInterval").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("timestamp").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("results").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("values")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("values")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("enableInterNodeCommunication").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("taskSlotsPerNode").ToString());
    Console.WriteLine(result.GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("dedicatedCoreTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgCPUPercentage").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgMemoryGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("peakMemoryGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgDiskGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("peakDiskGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskReadIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskWriteIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskReadGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskWriteGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("networkReadGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("networkWriteGiB").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("identity").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("clientId").ToString());
    Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("principalId").ToString());
    Console.WriteLine(result.GetProperty("targetNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("currentNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("mode").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPools">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchPool&gt; GetPools (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchPool&gt; GetPools(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPools(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPools (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchPool)" />
      <MemberSignature Language="F#" Value="abstract member GetPools : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchPool&gt;&#xA;override this.GetPools : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchPool&gt;" Usage="batchClient.GetPools (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchPool&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the Pools in the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetPools.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchPool item in client.GetPools())
{
}
]]></code>
This sample shows how to call GetPools with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchPool item in client.GetPools(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetPoolsAsync (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetPoolsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolsAsync (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetPoolsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetPoolsAsync (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the Pools in the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetPoolsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetPoolsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetPoolsAsync(null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetPoolsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetPoolsAsync(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("allocationState").ToString());
    Console.WriteLine(result.GetProperty("allocationStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("windowsConfiguration").GetProperty("enableAutomaticUpdates").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("lun").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("dataDisks")[0].GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("licenseType").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerImageNames")[0].ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("containerConfiguration").GetProperty("containerRegistries")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("diskEncryptionConfiguration").GetProperty("targets")[0].ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("nodePlacementConfiguration").GetProperty("policy").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("typeHandlerVersion").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("autoUpgradeMinorVersion").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("enableAutomaticUpgrade").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("settings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("protectedSettings").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("extensions")[0].GetProperty("provisionAfterExtensions")[0].ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("ephemeralOSDiskSettings").GetProperty("placement").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("caching").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("diskSizeGB").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("managedDisk").GetProperty("storageAccountType").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("osDisk").GetProperty("writeAcceleratorEnabled").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("encryptionAtHost").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("securityType").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("secureBootEnabled").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("securityProfile").GetProperty("uefiSettings").GetProperty("vTpmEnabled").ToString());
    Console.WriteLine(result.GetProperty("virtualMachineConfiguration").GetProperty("serviceArtifactReference").GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("resizeTimeout").ToString());
    Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("values")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("resizeErrors")[0].GetProperty("values")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("resourceTags").GetProperty("<key>").ToString());
    Console.WriteLine(result.GetProperty("currentDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("currentLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("targetDedicatedNodes").ToString());
    Console.WriteLine(result.GetProperty("targetLowPriorityNodes").ToString());
    Console.WriteLine(result.GetProperty("enableAutoScale").ToString());
    Console.WriteLine(result.GetProperty("autoScaleFormula").ToString());
    Console.WriteLine(result.GetProperty("autoScaleEvaluationInterval").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("timestamp").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("results").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("values")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("autoScaleRun").GetProperty("error").GetProperty("values")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("enableInterNodeCommunication").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("subnetId").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("dynamicVNetAssignmentScope").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("protocol").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("backendPort").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeStart").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("frontendPortRangeEnd").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("priority").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("access").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourceAddressPrefix").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("endpointConfiguration").GetProperty("inboundNATPools")[0].GetProperty("networkSecurityGroupRules")[0].GetProperty("sourcePortRanges")[0].ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("provision").ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("publicIPAddressConfiguration").GetProperty("ipAddressIds")[0].ToString());
    Console.WriteLine(result.GetProperty("networkConfiguration").GetProperty("enableAcceleratedNetworking").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("startTask").GetProperty("waitForSuccess").ToString());
    Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("taskSlotsPerNode").ToString());
    Console.WriteLine(result.GetProperty("taskSchedulingPolicy").GetProperty("nodeFillType").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("uid").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("gid").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("linuxUserConfiguration").GetProperty("sshPrivateKey").ToString());
    Console.WriteLine(result.GetProperty("userAccounts")[0].GetProperty("windowsUserConfiguration").GetProperty("loginMode").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("metadata")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("usageStats").GetProperty("dedicatedCoreTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgCPUPercentage").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgMemoryGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("peakMemoryGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("avgDiskGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("peakDiskGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskReadIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskWriteIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskReadGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("diskWriteGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("networkReadGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("resourceStats").GetProperty("networkWriteGiB").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("containerName").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("sasKey").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("blobfuseOptions").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureBlobFileSystemConfiguration").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("nfsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("source").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("cifsMountConfiguration").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountName").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("azureFileUrl").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("accountKey").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("relativeMountPath").ToString());
    Console.WriteLine(result.GetProperty("mountConfiguration")[0].GetProperty("azureFileShareConfiguration").GetProperty("mountOptions").ToString());
    Console.WriteLine(result.GetProperty("identity").GetProperty("type").ToString());
    Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("clientId").ToString());
    Console.WriteLine(result.GetProperty("identity").GetProperty("userAssignedIdentities")[0].GetProperty("principalId").ToString());
    Console.WriteLine(result.GetProperty("targetNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("currentNodeCommunicationMode").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("mode").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("disableAutomaticRollback").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("enableAutomaticOSUpgrade").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("useRollingUpgradePolicy").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("automaticOSUpgradePolicy").GetProperty("osRollingUpgradeDeferral").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("enableCrossZoneUpgrade").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxBatchInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("maxUnhealthyUpgradedInstancePercent").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("pauseTimeBetweenBatches").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("prioritizeUnhealthyInstances").ToString());
    Console.WriteLine(result.GetProperty("upgradePolicy").GetProperty("rollingUpgradePolicy").GetProperty("rollbackFailedInstancesOnPolicyBreach").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPool&gt; GetPoolsAsync (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchPool&gt; GetPoolsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolsAsync (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchPool)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPool&gt;&#xA;override this.GetPoolsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPool&gt;" Usage="batchClient.GetPoolsAsync (timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPool&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the Pools in the specified Account. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetPoolsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchPool item in client.GetPoolsAsync())
{
}
]]></code>
This sample shows how to call GetPoolsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchPool item in client.GetPoolsAsync(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolUsageMetrics">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetPoolUsageMetrics (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, DateTimeOffset? starttime, DateTimeOffset? endtime, string filter, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetPoolUsageMetrics(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; starttime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; endtime, string filter, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolUsageMetrics(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolUsageMetrics (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), starttime As Nullable(Of DateTimeOffset), endtime As Nullable(Of DateTimeOffset), filter As String, context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolUsageMetrics : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetPoolUsageMetrics : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetPoolUsageMetrics (timeOutInSeconds, ocpdate, maxresults, starttime, endtime, filter, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="starttime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="endtime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="starttime">
            The earliest time from which to include metrics. This must be at least two and
            a half hours before the current time. If not specified this defaults to the
            start time of the last aggregation interval currently available.
            </param>
        <param name="endtime">
            The latest time from which to include metrics. This must be at least two hours
            before the current time. If not specified this defaults to the end time of the
            last aggregation interval currently available.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the usage metrics, aggregated by Pool across individual time intervals,
            for the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetPoolUsageMetrics(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetPoolUsageMetrics and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetPoolUsageMetrics(null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("totalCoreHours").ToString());
}
]]></code>
This sample shows how to call GetPoolUsageMetrics with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetPoolUsageMetrics(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"), DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"), "<filter>", null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("totalCoreHours").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolUsageMetrics">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchPoolUsageMetrics&gt; GetPoolUsageMetrics (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, DateTimeOffset? starttime = default, DateTimeOffset? endtime = default, string filter = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchPoolUsageMetrics&gt; GetPoolUsageMetrics(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; starttime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; endtime, string filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolUsageMetrics(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolUsageMetrics (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional starttime As Nullable(Of DateTimeOffset) = Nothing, Optional endtime As Nullable(Of DateTimeOffset) = Nothing, Optional filter As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchPoolUsageMetrics)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolUsageMetrics : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchPoolUsageMetrics&gt;&#xA;override this.GetPoolUsageMetrics : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchPoolUsageMetrics&gt;" Usage="batchClient.GetPoolUsageMetrics (timeOutInSeconds, ocpdate, maxresults, starttime, endtime, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchPoolUsageMetrics&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="starttime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="endtime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="starttime">
            The earliest time from which to include metrics. This must be at least two and
            a half hours before the current time. If not specified this defaults to the
            start time of the last aggregation interval currently available.
            </param>
        <param name="endtime">
            The latest time from which to include metrics. This must be at least two hours
            before the current time. If not specified this defaults to the end time of the
            last aggregation interval currently available.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Lists the usage metrics, aggregated by Pool across individual time intervals,
            for the specified Account.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            If you do not specify a $filter clause including a poolId, the response
            includes all Pools that existed in the Account in the time range of the
            returned aggregation intervals. If you do not specify a $filter clause
            including a startTime or endTime these filters default to the start and end
            times of the last aggregation interval currently available; that is, only the
            last aggregation interval is returned.
            </remarks>
        <example>
This sample shows how to call GetPoolUsageMetrics.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchPoolUsageMetrics item in client.GetPoolUsageMetrics())
{
}
]]></code>
This sample shows how to call GetPoolUsageMetrics with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchPoolUsageMetrics item in client.GetPoolUsageMetrics(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, starttime: DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"), endtime: DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"), filter: "<filter>"))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolUsageMetricsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetPoolUsageMetricsAsync (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, DateTimeOffset? starttime, DateTimeOffset? endtime, string filter, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetPoolUsageMetricsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; starttime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; endtime, string filter, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolUsageMetricsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolUsageMetricsAsync (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), starttime As Nullable(Of DateTimeOffset), endtime As Nullable(Of DateTimeOffset), filter As String, context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolUsageMetricsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetPoolUsageMetricsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetPoolUsageMetricsAsync (timeOutInSeconds, ocpdate, maxresults, starttime, endtime, filter, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="starttime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="endtime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="starttime">
            The earliest time from which to include metrics. This must be at least two and
            a half hours before the current time. If not specified this defaults to the
            start time of the last aggregation interval currently available.
            </param>
        <param name="endtime">
            The latest time from which to include metrics. This must be at least two hours
            before the current time. If not specified this defaults to the end time of the
            last aggregation interval currently available.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the usage metrics, aggregated by Pool across individual time intervals,
            for the specified Account.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetPoolUsageMetricsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetPoolUsageMetricsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetPoolUsageMetricsAsync(null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("totalCoreHours").ToString());
}
]]></code>
This sample shows how to call GetPoolUsageMetricsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetPoolUsageMetricsAsync(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"), DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"), "<filter>", null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("vmSize").ToString());
    Console.WriteLine(result.GetProperty("totalCoreHours").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetPoolUsageMetricsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPoolUsageMetrics&gt; GetPoolUsageMetricsAsync (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, DateTimeOffset? starttime = default, DateTimeOffset? endtime = default, string filter = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchPoolUsageMetrics&gt; GetPoolUsageMetricsAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; starttime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; endtime, string filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetPoolUsageMetricsAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPoolUsageMetricsAsync (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional starttime As Nullable(Of DateTimeOffset) = Nothing, Optional endtime As Nullable(Of DateTimeOffset) = Nothing, Optional filter As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchPoolUsageMetrics)" />
      <MemberSignature Language="F#" Value="abstract member GetPoolUsageMetricsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPoolUsageMetrics&gt;&#xA;override this.GetPoolUsageMetricsAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPoolUsageMetrics&gt;" Usage="batchClient.GetPoolUsageMetricsAsync (timeOutInSeconds, ocpdate, maxresults, starttime, endtime, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchPoolUsageMetrics&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="starttime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="endtime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="starttime">
            The earliest time from which to include metrics. This must be at least two and
            a half hours before the current time. If not specified this defaults to the
            start time of the last aggregation interval currently available.
            </param>
        <param name="endtime">
            The latest time from which to include metrics. This must be at least two hours
            before the current time. If not specified this defaults to the end time of the
            last aggregation interval currently available.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Lists the usage metrics, aggregated by Pool across individual time intervals,
            for the specified Account.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            If you do not specify a $filter clause including a poolId, the response
            includes all Pools that existed in the Account in the time range of the
            returned aggregation intervals. If you do not specify a $filter clause
            including a startTime or endTime these filters default to the start and end
            times of the last aggregation interval currently available; that is, only the
            last aggregation interval is returned.
            </remarks>
        <example>
This sample shows how to call GetPoolUsageMetricsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchPoolUsageMetrics item in client.GetPoolUsageMetricsAsync())
{
}
]]></code>
This sample shows how to call GetPoolUsageMetricsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchPoolUsageMetrics item in client.GetPoolUsageMetricsAsync(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, starttime: DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"), endtime: DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"), filter: "<filter>"))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetSubTasks">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetSubTasks (string jobId, string taskId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetSubTasks(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetSubTasks(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSubTasks (jobId As String, taskId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetSubTasks : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetSubTasks : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetSubTasks (jobId, taskId, timeOutInSeconds, ocpdate, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="taskId"> The ID of the Task. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the subtasks that are associated with the specified multi-instance
            Task.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetSubTasks(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetSubTasks and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetSubTasks("<jobId>", "<taskId>", null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetSubTasks with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetSubTasks("<jobId>", "<taskId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("affinityId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeUrl").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectory").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectoryUrl").ToString());
    Console.WriteLine(result.GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("result").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetSubTasks">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchSubtask&gt; GetSubTasks (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchSubtask&gt; GetSubTasks(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetSubTasks(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSubTasks (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchSubtask)" />
      <MemberSignature Language="F#" Value="abstract member GetSubTasks : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchSubtask&gt;&#xA;override this.GetSubTasks : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchSubtask&gt;" Usage="batchClient.GetSubTasks (jobId, taskId, timeOutInSeconds, ocpdate, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchSubtask&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="taskId"> The ID of the Task. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Lists all of the subtasks that are associated with the specified multi-instance
            Task.
            </summary>
        <returns>To be added.</returns>
        <remarks> If the Task is not a multi-instance Task then this returns an empty collection. </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetSubTasks.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchSubtask item in client.GetSubTasks("<jobId>", "<taskId>"))
{
}
]]></code>
This sample shows how to call GetSubTasks with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchSubtask item in client.GetSubTasks("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetSubTasksAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetSubTasksAsync (string jobId, string taskId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetSubTasksAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetSubTasksAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSubTasksAsync (jobId As String, taskId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetSubTasksAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetSubTasksAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetSubTasksAsync (jobId, taskId, timeOutInSeconds, ocpdate, select, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="taskId"> The ID of the Task. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the subtasks that are associated with the specified multi-instance
            Task.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetSubTasksAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetSubTasksAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetSubTasksAsync("<jobId>", "<taskId>", null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetSubTasksAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetSubTasksAsync("<jobId>", "<taskId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("affinityId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeUrl").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectory").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectoryUrl").ToString());
    Console.WriteLine(result.GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("result").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetSubTasksAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchSubtask&gt; GetSubTasksAsync (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchSubtask&gt; GetSubTasksAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetSubTasksAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSubTasksAsync (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchSubtask)" />
      <MemberSignature Language="F#" Value="abstract member GetSubTasksAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchSubtask&gt;&#xA;override this.GetSubTasksAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchSubtask&gt;" Usage="batchClient.GetSubTasksAsync (jobId, taskId, timeOutInSeconds, ocpdate, select, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchSubtask&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="taskId"> The ID of the Task. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Lists all of the subtasks that are associated with the specified multi-instance
            Task.
            </summary>
        <returns>To be added.</returns>
        <remarks> If the Task is not a multi-instance Task then this returns an empty collection. </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetSubTasksAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchSubtask item in client.GetSubTasksAsync("<jobId>", "<taskId>"))
{
}
]]></code>
This sample shows how to call GetSubTasksAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchSubtask item in client.GetSubTasksAsync("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetSupportedImages">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetSupportedImages (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetSupportedImages(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetSupportedImages(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSupportedImages (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetSupportedImages : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetSupportedImages : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetSupportedImages (timeOutInSeconds, ocpdate, maxresults, filter, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all Virtual Machine Images supported by the Azure Batch service.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetSupportedImages(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetSupportedImages and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetSupportedImages(null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("imageReference").ToString());
    Console.WriteLine(result.GetProperty("osType").ToString());
    Console.WriteLine(result.GetProperty("verificationType").ToString());
}
]]></code>
This sample shows how to call GetSupportedImages with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetSupportedImages(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("osType").ToString());
    Console.WriteLine(result.GetProperty("capabilities")[0].ToString());
    Console.WriteLine(result.GetProperty("batchSupportEndOfLife").ToString());
    Console.WriteLine(result.GetProperty("verificationType").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetSupportedImages">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchSupportedImage&gt; GetSupportedImages (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchSupportedImage&gt; GetSupportedImages(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetSupportedImages(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSupportedImages (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchSupportedImage)" />
      <MemberSignature Language="F#" Value="abstract member GetSupportedImages : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchSupportedImage&gt;&#xA;override this.GetSupportedImages : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchSupportedImage&gt;" Usage="batchClient.GetSupportedImages (timeOutInSeconds, ocpdate, maxresults, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchSupportedImage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all Virtual Machine Images supported by the Azure Batch service. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetSupportedImages.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchSupportedImage item in client.GetSupportedImages())
{
}
]]></code>
This sample shows how to call GetSupportedImages with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchSupportedImage item in client.GetSupportedImages(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>"))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetSupportedImagesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetSupportedImagesAsync (int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetSupportedImagesAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetSupportedImagesAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSupportedImagesAsync (timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetSupportedImagesAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetSupportedImagesAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetSupportedImagesAsync (timeOutInSeconds, ocpdate, maxresults, filter, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all Virtual Machine Images supported by the Azure Batch service.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetSupportedImagesAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetSupportedImagesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetSupportedImagesAsync(null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("imageReference").ToString());
    Console.WriteLine(result.GetProperty("osType").ToString());
    Console.WriteLine(result.GetProperty("verificationType").ToString());
}
]]></code>
This sample shows how to call GetSupportedImagesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetSupportedImagesAsync(1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("nodeAgentSKUId").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("publisher").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("offer").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("sku").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("virtualMachineImageId").ToString());
    Console.WriteLine(result.GetProperty("imageReference").GetProperty("exactVersion").ToString());
    Console.WriteLine(result.GetProperty("osType").ToString());
    Console.WriteLine(result.GetProperty("capabilities")[0].ToString());
    Console.WriteLine(result.GetProperty("batchSupportEndOfLife").ToString());
    Console.WriteLine(result.GetProperty("verificationType").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetSupportedImagesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchSupportedImage&gt; GetSupportedImagesAsync (int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchSupportedImage&gt; GetSupportedImagesAsync(valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetSupportedImagesAsync(System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSupportedImagesAsync (Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchSupportedImage)" />
      <MemberSignature Language="F#" Value="abstract member GetSupportedImagesAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchSupportedImage&gt;&#xA;override this.GetSupportedImagesAsync : Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchSupportedImage&gt;" Usage="batchClient.GetSupportedImagesAsync (timeOutInSeconds, ocpdate, maxresults, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchSupportedImage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all Virtual Machine Images supported by the Azure Batch service. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetSupportedImagesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchSupportedImage item in client.GetSupportedImagesAsync())
{
}
]]></code>
This sample shows how to call GetSupportedImagesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchSupportedImage item in client.GetSupportedImagesAsync(timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>"))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTask (string jobId, string taskId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTask(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTask(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTask (jobId As String, taskId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), expand As IEnumerable(Of String), requestConditions As RequestConditions, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetTask (jobId, taskId, timeOutInSeconds, ocpdate, select, expand, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Task.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetTask(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTask and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetTask("<jobId>", "<taskId>", null, null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTask with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetTask("<jobId>", "<taskId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, new string[] { "<expand>" }, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("creationTime").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("exitOptions").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("exitOptions").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("start").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("end").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("exitOptions").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("exitOptions").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("preProcessingError").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("preProcessingError").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("fileUploadError").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("fileUploadError").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("default").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("default").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("previousState").ToString());
Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
Console.WriteLine(result.GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("affinityInfo").GetProperty("affinityId").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("requiredSlots").ToString());
Console.WriteLine(result.GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("exitCode").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("retryCount").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("lastRetryTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("requeueCount").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("lastRequeueTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("affinityId").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeUrl").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("poolId").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeId").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectory").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectoryUrl").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("numberOfInstances").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("coordinationCommandLine").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIds")[0].ToString());
Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIdRanges")[0].GetProperty("start").ToString());
Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIdRanges")[0].GetProperty("end").ToString());
Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchTask&gt; GetTask (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchTask&gt; GetTask(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTask(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTask (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchTask)" />
      <MemberSignature Language="F#" Value="abstract member GetTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchTask&gt;&#xA;override this.GetTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchTask&gt;" Usage="batchClient.GetTask (jobId, taskId, timeOutInSeconds, ocpdate, select, expand, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchTask&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Task. </summary>
        <returns>To be added.</returns>
        <remarks>
            For multi-instance Tasks, information such as affinityId, executionInfo and
            nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
            information about subtasks.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTask.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchTask> response = client.GetTask("<jobId>", "<taskId>");
]]></code>
This sample shows how to call GetTask with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchTask> response = client.GetTask("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }, expand: new string[] { "<expand>" }, requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTaskAsync (string jobId, string taskId, int? timeOutInSeconds, DateTimeOffset? ocpdate, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTaskAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskAsync (jobId As String, taskId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), select As IEnumerable(Of String), expand As IEnumerable(Of String), requestConditions As RequestConditions, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetTaskAsync (jobId, taskId, timeOutInSeconds, ocpdate, select, expand, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets information about the specified Task.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetTaskAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTaskAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetTaskAsync("<jobId>", "<taskId>", null, null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTaskAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetTaskAsync("<jobId>", "<taskId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), new string[] { "<select>" }, new string[] { "<expand>" }, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("eTag").ToString());
Console.WriteLine(result.GetProperty("lastModified").ToString());
Console.WriteLine(result.GetProperty("creationTime").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("exitOptions").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("exitOptions").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("start").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("end").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("exitOptions").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("exitOptions").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("preProcessingError").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("preProcessingError").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("fileUploadError").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("fileUploadError").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("default").GetProperty("jobAction").ToString());
Console.WriteLine(result.GetProperty("exitConditions").GetProperty("default").GetProperty("dependencyAction").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("previousState").ToString());
Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
Console.WriteLine(result.GetProperty("commandLine").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("imageName").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
Console.WriteLine(result.GetProperty("environmentSettings")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentSettings")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("affinityInfo").GetProperty("affinityId").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("retentionTime").ToString());
Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
Console.WriteLine(result.GetProperty("requiredSlots").ToString());
Console.WriteLine(result.GetProperty("userIdentity").GetProperty("username").ToString());
Console.WriteLine(result.GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
Console.WriteLine(result.GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("exitCode").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("retryCount").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("lastRetryTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("requeueCount").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("lastRequeueTime").ToString());
Console.WriteLine(result.GetProperty("executionInfo").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("affinityId").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeUrl").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("poolId").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeId").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectory").ToString());
Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectoryUrl").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("numberOfInstances").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("coordinationCommandLine").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("storageContainerUrl").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("httpUrl").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("blobPrefix").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("filePath").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("fileMode").ToString());
Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIds")[0].ToString());
Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIdRanges")[0].GetProperty("start").ToString());
Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIdRanges")[0].GetProperty("end").ToString());
Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTask&gt;&gt; GetTaskAsync (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchTask&gt;&gt; GetTaskAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskAsync (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchTask))" />
      <MemberSignature Language="F#" Value="abstract member GetTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTask&gt;&gt;&#xA;override this.GetTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTask&gt;&gt;" Usage="batchClient.GetTaskAsync (jobId, taskId, timeOutInSeconds, ocpdate, select, expand, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchTask&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task to get information about. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Gets information about the specified Task. </summary>
        <returns>To be added.</returns>
        <remarks>
            For multi-instance Tasks, information such as affinityId, executionInfo and
            nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
            information about subtasks.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTaskAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchTask> response = await client.GetTaskAsync("<jobId>", "<taskId>");
]]></code>
This sample shows how to call GetTaskAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BatchTask> response = await client.GetTaskAsync("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), select: new string[] { "<select>" }, expand: new string[] { "<expand>" }, requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTaskFile (string jobId, string taskId, string filePath, int? timeOutInSeconds, DateTimeOffset? ocpdate, string ocpRange, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTaskFile(string jobId, string taskId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, string ocpRange, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFile(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFile (jobId As String, taskId As String, filePath As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), ocpRange As String, requestConditions As RequestConditions, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTaskFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.GetTaskFile (jobId, taskId, filePath, timeOutInSeconds, ocpdate, ocpRange, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="ocpRange" Type="System.String" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="ocpRange">
            The byte range to be retrieved. The default is to retrieve the entire file. The
            format is bytes=startRange-endRange.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Returns the content of the specified Task file.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetTaskFile(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTaskFile and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetTaskFile("<jobId>", "<taskId>", "<filePath>", null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTaskFile with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.GetTaskFile("<jobId>", "<taskId>", "<filePath>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), "<ocp-range>", null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;BinaryData&gt; GetTaskFile (string jobId, string taskId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, string ocpRange = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class System.BinaryData&gt; GetTaskFile(string jobId, string taskId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, string ocpRange, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFile(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFile (jobId As String, taskId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional ocpRange As String = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;BinaryData&gt;&#xA;override this.GetTaskFile : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&lt;BinaryData&gt;" Usage="batchClient.GetTaskFile (jobId, taskId, filePath, timeOutInSeconds, ocpdate, ocpRange, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="ocpRange" Type="System.String" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="ocpRange">
            The byte range to be retrieved. The default is to retrieve the entire file. The
            format is bytes=startRange-endRange.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Returns the content of the specified Task file. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTaskFile.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BinaryData> response = client.GetTaskFile("<jobId>", "<taskId>", "<filePath>");
]]></code>
This sample shows how to call GetTaskFile with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BinaryData> response = client.GetTaskFile("<jobId>", "<taskId>", "<filePath>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), ocpRange: "<ocp-range>", requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTaskFileAsync (string jobId, string taskId, string filePath, int? timeOutInSeconds, DateTimeOffset? ocpdate, string ocpRange, Azure.RequestConditions requestConditions, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTaskFileAsync(string jobId, string taskId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, string ocpRange, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFileAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFileAsync (jobId As String, taskId As String, filePath As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), ocpRange As String, requestConditions As RequestConditions, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTaskFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.GetTaskFileAsync (jobId, taskId, filePath, timeOutInSeconds, ocpdate, ocpRange, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="ocpRange" Type="System.String" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="ocpRange">
            The byte range to be retrieved. The default is to retrieve the entire file. The
            format is bytes=startRange-endRange.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Returns the content of the specified Task file.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetTaskFileAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTaskFileAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetTaskFileAsync("<jobId>", "<taskId>", "<filePath>", null, null, null, null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTaskFileAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.GetTaskFileAsync("<jobId>", "<taskId>", "<filePath>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), "<ocp-range>", null, null);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt; GetTaskFileAsync (string jobId, string taskId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, string ocpRange = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class System.BinaryData&gt;&gt; GetTaskFileAsync(string jobId, string taskId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, string ocpRange, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFileAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFileAsync (jobId As String, taskId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional ocpRange As String = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BinaryData))" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt;&#xA;override this.GetTaskFileAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;BinaryData&gt;&gt;" Usage="batchClient.GetTaskFileAsync (jobId, taskId, filePath, timeOutInSeconds, ocpdate, ocpRange, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;System.BinaryData&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="ocpRange" Type="System.String" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="ocpRange">
            The byte range to be retrieved. The default is to retrieve the entire file. The
            format is bytes=startRange-endRange.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Returns the content of the specified Task file. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTaskFileAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BinaryData> response = await client.GetTaskFileAsync("<jobId>", "<taskId>", "<filePath>");
]]></code>
This sample shows how to call GetTaskFileAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response<BinaryData> response = await client.GetTaskFileAsync("<jobId>", "<taskId>", "<filePath>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), ocpRange: "<ocp-range>", requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskFileProperties">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt; GetTaskFileProperties (string jobId, string taskId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.BatchFileProperties&gt; GetTaskFileProperties(string jobId, string taskId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFileProperties(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFileProperties (jobId As String, taskId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of BatchFileProperties)" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFileProperties : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&#xA;override this.GetTaskFileProperties : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;" Usage="batchClient.GetTaskFileProperties (jobId, taskId, filePath, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Gets the properties of the specified Task file.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <!-- No matching elements were found for the following include tag -->
        <include file="../Generated/Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFilePropertiesInternal(string,string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
      </Docs>
    </Member>
    <Member MemberName="GetTaskFilePropertiesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&gt; GetTaskFilePropertiesAsync (string jobId, string taskId, string filePath, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.BatchFileProperties&gt;&gt; GetTaskFilePropertiesAsync(string jobId, string taskId, string filePath, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFilePropertiesAsync(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFilePropertiesAsync (jobId As String, taskId As String, filePath As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of BatchFileProperties))" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFilePropertiesAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&gt;&#xA;override this.GetTaskFilePropertiesAsync : string * string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&gt;" Usage="batchClient.GetTaskFilePropertiesAsync (jobId, taskId, filePath, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.BatchFileProperties&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Gets the properties of the specified Task file.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="filePath" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <!-- No matching elements were found for the following include tag -->
        <include file="../Generated/Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFilePropertiesAsync(string,string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
      </Docs>
    </Member>
    <Member MemberName="GetTaskFiles">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetTaskFiles (string jobId, string taskId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, bool? recursive, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetTaskFiles(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Nullable`1&lt;bool&gt; recursive, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFiles(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFiles (jobId As String, taskId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, recursive As Nullable(Of Boolean), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFiles : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetTaskFiles : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetTaskFiles (jobId, taskId, timeOutInSeconds, ocpdate, maxresults, filter, recursive, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose files you want to list. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
            </param>
        <param name="recursive">
            Whether to list children of the Task directory. This parameter can be used in
            combination with the filter parameter to list specific type of files.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the files in a Task's directory on its Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetTaskFiles(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTaskFiles and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetTaskFiles("<jobId>", "<taskId>", null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetTaskFiles with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetTaskFiles("<jobId>", "<taskId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", true, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("isDirectory").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("contentLength").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("fileMode").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskFiles">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeFile&gt; GetTaskFiles (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, bool? recursive = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchNodeFile&gt; GetTaskFiles(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Nullable`1&lt;bool&gt; recursive, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFiles(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFiles (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional recursive As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchNodeFile)" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFiles : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;&#xA;override this.GetTaskFiles : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;" Usage="batchClient.GetTaskFiles (jobId, taskId, timeOutInSeconds, ocpdate, maxresults, filter, recursive, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose files you want to list. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
            </param>
        <param name="recursive">
            Whether to list children of the Task directory. This parameter can be used in
            combination with the filter parameter to list specific type of files.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists the files in a Task's directory on its Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTaskFiles.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchNodeFile item in client.GetTaskFiles("<jobId>", "<taskId>"))
{
}
]]></code>
This sample shows how to call GetTaskFiles with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchNodeFile item in client.GetTaskFiles("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", recursive: true))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskFilesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetTaskFilesAsync (string jobId, string taskId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, bool? recursive, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetTaskFilesAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Nullable`1&lt;bool&gt; recursive, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFilesAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFilesAsync (jobId As String, taskId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, recursive As Nullable(Of Boolean), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFilesAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetTaskFilesAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetTaskFilesAsync (jobId, taskId, timeOutInSeconds, ocpdate, maxresults, filter, recursive, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose files you want to list. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
            </param>
        <param name="recursive">
            Whether to list children of the Task directory. This parameter can be used in
            combination with the filter parameter to list specific type of files.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the files in a Task's directory on its Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetTaskFilesAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTaskFilesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetTaskFilesAsync("<jobId>", "<taskId>", null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetTaskFilesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetTaskFilesAsync("<jobId>", "<taskId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", true, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("isDirectory").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("contentLength").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("properties").GetProperty("fileMode").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTaskFilesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeFile&gt; GetTaskFilesAsync (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, bool? recursive = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchNodeFile&gt; GetTaskFilesAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, valuetype System.Nullable`1&lt;bool&gt; recursive, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTaskFilesAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTaskFilesAsync (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional recursive As Nullable(Of Boolean) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchNodeFile)" />
      <MemberSignature Language="F#" Value="abstract member GetTaskFilesAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;&#xA;override this.GetTaskFilesAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * Nullable&lt;bool&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;" Usage="batchClient.GetTaskFilesAsync (jobId, taskId, timeOutInSeconds, ocpdate, maxresults, filter, recursive, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchNodeFile&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="recursive" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job that contains the Task. </param>
        <param name="taskId"> The ID of the Task whose files you want to list. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
            </param>
        <param name="recursive">
            Whether to list children of the Task directory. This parameter can be used in
            combination with the filter parameter to list specific type of files.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists the files in a Task's directory on its Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTaskFilesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchNodeFile item in client.GetTaskFilesAsync("<jobId>", "<taskId>"))
{
}
]]></code>
This sample shows how to call GetTaskFilesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchNodeFile item in client.GetTaskFilesAsync("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", recursive: true))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTasks">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetTasks (string jobId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetTasks(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTasks(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTasks (jobId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTasks : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetTasks : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="batchClient.GetTasks (jobId, timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the Tasks that are associated with the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetTasks(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTasks and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetTasks("<jobId>", null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetTasks with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BinaryData item in client.GetTasks("<jobId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("exitOptions").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("exitOptions").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("start").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("end").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("exitOptions").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("exitOptions").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("preProcessingError").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("preProcessingError").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("fileUploadError").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("fileUploadError").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("default").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("default").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
    Console.WriteLine(result.GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("affinityInfo").GetProperty("affinityId").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("requiredSlots").ToString());
    Console.WriteLine(result.GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("retryCount").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("lastRetryTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("requeueCount").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("lastRequeueTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("result").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("affinityId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeUrl").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectory").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectoryUrl").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("numberOfInstances").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("coordinationCommandLine").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
    Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIds")[0].ToString());
    Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIdRanges")[0].GetProperty("start").ToString());
    Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIdRanges")[0].GetProperty("end").ToString());
    Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTasks">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Compute.Batch.BatchTask&gt; GetTasks (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Compute.Batch.BatchTask&gt; GetTasks(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTasks(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTasks (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of BatchTask)" />
      <MemberSignature Language="F#" Value="abstract member GetTasks : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchTask&gt;&#xA;override this.GetTasks : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Compute.Batch.BatchTask&gt;" Usage="batchClient.GetTasks (jobId, timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Compute.Batch.BatchTask&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the Tasks that are associated with the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            For multi-instance Tasks, information such as affinityId, executionInfo and
            nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
            information about subtasks.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTasks.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchTask item in client.GetTasks("<jobId>"))
{
}
]]></code>
This sample shows how to call GetTasks with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

foreach (BatchTask item in client.GetTasks("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTasksAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetTasksAsync (string jobId, int? timeOutInSeconds, DateTimeOffset? ocpdate, int? maxresults, string filter, System.Collections.Generic.IEnumerable&lt;string&gt; select, System.Collections.Generic.IEnumerable&lt;string&gt; expand, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetTasksAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTasksAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTasksAsync (jobId As String, timeOutInSeconds As Nullable(Of Integer), ocpdate As Nullable(Of DateTimeOffset), maxresults As Nullable(Of Integer), filter As String, select As IEnumerable(Of String), expand As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTasksAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetTasksAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="batchClient.GetTasksAsync (jobId, timeOutInSeconds, ocpdate, maxresults, filter, select, expand, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists all of the Tasks that are associated with the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.GetTasksAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTasksAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetTasksAsync("<jobId>", null, null, null, null, null, null, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetTasksAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BinaryData item in client.GetTasksAsync("<jobId>", 1234, DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), 1234, "<filter>", new string[] { "<select>" }, new string[] { "<expand>" }, null))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("displayName").ToString());
    Console.WriteLine(result.GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("eTag").ToString());
    Console.WriteLine(result.GetProperty("lastModified").ToString());
    Console.WriteLine(result.GetProperty("creationTime").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("exitOptions").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodes")[0].GetProperty("exitOptions").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("start").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("end").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("exitOptions").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("exitCodeRanges")[0].GetProperty("exitOptions").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("preProcessingError").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("preProcessingError").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("fileUploadError").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("fileUploadError").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("default").GetProperty("jobAction").ToString());
    Console.WriteLine(result.GetProperty("exitConditions").GetProperty("default").GetProperty("dependencyAction").ToString());
    Console.WriteLine(result.GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("previousState").ToString());
    Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
    Console.WriteLine(result.GetProperty("commandLine").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("containerRunOptions").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("imageName").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("password").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("registryServer").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("registry").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("containerSettings").GetProperty("workingDirectory").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("resourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("filePattern").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("path").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("containerUrl").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("destination").GetProperty("container").GetProperty("uploadHeaders")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("outputFiles")[0].GetProperty("uploadOptions").GetProperty("uploadCondition").ToString());
    Console.WriteLine(result.GetProperty("environmentSettings")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("environmentSettings")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("affinityInfo").GetProperty("affinityId").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxWallClockTime").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("retentionTime").ToString());
    Console.WriteLine(result.GetProperty("constraints").GetProperty("maxTaskRetryCount").ToString());
    Console.WriteLine(result.GetProperty("requiredSlots").ToString());
    Console.WriteLine(result.GetProperty("userIdentity").GetProperty("username").ToString());
    Console.WriteLine(result.GetProperty("userIdentity").GetProperty("autoUser").GetProperty("scope").ToString());
    Console.WriteLine(result.GetProperty("userIdentity").GetProperty("autoUser").GetProperty("elevationLevel").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("endTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("exitCode").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("containerId").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("state").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("containerInfo").GetProperty("error").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("category").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("message").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("failureInfo").GetProperty("details")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("retryCount").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("lastRetryTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("requeueCount").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("lastRequeueTime").ToString());
    Console.WriteLine(result.GetProperty("executionInfo").GetProperty("result").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("affinityId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeUrl").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("poolId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("nodeId").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectory").ToString());
    Console.WriteLine(result.GetProperty("nodeInfo").GetProperty("taskRootDirectoryUrl").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("numberOfInstances").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("coordinationCommandLine").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("autoStorageContainerName").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("storageContainerUrl").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("httpUrl").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("blobPrefix").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("filePath").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("fileMode").ToString());
    Console.WriteLine(result.GetProperty("multiInstanceSettings").GetProperty("commonResourceFiles")[0].GetProperty("identityReference").GetProperty("resourceId").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("url").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("startTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("lastUpdateTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("userCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("kernelCPUTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("wallClockTime").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOps").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("readIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("writeIOGiB").ToString());
    Console.WriteLine(result.GetProperty("stats").GetProperty("waitTime").ToString());
    Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIds")[0].ToString());
    Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIdRanges")[0].GetProperty("start").ToString());
    Console.WriteLine(result.GetProperty("dependsOn").GetProperty("taskIdRanges")[0].GetProperty("end").ToString());
    Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("applicationId").ToString());
    Console.WriteLine(result.GetProperty("applicationPackageReferences")[0].GetProperty("version").ToString());
    Console.WriteLine(result.GetProperty("authenticationTokenSettings").GetProperty("access")[0].ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTasksAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchTask&gt; GetTasksAsync (string jobId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, int? maxresults = default, string filter = default, System.Collections.Generic.IEnumerable&lt;string&gt; select = default, System.Collections.Generic.IEnumerable&lt;string&gt; expand = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Compute.Batch.BatchTask&gt; GetTasksAsync(string jobId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Nullable`1&lt;int32&gt; maxresults, string filter, class System.Collections.Generic.IEnumerable`1&lt;string&gt; select, class System.Collections.Generic.IEnumerable`1&lt;string&gt; expand, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.GetTasksAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32},System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTasksAsync (jobId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional maxresults As Nullable(Of Integer) = Nothing, Optional filter As String = Nothing, Optional select As IEnumerable(Of String) = Nothing, Optional expand As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of BatchTask)" />
      <MemberSignature Language="F#" Value="abstract member GetTasksAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchTask&gt;&#xA;override this.GetTasksAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;int&gt; * string * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchTask&gt;" Usage="batchClient.GetTasksAsync (jobId, timeOutInSeconds, ocpdate, maxresults, filter, select, expand, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Compute.Batch.BatchTask&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="maxresults" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="select" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="expand" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="maxresults">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="filter">
            An OData $filter clause. For more information on constructing this filter, see
            https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
            </param>
        <param name="select"> An OData $select clause. </param>
        <param name="expand"> An OData $expand clause. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Lists all of the Tasks that are associated with the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            For multi-instance Tasks, information such as affinityId, executionInfo and
            nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
            information about subtasks.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call GetTasksAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchTask item in client.GetTasksAsync("<jobId>"))
{
}
]]></code>
This sample shows how to call GetTasksAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

await foreach (BatchTask item in client.GetTasksAsync("<jobId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), maxresults: 1234, filter: "<filter>", select: new string[] { "<select>" }, expand: new string[] { "<expand>" }))
{
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="JobScheduleExists">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;bool&gt; JobScheduleExists (string jobScheduleId, int? timeOut = default, DateTimeOffset? ocpDate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;bool&gt; JobScheduleExists(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOut, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpDate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.JobScheduleExists(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function JobScheduleExists (jobScheduleId As String, Optional timeOut As Nullable(Of Integer) = Nothing, Optional ocpDate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member JobScheduleExists : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&lt;bool&gt;&#xA;override this.JobScheduleExists : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&lt;bool&gt;" Usage="batchClient.JobScheduleExists (jobScheduleId, timeOut, ocpDate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOut" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpDate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule which you want to check. </param>
        <param name="timeOut">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="ocpDate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Checks the specified Job Schedule exists.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <!-- No matching elements were found for the following include tag -->
        <include file="../Generated/Docs/BatchClient.xml" path="doc/members/member[@name='JobScheduleExists(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
      </Docs>
    </Member>
    <Member MemberName="JobScheduleExistsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;bool&gt;&gt; JobScheduleExistsAsync (string jobScheduleId, int? timeOut = default, DateTimeOffset? ocpDate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;bool&gt;&gt; JobScheduleExistsAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOut, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpDate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.JobScheduleExistsAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function JobScheduleExistsAsync (jobScheduleId As String, Optional timeOut As Nullable(Of Integer) = Nothing, Optional ocpDate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response(Of Boolean))" />
      <MemberSignature Language="F#" Value="abstract member JobScheduleExistsAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;bool&gt;&gt;&#xA;override this.JobScheduleExistsAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;bool&gt;&gt;" Usage="batchClient.JobScheduleExistsAsync (jobScheduleId, timeOut, ocpDate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Boolean&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOut" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpDate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule which you want to check. </param>
        <param name="timeOut">
            The maximum number of items to return in the response. A maximum of 1000
            applications can be returned.
            </param>
        <param name="ocpDate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Checks the specified Job Schedule exists.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <!-- No matching elements were found for the following include tag -->
        <include file="../Generated/Docs/BatchClient.xml" path="doc/members/member[@name='JobScheduleExistsAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Compute.Batch.BatchClient.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Compute.Batch.BatchClient.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PoolExists">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;bool&gt; PoolExists (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;bool&gt; PoolExists(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.PoolExists(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PoolExists (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response(Of Boolean)" />
      <MemberSignature Language="F#" Value="abstract member PoolExists : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&lt;bool&gt;&#xA;override this.PoolExists : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&lt;bool&gt;" Usage="batchClient.PoolExists (poolId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets basic properties of a Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <!-- No matching elements were found for the following include tag -->
        <include file="../Generated/Docs/BatchClient.xml" path="doc/members/member[@name='PoolExists(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
      </Docs>
    </Member>
    <Member MemberName="PoolExistsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;bool&gt;&gt; PoolExistsAsync (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;bool&gt;&gt; PoolExistsAsync(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.PoolExistsAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PoolExistsAsync (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response(Of Boolean))" />
      <MemberSignature Language="F#" Value="abstract member PoolExistsAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;bool&gt;&gt;&#xA;override this.PoolExistsAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;bool&gt;&gt;" Usage="batchClient.PoolExistsAsync (poolId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;System.Boolean&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets basic properties of a Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <!-- No matching elements were found for the following include tag -->
        <include file="../Generated/Docs/BatchClient.xml" path="doc/members/member[@name='PoolExistsAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
      </Docs>
    </Member>
    <Member MemberName="ReactivateTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReactivateTask (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReactivateTask(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReactivateTask(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReactivateTask (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReactivateTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ReactivateTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.ReactivateTask (jobId, taskId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job containing the Task. </param>
        <param name="taskId"> The ID of the Task to reactivate. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Reactivates a Task, allowing it to run again even if its retry count has been
            exhausted.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReactivateTask.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.ReactivateTask("<jobId>", "<taskId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReactivateTask with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.ReactivateTask("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReactivateTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReactivateTaskAsync (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReactivateTaskAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReactivateTaskAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReactivateTaskAsync (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReactivateTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReactivateTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReactivateTaskAsync (jobId, taskId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job containing the Task. </param>
        <param name="taskId"> The ID of the Task to reactivate. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Reactivates a Task, allowing it to run again even if its retry count has been
            exhausted.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReactivateTaskAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.ReactivateTaskAsync("<jobId>", "<taskId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReactivateTaskAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.ReactivateTaskAsync("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RebootNode">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RebootNode (string poolId, string nodeId, Azure.Compute.Batch.BatchNodeRebootContent parameters = default, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RebootNode(string poolId, string nodeId, class Azure.Compute.Batch.BatchNodeRebootContent parameters, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.RebootNode(System.String,System.String,Azure.Compute.Batch.BatchNodeRebootContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RebootNode (poolId As String, nodeId As String, Optional parameters As BatchNodeRebootContent = Nothing, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RebootNode : string * string * Azure.Compute.Batch.BatchNodeRebootContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.RebootNode : string * string * Azure.Compute.Batch.BatchNodeRebootContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.RebootNode (poolId, nodeId, parameters, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="parameters" Type="Azure.Compute.Batch.BatchNodeRebootContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        <param name="parameters"> The options to use for rebooting the Compute Node. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Restarts the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks> You can restart a Compute Node only if it is in an idle or running state. </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RebootNode.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.RebootNode("<poolId>", "<nodeId>");
]]></code>
This sample shows how to call RebootNode with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeRebootContent parameters = new BatchNodeRebootContent
{
    NodeRebootOption = BatchNodeRebootOption.Requeue,
};
Response response = client.RebootNode("<poolId>", "<nodeId>", parameters: parameters, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RebootNode">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RebootNode (string poolId, string nodeId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RebootNode(string poolId, string nodeId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.RebootNode(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RebootNode (poolId As String, nodeId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RebootNode : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.RebootNode : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.RebootNode (poolId, nodeId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Restarts the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.RebootNode(System.String,System.String,Azure.Compute.Batch.BatchNodeRebootContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RebootNode.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = null;
Response response = client.RebootNode("<poolId>", "<nodeId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RebootNode with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    nodeRebootOption = "requeue",
});
Response response = client.RebootNode("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RebootNodeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RebootNodeAsync (string poolId, string nodeId, Azure.Compute.Batch.BatchNodeRebootContent parameters = default, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RebootNodeAsync(string poolId, string nodeId, class Azure.Compute.Batch.BatchNodeRebootContent parameters, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.RebootNodeAsync(System.String,System.String,Azure.Compute.Batch.BatchNodeRebootContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RebootNodeAsync (poolId As String, nodeId As String, Optional parameters As BatchNodeRebootContent = Nothing, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RebootNodeAsync : string * string * Azure.Compute.Batch.BatchNodeRebootContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RebootNodeAsync : string * string * Azure.Compute.Batch.BatchNodeRebootContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.RebootNodeAsync (poolId, nodeId, parameters, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="parameters" Type="Azure.Compute.Batch.BatchNodeRebootContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        <param name="parameters"> The options to use for rebooting the Compute Node. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Restarts the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks> You can restart a Compute Node only if it is in an idle or running state. </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RebootNodeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.RebootNodeAsync("<poolId>", "<nodeId>");
]]></code>
This sample shows how to call RebootNodeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeRebootContent parameters = new BatchNodeRebootContent
{
    NodeRebootOption = BatchNodeRebootOption.Requeue,
};
Response response = await client.RebootNodeAsync("<poolId>", "<nodeId>", parameters: parameters, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RebootNodeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RebootNodeAsync (string poolId, string nodeId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RebootNodeAsync(string poolId, string nodeId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.RebootNodeAsync(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RebootNodeAsync (poolId As String, nodeId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RebootNodeAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RebootNodeAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.RebootNodeAsync (poolId, nodeId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Restarts the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.RebootNodeAsync(System.String,System.String,Azure.Compute.Batch.BatchNodeRebootContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RebootNodeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = null;
Response response = await client.RebootNodeAsync("<poolId>", "<nodeId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RebootNodeAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    nodeRebootOption = "requeue",
});
Response response = await client.RebootNodeAsync("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveNodes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveNodes (string poolId, Azure.Compute.Batch.BatchNodeRemoveContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveNodes(string poolId, class Azure.Compute.Batch.BatchNodeRemoveContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.RemoveNodes(System.String,Azure.Compute.Batch.BatchNodeRemoveContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveNodes (poolId As String, content As BatchNodeRemoveContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveNodes : string * Azure.Compute.Batch.BatchNodeRemoveContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.RemoveNodes : string * Azure.Compute.Batch.BatchNodeRemoveContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.RemoveNodes (poolId, content, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchNodeRemoveContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The options to use for removing the node. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Removes Compute Nodes from the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            This operation can only run when the allocation state of the Pool is steady.
            When this operation runs, the allocation state changes from steady to resizing.
            Each request may remove up to 100 nodes.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveNodes.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeRemoveContent content = new BatchNodeRemoveContent(new string[] { "<nodeList>" });
Response response = client.RemoveNodes("<poolId>", content);
]]></code>
This sample shows how to call RemoveNodes with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeRemoveContent content = new BatchNodeRemoveContent(new string[] { "<nodeList>" })
{
    ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
    NodeDeallocationOption = BatchNodeDeallocationOption.Requeue,
};
Response response = client.RemoveNodes("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveNodes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response RemoveNodes (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response RemoveNodes(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.RemoveNodes(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveNodes (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member RemoveNodes : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.RemoveNodes : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.RemoveNodes (poolId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Removes Compute Nodes from the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.RemoveNodes(System.String,Azure.Compute.Batch.BatchNodeRemoveContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveNodes.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    nodeList = new object[]
    {
        "<nodeList>"
    },
});
Response response = client.RemoveNodes("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveNodes with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    nodeList = new object[]
    {
        "<nodeList>"
    },
    resizeTimeout = "PT1H23M45S",
    nodeDeallocationOption = "requeue",
});
Response response = client.RemoveNodes("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveNodesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveNodesAsync (string poolId, Azure.Compute.Batch.BatchNodeRemoveContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveNodesAsync(string poolId, class Azure.Compute.Batch.BatchNodeRemoveContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.RemoveNodesAsync(System.String,Azure.Compute.Batch.BatchNodeRemoveContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveNodesAsync (poolId As String, content As BatchNodeRemoveContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveNodesAsync : string * Azure.Compute.Batch.BatchNodeRemoveContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveNodesAsync : string * Azure.Compute.Batch.BatchNodeRemoveContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.RemoveNodesAsync (poolId, content, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchNodeRemoveContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The options to use for removing the node. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Removes Compute Nodes from the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            This operation can only run when the allocation state of the Pool is steady.
            When this operation runs, the allocation state changes from steady to resizing.
            Each request may remove up to 100 nodes.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call RemoveNodesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeRemoveContent content = new BatchNodeRemoveContent(new string[] { "<nodeList>" });
Response response = await client.RemoveNodesAsync("<poolId>", content);
]]></code>
This sample shows how to call RemoveNodesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeRemoveContent content = new BatchNodeRemoveContent(new string[] { "<nodeList>" })
{
    ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
    NodeDeallocationOption = BatchNodeDeallocationOption.Requeue,
};
Response response = await client.RemoveNodesAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="RemoveNodesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; RemoveNodesAsync (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; RemoveNodesAsync(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.RemoveNodesAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveNodesAsync (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member RemoveNodesAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.RemoveNodesAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.RemoveNodesAsync (poolId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Removes Compute Nodes from the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.RemoveNodesAsync(System.String,Azure.Compute.Batch.BatchNodeRemoveContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call RemoveNodesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    nodeList = new object[]
    {
        "<nodeList>"
    },
});
Response response = await client.RemoveNodesAsync("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call RemoveNodesAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    nodeList = new object[]
    {
        "<nodeList>"
    },
    resizeTimeout = "PT1H23M45S",
    nodeDeallocationOption = "requeue",
});
Response response = await client.RemoveNodesAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplaceJob (string jobId, Azure.Compute.Batch.BatchJob job, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplaceJob(string jobId, class Azure.Compute.Batch.BatchJob job, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceJob(System.String,Azure.Compute.Batch.BatchJob,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceJob (jobId As String, job As BatchJob, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplaceJob : string * Azure.Compute.Batch.BatchJob * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.ReplaceJob : string * Azure.Compute.Batch.BatchJob * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.ReplaceJob (jobId, job, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="job" Type="Azure.Compute.Batch.BatchJob" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        <param name="job"> A job with updated properties. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the properties of the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            This fully replaces all the updatable properties of the Job. For example, if
            the Job has constraints associated with it and if constraints is not specified
            with this request, then the Batch service will remove the existing constraints.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="job" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplaceJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJob job = new BatchJob(new BatchPoolInfo());
Response response = client.ReplaceJob("<jobId>", job);
]]></code>
This sample shows how to call ReplaceJob with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJob job = new BatchJob(new BatchPoolInfo
{
    PoolId = "<poolId>",
    AutoPoolSpecification = new BatchAutoPoolSpecification(BatchPoolLifetimeOption.JobSchedule)
    {
        AutoPoolIdPrefix = "<autoPoolIdPrefix>",
        KeepAlive = true,
        Pool = new BatchPoolSpecification("<vmSize>")
        {
            DisplayName = "<displayName>",
            VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
            {
                Publisher = "<publisher>",
                Offer = "<offer>",
                Sku = "<sku>",
                Version = "<version>",
                VirtualMachineImageId = "<virtualMachineImageId>",
            }, "<nodeAgentSKUId>")
            {
                WindowsConfiguration = new WindowsConfiguration
                {
                    EnableAutomaticUpdates = true,
                },
                DataDisks = {new DataDisk(1234, 1234)
                {
                    Caching = CachingType.None,
                    StorageAccountType = StorageAccountType.StandardLRS,
                }},
                LicenseType = "<licenseType>",
                ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
                {
                    ContainerImageNames = { "<containerImageNames>" },
                    ContainerRegistries = {new ContainerRegistryReference
                    {
                        Username = "<username>",
                        Password = "<password>",
                        RegistryServer = "<registryServer>",
                        IdentityReference = new BatchNodeIdentityReference
                        {
                            ResourceId = "<resourceId>",
                        },
                    }},
                },
                DiskEncryptionConfiguration = new DiskEncryptionConfiguration
                {
                    Targets = { DiskEncryptionTarget.OsDisk },
                },
                NodePlacementConfiguration = new BatchNodePlacementConfiguration
                {
                    Policy = BatchNodePlacementPolicyType.Regional,
                },
                Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
                {
                    TypeHandlerVersion = "<typeHandlerVersion>",
                    AutoUpgradeMinorVersion = true,
                    EnableAutomaticUpgrade = true,
                    Settings =
                    {
                        ["key"] = "<settings>"
                    },
                    ProtectedSettings =
                    {
                        ["key"] = "<protectedSettings>"
                    },
                    ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
                }},
                OsDisk = new OSDisk
                {
                    EphemeralOSDiskSettings = new DiffDiskSettings
                    {
                        Placement = DiffDiskPlacement.CacheDisk,
                    },
                    Caching = CachingType.None,
                    DiskSizeGB = 1234,
                    ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
                    WriteAcceleratorEnabled = true,
                },
                SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
                {
                    SecureBootEnabled = true,
                    VTpmEnabled = true,
                }),
                ServiceArtifactReference = new ServiceArtifactReference("<id>"),
            },
            TaskSlotsPerNode = 1234,
            TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
            ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
            ResourceTags = "<resourceTags>",
            TargetDedicatedNodes = 1234,
            TargetLowPriorityNodes = 1234,
            EnableAutoScale = true,
            AutoScaleFormula = "<autoScaleFormula>",
            AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
            EnableInterNodeCommunication = true,
            NetworkConfiguration = new NetworkConfiguration
            {
                SubnetId = "<subnetId>",
                DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
                EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
                {
                    new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
                    {
                        NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                        {
                            SourcePortRanges = {"<sourcePortRanges>"},
                        }},
                    }
                }),
                PublicIpAddressConfiguration = new PublicIpAddressConfiguration
                {
                    IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
                    IpAddressIds = { "<ipAddressIds>" },
                },
                EnableAcceleratedNetworking = true,
            },
            StartTask = new BatchStartTask("<commandLine>")
            {
                ContainerSettings = new BatchTaskContainerSettings("<imageName>")
                {
                    ContainerRunOptions = "<containerRunOptions>",
                    Registry = default,
                    WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
                },
                ResourceFiles = {new ResourceFile
                {
                    AutoStorageContainerName = "<autoStorageContainerName>",
                    StorageContainerUrl = "<storageContainerUrl>",
                    HttpUrl = "<httpUrl>",
                    BlobPrefix = "<blobPrefix>",
                    FilePath = "<filePath>",
                    FileMode = "<fileMode>",
                    IdentityReference = default,
                }},
                EnvironmentSettings = {new EnvironmentSetting("<name>")
                {
                    Value = "<value>",
                }},
                UserIdentity = new UserIdentity
                {
                    Username = "<username>",
                    AutoUser = new AutoUserSpecification
                    {
                        Scope = AutoUserScope.Task,
                        ElevationLevel = ElevationLevel.NonAdmin,
                    },
                },
                MaxTaskRetryCount = 1234,
                WaitForSuccess = true,
            },
            ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
            {
                Version = "<version>",
            }},
            UserAccounts = {new UserAccount("<name>", "<password>")
            {
                ElevationLevel = ElevationLevel.NonAdmin,
                LinuxUserConfiguration = new LinuxUserConfiguration
                {
                    Uid = 1234,
                    Gid = 1234,
                    SshPrivateKey = "<sshPrivateKey>",
                },
                WindowsUserConfiguration = new WindowsUserConfiguration
                {
                    LoginMode = LoginMode.Batch,
                },
            }},
            Metadata = { new MetadataItem("<name>", "<value>") },
            MountConfiguration = {new MountConfiguration
            {
                AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
                {
                    AccountKey = "<accountKey>",
                    SasKey = "<sasKey>",
                    BlobfuseOptions = "<blobfuseOptions>",
                    IdentityReference = default,
                },
                NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
                CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
                {
                    MountOptions = "<mountOptions>",
                },
                AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
            }},
            TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
            UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
            {
                AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
                {
                    DisableAutomaticRollback = true,
                    EnableAutomaticOsUpgrade = true,
                    UseRollingUpgradePolicy = true,
                    OsRollingUpgradeDeferral = true,
                },
                RollingUpgradePolicy = new RollingUpgradePolicy
                {
                    EnableCrossZoneUpgrade = true,
                    MaxBatchInstancePercent = 1234,
                    MaxUnhealthyInstancePercent = 1234,
                    MaxUnhealthyUpgradedInstancePercent = 1234,
                    PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
                    PrioritizeUnhealthyInstances = true,
                    RollbackFailedInstancesOnPolicyBreach = true,
                },
            },
        },
    },
})
{
    Priority = 1234,
    AllowTaskPreemption = true,
    MaxParallelTasks = 1234,
    Constraints = new BatchJobConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    OnAllTasksComplete = OnAllBatchTasksComplete.NoAction,
    Metadata = { default },
};
Response response = client.ReplaceJob("<jobId>", job, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplaceJob (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplaceJob(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceJob(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceJob (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplaceJob : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ReplaceJob : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.ReplaceJob (jobId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplaceJob(System.String,Azure.Compute.Batch.BatchJob,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplaceJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    poolInfo = new object(),
});
Response response = client.ReplaceJob("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplaceJob with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    priority = 1234,
    allowTaskPreemption = true,
    maxParallelTasks = 1234,
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    poolInfo = new
    {
        poolId = "<poolId>",
        autoPoolSpecification = new
        {
            autoPoolIdPrefix = "<autoPoolIdPrefix>",
            poolLifetimeOption = "jobschedule",
            keepAlive = true,
            pool = new
            {
                displayName = "<displayName>",
                vmSize = "<vmSize>",
                virtualMachineConfiguration = new
                {
                    imageReference = new
                    {
                        publisher = "<publisher>",
                        offer = "<offer>",
                        sku = "<sku>",
                        version = "<version>",
                        virtualMachineImageId = "<virtualMachineImageId>",
                    },
                    nodeAgentSKUId = "<nodeAgentSKUId>",
                    windowsConfiguration = new
                    {
                        enableAutomaticUpdates = true,
                    },
                    dataDisks = new object[]
                    {
                        new
                        {
                            lun = 1234,
                            caching = "none",
                            diskSizeGB = 1234,
                            storageAccountType = "standard_lrs",
                        }
                    },
                    licenseType = "<licenseType>",
                    containerConfiguration = new
                    {
                        type = "dockerCompatible",
                        containerImageNames = new object[]
                        {
                            "<containerImageNames>"
                        },
                        containerRegistries = new object[]
                        {
                            new
                            {
                                username = "<username>",
                                password = "<password>",
                                registryServer = "<registryServer>",
                                identityReference = new
                                {
                                    resourceId = "<resourceId>",
                                },
                            }
                        },
                    },
                    diskEncryptionConfiguration = new
                    {
                        targets = new object[]
                        {
                            "osdisk"
                        },
                    },
                    nodePlacementConfiguration = new
                    {
                        policy = "regional",
                    },
                    extensions = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            publisher = "<publisher>",
                            type = "<type>",
                            typeHandlerVersion = "<typeHandlerVersion>",
                            autoUpgradeMinorVersion = true,
                            enableAutomaticUpgrade = true,
                            settings = new
                            {
                                key = "<settings>",
                            },
                            protectedSettings = new
                            {
                                key = "<protectedSettings>",
                            },
                            provisionAfterExtensions = new object[]
                            {
                                "<provisionAfterExtensions>"
                            },
                        }
                    },
                    osDisk = new
                    {
                        ephemeralOSDiskSettings = new
                        {
                            placement = "cachedisk",
                        },
                        caching = "none",
                        diskSizeGB = 1234,
                        managedDisk = new
                        {
                            storageAccountType = "standard_lrs",
                        },
                        writeAcceleratorEnabled = true,
                    },
                    securityProfile = new
                    {
                        encryptionAtHost = true,
                        securityType = "trustedLaunch",
                        uefiSettings = new
                        {
                            secureBootEnabled = true,
                            vTpmEnabled = true,
                        },
                    },
                    serviceArtifactReference = new
                    {
                        id = "<id>",
                    },
                },
                taskSlotsPerNode = 1234,
                taskSchedulingPolicy = new
                {
                    nodeFillType = "spread",
                },
                resizeTimeout = "PT1H23M45S",
                resourceTags = "<resourceTags>",
                targetDedicatedNodes = 1234,
                targetLowPriorityNodes = 1234,
                enableAutoScale = true,
                autoScaleFormula = "<autoScaleFormula>",
                autoScaleEvaluationInterval = "PT1H23M45S",
                enableInterNodeCommunication = true,
                networkConfiguration = new
                {
                    subnetId = "<subnetId>",
                    dynamicVNetAssignmentScope = "none",
                    endpointConfiguration = new
                    {
                        inboundNATPools = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                protocol = "tcp",
                                backendPort = 1234,
                                frontendPortRangeStart = 1234,
                                frontendPortRangeEnd = 1234,
                                networkSecurityGroupRules = new object[]
                                {
                                    new
                                    {
                                        priority = 1234,
                                        access = "allow",
                                        sourceAddressPrefix = "<sourceAddressPrefix>",
                                        sourcePortRanges = new object[]
                                        {
                                            "<sourcePortRanges>"
                                        },
                                    }
                                },
                            }
                        },
                    },
                    publicIPAddressConfiguration = new
                    {
                        provision = "batchmanaged",
                        ipAddressIds = new object[]
                        {
                            "<ipAddressIds>"
                        },
                    },
                    enableAcceleratedNetworking = true,
                },
                startTask = new
                {
                    commandLine = "<commandLine>",
                    containerSettings = new
                    {
                        containerRunOptions = "<containerRunOptions>",
                        imageName = "<imageName>",
                        workingDirectory = "taskWorkingDirectory",
                    },
                    resourceFiles = new object[]
                    {
                        new
                        {
                            autoStorageContainerName = "<autoStorageContainerName>",
                            storageContainerUrl = "<storageContainerUrl>",
                            httpUrl = "<httpUrl>",
                            blobPrefix = "<blobPrefix>",
                            filePath = "<filePath>",
                            fileMode = "<fileMode>",
                        }
                    },
                    environmentSettings = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    userIdentity = new
                    {
                        username = "<username>",
                        autoUser = new
                        {
                            scope = "task",
                            elevationLevel = "nonadmin",
                        },
                    },
                    maxTaskRetryCount = 1234,
                    waitForSuccess = true,
                },
                applicationPackageReferences = new object[]
                {
                    new
                    {
                        applicationId = "<applicationId>",
                        version = "<version>",
                    }
                },
                userAccounts = new object[]
                {
                    new
                    {
                        name = "<name>",
                        password = "<password>",
                        elevationLevel = "nonadmin",
                        linuxUserConfiguration = new
                        {
                            uid = 1234,
                            gid = 1234,
                            sshPrivateKey = "<sshPrivateKey>",
                        },
                        windowsUserConfiguration = new
                        {
                            loginMode = "batch",
                        },
                    }
                },
                metadata = new object[]
                {
                    new
                    {
                        name = "<name>",
                        value = "<value>",
                    }
                },
                mountConfiguration = new object[]
                {
                    new
                    {
                        azureBlobFileSystemConfiguration = new
                        {
                            accountName = "<accountName>",
                            containerName = "<containerName>",
                            accountKey = "<accountKey>",
                            sasKey = "<sasKey>",
                            blobfuseOptions = "<blobfuseOptions>",
                            relativeMountPath = "<relativeMountPath>",
                        },
                        nfsMountConfiguration = new
                        {
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                        cifsMountConfiguration = new
                        {
                            username = "<username>",
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                            password = "<password>",
                        },
                        azureFileShareConfiguration = new
                        {
                            accountName = "<accountName>",
                            azureFileUrl = "<azureFileUrl>",
                            accountKey = "<accountKey>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                    }
                },
                targetNodeCommunicationMode = "default",
                upgradePolicy = new
                {
                    mode = "automatic",
                    automaticOSUpgradePolicy = new
                    {
                        disableAutomaticRollback = true,
                        enableAutomaticOSUpgrade = true,
                        useRollingUpgradePolicy = true,
                        osRollingUpgradeDeferral = true,
                    },
                    rollingUpgradePolicy = new
                    {
                        enableCrossZoneUpgrade = true,
                        maxBatchInstancePercent = 1234,
                        maxUnhealthyInstancePercent = 1234,
                        maxUnhealthyUpgradedInstancePercent = 1234,
                        pauseTimeBetweenBatches = "PT1H23M45S",
                        prioritizeUnhealthyInstances = true,
                        rollbackFailedInstancesOnPolicyBreach = true,
                    },
                },
            },
        },
    },
    onAllTasksComplete = "noaction",
    metadata = new object[]
    {
        null
    },
});
Response response = client.ReplaceJob("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplaceJobAsync (string jobId, Azure.Compute.Batch.BatchJob job, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplaceJobAsync(string jobId, class Azure.Compute.Batch.BatchJob job, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceJobAsync(System.String,Azure.Compute.Batch.BatchJob,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceJobAsync (jobId As String, job As BatchJob, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplaceJobAsync : string * Azure.Compute.Batch.BatchJob * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplaceJobAsync : string * Azure.Compute.Batch.BatchJob * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplaceJobAsync (jobId, job, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="job" Type="Azure.Compute.Batch.BatchJob" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        <param name="job"> A job with updated properties. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the properties of the specified Job. </summary>
        <returns>To be added.</returns>
        <remarks>
            This fully replaces all the updatable properties of the Job. For example, if
            the Job has constraints associated with it and if constraints is not specified
            with this request, then the Batch service will remove the existing constraints.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="job" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplaceJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJob job = new BatchJob(new BatchPoolInfo());
Response response = await client.ReplaceJobAsync("<jobId>", job);
]]></code>
This sample shows how to call ReplaceJobAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJob job = new BatchJob(new BatchPoolInfo
{
    PoolId = "<poolId>",
    AutoPoolSpecification = new BatchAutoPoolSpecification(BatchPoolLifetimeOption.JobSchedule)
    {
        AutoPoolIdPrefix = "<autoPoolIdPrefix>",
        KeepAlive = true,
        Pool = new BatchPoolSpecification("<vmSize>")
        {
            DisplayName = "<displayName>",
            VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
            {
                Publisher = "<publisher>",
                Offer = "<offer>",
                Sku = "<sku>",
                Version = "<version>",
                VirtualMachineImageId = "<virtualMachineImageId>",
            }, "<nodeAgentSKUId>")
            {
                WindowsConfiguration = new WindowsConfiguration
                {
                    EnableAutomaticUpdates = true,
                },
                DataDisks = {new DataDisk(1234, 1234)
                {
                    Caching = CachingType.None,
                    StorageAccountType = StorageAccountType.StandardLRS,
                }},
                LicenseType = "<licenseType>",
                ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
                {
                    ContainerImageNames = { "<containerImageNames>" },
                    ContainerRegistries = {new ContainerRegistryReference
                    {
                        Username = "<username>",
                        Password = "<password>",
                        RegistryServer = "<registryServer>",
                        IdentityReference = new BatchNodeIdentityReference
                        {
                            ResourceId = "<resourceId>",
                        },
                    }},
                },
                DiskEncryptionConfiguration = new DiskEncryptionConfiguration
                {
                    Targets = { DiskEncryptionTarget.OsDisk },
                },
                NodePlacementConfiguration = new BatchNodePlacementConfiguration
                {
                    Policy = BatchNodePlacementPolicyType.Regional,
                },
                Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
                {
                    TypeHandlerVersion = "<typeHandlerVersion>",
                    AutoUpgradeMinorVersion = true,
                    EnableAutomaticUpgrade = true,
                    Settings =
                    {
                        ["key"] = "<settings>"
                    },
                    ProtectedSettings =
                    {
                        ["key"] = "<protectedSettings>"
                    },
                    ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
                }},
                OsDisk = new OSDisk
                {
                    EphemeralOSDiskSettings = new DiffDiskSettings
                    {
                        Placement = DiffDiskPlacement.CacheDisk,
                    },
                    Caching = CachingType.None,
                    DiskSizeGB = 1234,
                    ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
                    WriteAcceleratorEnabled = true,
                },
                SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
                {
                    SecureBootEnabled = true,
                    VTpmEnabled = true,
                }),
                ServiceArtifactReference = new ServiceArtifactReference("<id>"),
            },
            TaskSlotsPerNode = 1234,
            TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
            ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
            ResourceTags = "<resourceTags>",
            TargetDedicatedNodes = 1234,
            TargetLowPriorityNodes = 1234,
            EnableAutoScale = true,
            AutoScaleFormula = "<autoScaleFormula>",
            AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
            EnableInterNodeCommunication = true,
            NetworkConfiguration = new NetworkConfiguration
            {
                SubnetId = "<subnetId>",
                DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
                EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
                {
                    new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
                    {
                        NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                        {
                            SourcePortRanges = {"<sourcePortRanges>"},
                        }},
                    }
                }),
                PublicIpAddressConfiguration = new PublicIpAddressConfiguration
                {
                    IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
                    IpAddressIds = { "<ipAddressIds>" },
                },
                EnableAcceleratedNetworking = true,
            },
            StartTask = new BatchStartTask("<commandLine>")
            {
                ContainerSettings = new BatchTaskContainerSettings("<imageName>")
                {
                    ContainerRunOptions = "<containerRunOptions>",
                    Registry = default,
                    WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
                },
                ResourceFiles = {new ResourceFile
                {
                    AutoStorageContainerName = "<autoStorageContainerName>",
                    StorageContainerUrl = "<storageContainerUrl>",
                    HttpUrl = "<httpUrl>",
                    BlobPrefix = "<blobPrefix>",
                    FilePath = "<filePath>",
                    FileMode = "<fileMode>",
                    IdentityReference = default,
                }},
                EnvironmentSettings = {new EnvironmentSetting("<name>")
                {
                    Value = "<value>",
                }},
                UserIdentity = new UserIdentity
                {
                    Username = "<username>",
                    AutoUser = new AutoUserSpecification
                    {
                        Scope = AutoUserScope.Task,
                        ElevationLevel = ElevationLevel.NonAdmin,
                    },
                },
                MaxTaskRetryCount = 1234,
                WaitForSuccess = true,
            },
            ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
            {
                Version = "<version>",
            }},
            UserAccounts = {new UserAccount("<name>", "<password>")
            {
                ElevationLevel = ElevationLevel.NonAdmin,
                LinuxUserConfiguration = new LinuxUserConfiguration
                {
                    Uid = 1234,
                    Gid = 1234,
                    SshPrivateKey = "<sshPrivateKey>",
                },
                WindowsUserConfiguration = new WindowsUserConfiguration
                {
                    LoginMode = LoginMode.Batch,
                },
            }},
            Metadata = { new MetadataItem("<name>", "<value>") },
            MountConfiguration = {new MountConfiguration
            {
                AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
                {
                    AccountKey = "<accountKey>",
                    SasKey = "<sasKey>",
                    BlobfuseOptions = "<blobfuseOptions>",
                    IdentityReference = default,
                },
                NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
                CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
                {
                    MountOptions = "<mountOptions>",
                },
                AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
            }},
            TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
            UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
            {
                AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
                {
                    DisableAutomaticRollback = true,
                    EnableAutomaticOsUpgrade = true,
                    UseRollingUpgradePolicy = true,
                    OsRollingUpgradeDeferral = true,
                },
                RollingUpgradePolicy = new RollingUpgradePolicy
                {
                    EnableCrossZoneUpgrade = true,
                    MaxBatchInstancePercent = 1234,
                    MaxUnhealthyInstancePercent = 1234,
                    MaxUnhealthyUpgradedInstancePercent = 1234,
                    PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
                    PrioritizeUnhealthyInstances = true,
                    RollbackFailedInstancesOnPolicyBreach = true,
                },
            },
        },
    },
})
{
    Priority = 1234,
    AllowTaskPreemption = true,
    MaxParallelTasks = 1234,
    Constraints = new BatchJobConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    OnAllTasksComplete = OnAllBatchTasksComplete.NoAction,
    Metadata = { default },
};
Response response = await client.ReplaceJobAsync("<jobId>", job, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplaceJobAsync (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplaceJobAsync(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceJobAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceJobAsync (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplaceJobAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplaceJobAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplaceJobAsync (jobId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplaceJobAsync(System.String,Azure.Compute.Batch.BatchJob,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplaceJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    poolInfo = new object(),
});
Response response = await client.ReplaceJobAsync("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplaceJobAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    priority = 1234,
    allowTaskPreemption = true,
    maxParallelTasks = 1234,
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    poolInfo = new
    {
        poolId = "<poolId>",
        autoPoolSpecification = new
        {
            autoPoolIdPrefix = "<autoPoolIdPrefix>",
            poolLifetimeOption = "jobschedule",
            keepAlive = true,
            pool = new
            {
                displayName = "<displayName>",
                vmSize = "<vmSize>",
                virtualMachineConfiguration = new
                {
                    imageReference = new
                    {
                        publisher = "<publisher>",
                        offer = "<offer>",
                        sku = "<sku>",
                        version = "<version>",
                        virtualMachineImageId = "<virtualMachineImageId>",
                    },
                    nodeAgentSKUId = "<nodeAgentSKUId>",
                    windowsConfiguration = new
                    {
                        enableAutomaticUpdates = true,
                    },
                    dataDisks = new object[]
                    {
                        new
                        {
                            lun = 1234,
                            caching = "none",
                            diskSizeGB = 1234,
                            storageAccountType = "standard_lrs",
                        }
                    },
                    licenseType = "<licenseType>",
                    containerConfiguration = new
                    {
                        type = "dockerCompatible",
                        containerImageNames = new object[]
                        {
                            "<containerImageNames>"
                        },
                        containerRegistries = new object[]
                        {
                            new
                            {
                                username = "<username>",
                                password = "<password>",
                                registryServer = "<registryServer>",
                                identityReference = new
                                {
                                    resourceId = "<resourceId>",
                                },
                            }
                        },
                    },
                    diskEncryptionConfiguration = new
                    {
                        targets = new object[]
                        {
                            "osdisk"
                        },
                    },
                    nodePlacementConfiguration = new
                    {
                        policy = "regional",
                    },
                    extensions = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            publisher = "<publisher>",
                            type = "<type>",
                            typeHandlerVersion = "<typeHandlerVersion>",
                            autoUpgradeMinorVersion = true,
                            enableAutomaticUpgrade = true,
                            settings = new
                            {
                                key = "<settings>",
                            },
                            protectedSettings = new
                            {
                                key = "<protectedSettings>",
                            },
                            provisionAfterExtensions = new object[]
                            {
                                "<provisionAfterExtensions>"
                            },
                        }
                    },
                    osDisk = new
                    {
                        ephemeralOSDiskSettings = new
                        {
                            placement = "cachedisk",
                        },
                        caching = "none",
                        diskSizeGB = 1234,
                        managedDisk = new
                        {
                            storageAccountType = "standard_lrs",
                        },
                        writeAcceleratorEnabled = true,
                    },
                    securityProfile = new
                    {
                        encryptionAtHost = true,
                        securityType = "trustedLaunch",
                        uefiSettings = new
                        {
                            secureBootEnabled = true,
                            vTpmEnabled = true,
                        },
                    },
                    serviceArtifactReference = new
                    {
                        id = "<id>",
                    },
                },
                taskSlotsPerNode = 1234,
                taskSchedulingPolicy = new
                {
                    nodeFillType = "spread",
                },
                resizeTimeout = "PT1H23M45S",
                resourceTags = "<resourceTags>",
                targetDedicatedNodes = 1234,
                targetLowPriorityNodes = 1234,
                enableAutoScale = true,
                autoScaleFormula = "<autoScaleFormula>",
                autoScaleEvaluationInterval = "PT1H23M45S",
                enableInterNodeCommunication = true,
                networkConfiguration = new
                {
                    subnetId = "<subnetId>",
                    dynamicVNetAssignmentScope = "none",
                    endpointConfiguration = new
                    {
                        inboundNATPools = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                protocol = "tcp",
                                backendPort = 1234,
                                frontendPortRangeStart = 1234,
                                frontendPortRangeEnd = 1234,
                                networkSecurityGroupRules = new object[]
                                {
                                    new
                                    {
                                        priority = 1234,
                                        access = "allow",
                                        sourceAddressPrefix = "<sourceAddressPrefix>",
                                        sourcePortRanges = new object[]
                                        {
                                            "<sourcePortRanges>"
                                        },
                                    }
                                },
                            }
                        },
                    },
                    publicIPAddressConfiguration = new
                    {
                        provision = "batchmanaged",
                        ipAddressIds = new object[]
                        {
                            "<ipAddressIds>"
                        },
                    },
                    enableAcceleratedNetworking = true,
                },
                startTask = new
                {
                    commandLine = "<commandLine>",
                    containerSettings = new
                    {
                        containerRunOptions = "<containerRunOptions>",
                        imageName = "<imageName>",
                        workingDirectory = "taskWorkingDirectory",
                    },
                    resourceFiles = new object[]
                    {
                        new
                        {
                            autoStorageContainerName = "<autoStorageContainerName>",
                            storageContainerUrl = "<storageContainerUrl>",
                            httpUrl = "<httpUrl>",
                            blobPrefix = "<blobPrefix>",
                            filePath = "<filePath>",
                            fileMode = "<fileMode>",
                        }
                    },
                    environmentSettings = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    userIdentity = new
                    {
                        username = "<username>",
                        autoUser = new
                        {
                            scope = "task",
                            elevationLevel = "nonadmin",
                        },
                    },
                    maxTaskRetryCount = 1234,
                    waitForSuccess = true,
                },
                applicationPackageReferences = new object[]
                {
                    new
                    {
                        applicationId = "<applicationId>",
                        version = "<version>",
                    }
                },
                userAccounts = new object[]
                {
                    new
                    {
                        name = "<name>",
                        password = "<password>",
                        elevationLevel = "nonadmin",
                        linuxUserConfiguration = new
                        {
                            uid = 1234,
                            gid = 1234,
                            sshPrivateKey = "<sshPrivateKey>",
                        },
                        windowsUserConfiguration = new
                        {
                            loginMode = "batch",
                        },
                    }
                },
                metadata = new object[]
                {
                    new
                    {
                        name = "<name>",
                        value = "<value>",
                    }
                },
                mountConfiguration = new object[]
                {
                    new
                    {
                        azureBlobFileSystemConfiguration = new
                        {
                            accountName = "<accountName>",
                            containerName = "<containerName>",
                            accountKey = "<accountKey>",
                            sasKey = "<sasKey>",
                            blobfuseOptions = "<blobfuseOptions>",
                            relativeMountPath = "<relativeMountPath>",
                        },
                        nfsMountConfiguration = new
                        {
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                        cifsMountConfiguration = new
                        {
                            username = "<username>",
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                            password = "<password>",
                        },
                        azureFileShareConfiguration = new
                        {
                            accountName = "<accountName>",
                            azureFileUrl = "<azureFileUrl>",
                            accountKey = "<accountKey>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                    }
                },
                targetNodeCommunicationMode = "default",
                upgradePolicy = new
                {
                    mode = "automatic",
                    automaticOSUpgradePolicy = new
                    {
                        disableAutomaticRollback = true,
                        enableAutomaticOSUpgrade = true,
                        useRollingUpgradePolicy = true,
                        osRollingUpgradeDeferral = true,
                    },
                    rollingUpgradePolicy = new
                    {
                        enableCrossZoneUpgrade = true,
                        maxBatchInstancePercent = 1234,
                        maxUnhealthyInstancePercent = 1234,
                        maxUnhealthyUpgradedInstancePercent = 1234,
                        pauseTimeBetweenBatches = "PT1H23M45S",
                        prioritizeUnhealthyInstances = true,
                        rollbackFailedInstancesOnPolicyBreach = true,
                    },
                },
            },
        },
    },
    onAllTasksComplete = "noaction",
    metadata = new object[]
    {
        null
    },
});
Response response = await client.ReplaceJobAsync("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplaceJobSchedule (string jobScheduleId, Azure.Compute.Batch.BatchJobSchedule jobSchedule, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplaceJobSchedule(string jobScheduleId, class Azure.Compute.Batch.BatchJobSchedule jobSchedule, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceJobSchedule(System.String,Azure.Compute.Batch.BatchJobSchedule,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceJobSchedule (jobScheduleId As String, jobSchedule As BatchJobSchedule, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplaceJobSchedule : string * Azure.Compute.Batch.BatchJobSchedule * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.ReplaceJobSchedule : string * Azure.Compute.Batch.BatchJobSchedule * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.ReplaceJobSchedule (jobScheduleId, jobSchedule, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="jobSchedule" Type="Azure.Compute.Batch.BatchJobSchedule" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        <param name="jobSchedule"> A Job Schedule with updated properties. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the properties of the specified Job Schedule. </summary>
        <returns>To be added.</returns>
        <remarks>
            This fully replaces all the updatable properties of the Job Schedule. For
            example, if the schedule property is not specified with this request, then the
            Batch service will remove the existing schedule. Changes to a Job Schedule only
            impact Jobs created by the schedule after the update has taken place; currently
            running Jobs are unaffected.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> or <paramref name="jobSchedule" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplaceJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobSchedule jobSchedule = new BatchJobSchedule(new BatchJobSpecification(new BatchPoolInfo()));
Response response = client.ReplaceJobSchedule("<jobScheduleId>", jobSchedule);
]]></code>
This sample shows how to call ReplaceJobSchedule with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobSchedule jobSchedule = new BatchJobSchedule(new BatchJobSpecification(new BatchPoolInfo
{
    PoolId = "<poolId>",
    AutoPoolSpecification = new BatchAutoPoolSpecification(BatchPoolLifetimeOption.JobSchedule)
    {
        AutoPoolIdPrefix = "<autoPoolIdPrefix>",
        KeepAlive = true,
        Pool = new BatchPoolSpecification("<vmSize>")
        {
            DisplayName = "<displayName>",
            VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
            {
                Publisher = "<publisher>",
                Offer = "<offer>",
                Sku = "<sku>",
                Version = "<version>",
                VirtualMachineImageId = "<virtualMachineImageId>",
            }, "<nodeAgentSKUId>")
            {
                WindowsConfiguration = new WindowsConfiguration
                {
                    EnableAutomaticUpdates = true,
                },
                DataDisks = {new DataDisk(1234, 1234)
                {
                    Caching = CachingType.None,
                    StorageAccountType = StorageAccountType.StandardLRS,
                }},
                LicenseType = "<licenseType>",
                ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
                {
                    ContainerImageNames = { "<containerImageNames>" },
                    ContainerRegistries = { default },
                },
                DiskEncryptionConfiguration = new DiskEncryptionConfiguration
                {
                    Targets = { DiskEncryptionTarget.OsDisk },
                },
                NodePlacementConfiguration = new BatchNodePlacementConfiguration
                {
                    Policy = BatchNodePlacementPolicyType.Regional,
                },
                Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
                {
                    TypeHandlerVersion = "<typeHandlerVersion>",
                    AutoUpgradeMinorVersion = true,
                    EnableAutomaticUpgrade = true,
                    Settings =
                    {
                        ["key"] = "<settings>"
                    },
                    ProtectedSettings =
                    {
                        ["key"] = "<protectedSettings>"
                    },
                    ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
                }},
                OsDisk = new OSDisk
                {
                    EphemeralOSDiskSettings = new DiffDiskSettings
                    {
                        Placement = DiffDiskPlacement.CacheDisk,
                    },
                    Caching = CachingType.None,
                    DiskSizeGB = 1234,
                    ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
                    WriteAcceleratorEnabled = true,
                },
                SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
                {
                    SecureBootEnabled = true,
                    VTpmEnabled = true,
                }),
                ServiceArtifactReference = new ServiceArtifactReference("<id>"),
            },
            TaskSlotsPerNode = 1234,
            TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
            ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
            ResourceTags = "<resourceTags>",
            TargetDedicatedNodes = 1234,
            TargetLowPriorityNodes = 1234,
            EnableAutoScale = true,
            AutoScaleFormula = "<autoScaleFormula>",
            AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
            EnableInterNodeCommunication = true,
            NetworkConfiguration = new NetworkConfiguration
            {
                SubnetId = "<subnetId>",
                DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
                EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
                {
                    new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
                    {
                        NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                        {
                            SourcePortRanges = {"<sourcePortRanges>"},
                        }},
                    }
                }),
                PublicIpAddressConfiguration = new PublicIpAddressConfiguration
                {
                    IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
                    IpAddressIds = { "<ipAddressIds>" },
                },
                EnableAcceleratedNetworking = true,
            },
            StartTask = new BatchStartTask("<commandLine>")
            {
                ContainerSettings = default,
                ResourceFiles = { default },
                EnvironmentSettings = { default },
                UserIdentity = default,
                MaxTaskRetryCount = 1234,
                WaitForSuccess = true,
            },
            ApplicationPackageReferences = { default },
            UserAccounts = {new UserAccount("<name>", "<password>")
            {
                ElevationLevel = ElevationLevel.NonAdmin,
                LinuxUserConfiguration = new LinuxUserConfiguration
                {
                    Uid = 1234,
                    Gid = 1234,
                    SshPrivateKey = "<sshPrivateKey>",
                },
                WindowsUserConfiguration = new WindowsUserConfiguration
                {
                    LoginMode = LoginMode.Batch,
                },
            }},
            Metadata = { new MetadataItem("<name>", "<value>") },
            MountConfiguration = {new MountConfiguration
            {
                AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
                {
                    AccountKey = "<accountKey>",
                    SasKey = "<sasKey>",
                    BlobfuseOptions = "<blobfuseOptions>",
                    IdentityReference = default,
                },
                NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
                CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
                {
                    MountOptions = "<mountOptions>",
                },
                AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
            }},
            TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
            UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
            {
                AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
                {
                    DisableAutomaticRollback = true,
                    EnableAutomaticOsUpgrade = true,
                    UseRollingUpgradePolicy = true,
                    OsRollingUpgradeDeferral = true,
                },
                RollingUpgradePolicy = new RollingUpgradePolicy
                {
                    EnableCrossZoneUpgrade = true,
                    MaxBatchInstancePercent = 1234,
                    MaxUnhealthyInstancePercent = 1234,
                    MaxUnhealthyUpgradedInstancePercent = 1234,
                    PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
                    PrioritizeUnhealthyInstances = true,
                    RollbackFailedInstancesOnPolicyBreach = true,
                },
            },
        },
    },
})
{
    Priority = 1234,
    AllowTaskPreemption = true,
    MaxParallelTasks = 1234,
    DisplayName = "<displayName>",
    UsesTaskDependencies = true,
    OnAllTasksComplete = OnAllBatchTasksComplete.NoAction,
    OnTaskFailure = OnBatchTaskFailure.NoAction,
    NetworkConfiguration = new BatchJobNetworkConfiguration("<subnetId>"),
    Constraints = new BatchJobConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    JobManagerTask = new BatchJobManagerTask("<id>", "<commandLine>")
    {
        DisplayName = "<displayName>",
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
        {
            Container = new OutputFileBlobContainerDestination("<containerUrl>")
            {
                Path = "<path>",
                IdentityReference = default,
                UploadHeaders = {new HttpHeader("<name>")
                {
                    Value = "<value>",
                }},
            },
        }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        Constraints = new BatchTaskConstraints
        {
            MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            MaxTaskRetryCount = 1234,
        },
        RequiredSlots = 1234,
        KillJobOnCompletion = true,
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        RunExclusive = true,
        ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
        {
            Version = "<version>",
        }},
        AuthenticationTokenSettings = new AuthenticationTokenSettings
        {
            Access = { AccessScope.Job },
        },
        AllowLowPriorityNode = true,
    },
    JobPreparationTask = new BatchJobPreparationTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        Constraints = default,
        WaitForSuccess = true,
        UserIdentity = default,
        RerunOnNodeRebootAfterSuccess = true,
    },
    JobReleaseTask = new BatchJobReleaseTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        UserIdentity = default,
    },
    CommonEnvironmentSettings = { default },
    Metadata = { default },
})
{
    Schedule = new BatchJobScheduleConfiguration
    {
        DoNotRunUntil = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
        DoNotRunAfter = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
        StartWindow = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RecurrenceInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
    },
    Metadata = { default },
};
Response response = client.ReplaceJobSchedule("<jobScheduleId>", jobSchedule, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplaceJobSchedule (string jobScheduleId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplaceJobSchedule(string jobScheduleId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceJobSchedule(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceJobSchedule (jobScheduleId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplaceJobSchedule : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ReplaceJobSchedule : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.ReplaceJobSchedule (jobScheduleId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplaceJobSchedule(System.String,Azure.Compute.Batch.BatchJobSchedule,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplaceJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    jobSpecification = new
    {
        poolInfo = new object(),
    },
});
Response response = client.ReplaceJobSchedule("<jobScheduleId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplaceJobSchedule with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    schedule = new
    {
        doNotRunUntil = "2022-05-10T18:57:31.2311892Z",
        doNotRunAfter = "2022-05-10T18:57:31.2311892Z",
        startWindow = "PT1H23M45S",
        recurrenceInterval = "PT1H23M45S",
    },
    jobSpecification = new
    {
        priority = 1234,
        allowTaskPreemption = true,
        maxParallelTasks = 1234,
        displayName = "<displayName>",
        usesTaskDependencies = true,
        onAllTasksComplete = "noaction",
        onTaskFailure = "noaction",
        networkConfiguration = new
        {
            subnetId = "<subnetId>",
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        jobManagerTask = new
        {
            id = "<id>",
            displayName = "<displayName>",
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            killJobOnCompletion = true,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            runExclusive = true,
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
            allowLowPriorityNode = true,
        },
        jobPreparationTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            waitForSuccess = true,
            rerunOnNodeRebootAfterSuccess = true,
        },
        jobReleaseTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
        },
        commonEnvironmentSettings = new object[]
        {
            null
        },
        poolInfo = new
        {
            poolId = "<poolId>",
            autoPoolSpecification = new
            {
                autoPoolIdPrefix = "<autoPoolIdPrefix>",
                poolLifetimeOption = "jobschedule",
                keepAlive = true,
                pool = new
                {
                    displayName = "<displayName>",
                    vmSize = "<vmSize>",
                    virtualMachineConfiguration = new
                    {
                        imageReference = new
                        {
                            publisher = "<publisher>",
                            offer = "<offer>",
                            sku = "<sku>",
                            version = "<version>",
                            virtualMachineImageId = "<virtualMachineImageId>",
                        },
                        nodeAgentSKUId = "<nodeAgentSKUId>",
                        windowsConfiguration = new
                        {
                            enableAutomaticUpdates = true,
                        },
                        dataDisks = new object[]
                        {
                            new
                            {
                                lun = 1234,
                                caching = "none",
                                diskSizeGB = 1234,
                                storageAccountType = "standard_lrs",
                            }
                        },
                        licenseType = "<licenseType>",
                        containerConfiguration = new
                        {
                            type = "dockerCompatible",
                            containerImageNames = new object[]
                            {
                                "<containerImageNames>"
                            },
                            containerRegistries = new object[]
                            {
                                null
                            },
                        },
                        diskEncryptionConfiguration = new
                        {
                            targets = new object[]
                            {
                                "osdisk"
                            },
                        },
                        nodePlacementConfiguration = new
                        {
                            policy = "regional",
                        },
                        extensions = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                publisher = "<publisher>",
                                type = "<type>",
                                typeHandlerVersion = "<typeHandlerVersion>",
                                autoUpgradeMinorVersion = true,
                                enableAutomaticUpgrade = true,
                                settings = new
                                {
                                    key = "<settings>",
                                },
                                protectedSettings = new
                                {
                                    key = "<protectedSettings>",
                                },
                                provisionAfterExtensions = new object[]
                                {
                                    "<provisionAfterExtensions>"
                                },
                            }
                        },
                        osDisk = new
                        {
                            ephemeralOSDiskSettings = new
                            {
                                placement = "cachedisk",
                            },
                            caching = "none",
                            diskSizeGB = 1234,
                            managedDisk = new
                            {
                                storageAccountType = "standard_lrs",
                            },
                            writeAcceleratorEnabled = true,
                        },
                        securityProfile = new
                        {
                            encryptionAtHost = true,
                            securityType = "trustedLaunch",
                            uefiSettings = new
                            {
                                secureBootEnabled = true,
                                vTpmEnabled = true,
                            },
                        },
                        serviceArtifactReference = new
                        {
                            id = "<id>",
                        },
                    },
                    taskSlotsPerNode = 1234,
                    taskSchedulingPolicy = new
                    {
                        nodeFillType = "spread",
                    },
                    resizeTimeout = "PT1H23M45S",
                    resourceTags = "<resourceTags>",
                    targetDedicatedNodes = 1234,
                    targetLowPriorityNodes = 1234,
                    enableAutoScale = true,
                    autoScaleFormula = "<autoScaleFormula>",
                    autoScaleEvaluationInterval = "PT1H23M45S",
                    enableInterNodeCommunication = true,
                    networkConfiguration = new
                    {
                        subnetId = "<subnetId>",
                        dynamicVNetAssignmentScope = "none",
                        endpointConfiguration = new
                        {
                            inboundNATPools = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    protocol = "tcp",
                                    backendPort = 1234,
                                    frontendPortRangeStart = 1234,
                                    frontendPortRangeEnd = 1234,
                                    networkSecurityGroupRules = new object[]
                                    {
                                        new
                                        {
                                            priority = 1234,
                                            access = "allow",
                                            sourceAddressPrefix = "<sourceAddressPrefix>",
                                            sourcePortRanges = new object[]
                                            {
                                                "<sourcePortRanges>"
                                            },
                                        }
                                    },
                                }
                            },
                        },
                        publicIPAddressConfiguration = new
                        {
                            provision = "batchmanaged",
                            ipAddressIds = new object[]
                            {
                                "<ipAddressIds>"
                            },
                        },
                        enableAcceleratedNetworking = true,
                    },
                    startTask = new
                    {
                        commandLine = "<commandLine>",
                        resourceFiles = new object[]
                        {
                            null
                        },
                        environmentSettings = new object[]
                        {
                            null
                        },
                        maxTaskRetryCount = 1234,
                        waitForSuccess = true,
                    },
                    applicationPackageReferences = new object[]
                    {
                        null
                    },
                    userAccounts = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            password = "<password>",
                            elevationLevel = "nonadmin",
                            linuxUserConfiguration = new
                            {
                                uid = 1234,
                                gid = 1234,
                                sshPrivateKey = "<sshPrivateKey>",
                            },
                            windowsUserConfiguration = new
                            {
                                loginMode = "batch",
                            },
                        }
                    },
                    metadata = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    mountConfiguration = new object[]
                    {
                        new
                        {
                            azureBlobFileSystemConfiguration = new
                            {
                                accountName = "<accountName>",
                                containerName = "<containerName>",
                                accountKey = "<accountKey>",
                                sasKey = "<sasKey>",
                                blobfuseOptions = "<blobfuseOptions>",
                                relativeMountPath = "<relativeMountPath>",
                            },
                            nfsMountConfiguration = new
                            {
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                            cifsMountConfiguration = new
                            {
                                username = "<username>",
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                                password = "<password>",
                            },
                            azureFileShareConfiguration = new
                            {
                                accountName = "<accountName>",
                                azureFileUrl = "<azureFileUrl>",
                                accountKey = "<accountKey>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                        }
                    },
                    targetNodeCommunicationMode = "default",
                    upgradePolicy = new
                    {
                        mode = "automatic",
                        automaticOSUpgradePolicy = new
                        {
                            disableAutomaticRollback = true,
                            enableAutomaticOSUpgrade = true,
                            useRollingUpgradePolicy = true,
                            osRollingUpgradeDeferral = true,
                        },
                        rollingUpgradePolicy = new
                        {
                            enableCrossZoneUpgrade = true,
                            maxBatchInstancePercent = 1234,
                            maxUnhealthyInstancePercent = 1234,
                            maxUnhealthyUpgradedInstancePercent = 1234,
                            pauseTimeBetweenBatches = "PT1H23M45S",
                            prioritizeUnhealthyInstances = true,
                            rollbackFailedInstancesOnPolicyBreach = true,
                        },
                    },
                },
            },
        },
        metadata = new object[]
        {
            null
        },
    },
    metadata = new object[]
    {
        null
    },
});
Response response = client.ReplaceJobSchedule("<jobScheduleId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplaceJobScheduleAsync (string jobScheduleId, Azure.Compute.Batch.BatchJobSchedule jobSchedule, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplaceJobScheduleAsync(string jobScheduleId, class Azure.Compute.Batch.BatchJobSchedule jobSchedule, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceJobScheduleAsync(System.String,Azure.Compute.Batch.BatchJobSchedule,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceJobScheduleAsync (jobScheduleId As String, jobSchedule As BatchJobSchedule, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplaceJobScheduleAsync : string * Azure.Compute.Batch.BatchJobSchedule * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplaceJobScheduleAsync : string * Azure.Compute.Batch.BatchJobSchedule * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplaceJobScheduleAsync (jobScheduleId, jobSchedule, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="jobSchedule" Type="Azure.Compute.Batch.BatchJobSchedule" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        <param name="jobSchedule"> A Job Schedule with updated properties. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the properties of the specified Job Schedule. </summary>
        <returns>To be added.</returns>
        <remarks>
            This fully replaces all the updatable properties of the Job Schedule. For
            example, if the schedule property is not specified with this request, then the
            Batch service will remove the existing schedule. Changes to a Job Schedule only
            impact Jobs created by the schedule after the update has taken place; currently
            running Jobs are unaffected.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> or <paramref name="jobSchedule" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplaceJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobSchedule jobSchedule = new BatchJobSchedule(new BatchJobSpecification(new BatchPoolInfo()));
Response response = await client.ReplaceJobScheduleAsync("<jobScheduleId>", jobSchedule);
]]></code>
This sample shows how to call ReplaceJobScheduleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobSchedule jobSchedule = new BatchJobSchedule(new BatchJobSpecification(new BatchPoolInfo
{
    PoolId = "<poolId>",
    AutoPoolSpecification = new BatchAutoPoolSpecification(BatchPoolLifetimeOption.JobSchedule)
    {
        AutoPoolIdPrefix = "<autoPoolIdPrefix>",
        KeepAlive = true,
        Pool = new BatchPoolSpecification("<vmSize>")
        {
            DisplayName = "<displayName>",
            VirtualMachineConfiguration = new VirtualMachineConfiguration(new ImageReference
            {
                Publisher = "<publisher>",
                Offer = "<offer>",
                Sku = "<sku>",
                Version = "<version>",
                VirtualMachineImageId = "<virtualMachineImageId>",
            }, "<nodeAgentSKUId>")
            {
                WindowsConfiguration = new WindowsConfiguration
                {
                    EnableAutomaticUpdates = true,
                },
                DataDisks = {new DataDisk(1234, 1234)
                {
                    Caching = CachingType.None,
                    StorageAccountType = StorageAccountType.StandardLRS,
                }},
                LicenseType = "<licenseType>",
                ContainerConfiguration = new ContainerConfiguration(ContainerType.DockerCompatible)
                {
                    ContainerImageNames = { "<containerImageNames>" },
                    ContainerRegistries = { default },
                },
                DiskEncryptionConfiguration = new DiskEncryptionConfiguration
                {
                    Targets = { DiskEncryptionTarget.OsDisk },
                },
                NodePlacementConfiguration = new BatchNodePlacementConfiguration
                {
                    Policy = BatchNodePlacementPolicyType.Regional,
                },
                Extensions = {new VMExtension("<name>", "<publisher>", "<type>")
                {
                    TypeHandlerVersion = "<typeHandlerVersion>",
                    AutoUpgradeMinorVersion = true,
                    EnableAutomaticUpgrade = true,
                    Settings =
                    {
                        ["key"] = "<settings>"
                    },
                    ProtectedSettings =
                    {
                        ["key"] = "<protectedSettings>"
                    },
                    ProvisionAfterExtensions = {"<provisionAfterExtensions>"},
                }},
                OsDisk = new OSDisk
                {
                    EphemeralOSDiskSettings = new DiffDiskSettings
                    {
                        Placement = DiffDiskPlacement.CacheDisk,
                    },
                    Caching = CachingType.None,
                    DiskSizeGB = 1234,
                    ManagedDisk = new ManagedDisk(StorageAccountType.StandardLRS),
                    WriteAcceleratorEnabled = true,
                },
                SecurityProfile = new SecurityProfile(true, SecurityTypes.TrustedLaunch, new UefiSettings
                {
                    SecureBootEnabled = true,
                    VTpmEnabled = true,
                }),
                ServiceArtifactReference = new ServiceArtifactReference("<id>"),
            },
            TaskSlotsPerNode = 1234,
            TaskSchedulingPolicy = new BatchTaskSchedulingPolicy(BatchNodeFillType.Spread),
            ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
            ResourceTags = "<resourceTags>",
            TargetDedicatedNodes = 1234,
            TargetLowPriorityNodes = 1234,
            EnableAutoScale = true,
            AutoScaleFormula = "<autoScaleFormula>",
            AutoScaleEvaluationInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
            EnableInterNodeCommunication = true,
            NetworkConfiguration = new NetworkConfiguration
            {
                SubnetId = "<subnetId>",
                DynamicVNetAssignmentScope = DynamicVNetAssignmentScope.None,
                EndpointConfiguration = new BatchPoolEndpointConfiguration(new InboundNatPool[]
                {
                    new InboundNatPool("<name>", InboundEndpointProtocol.Tcp, 1234, 1234, 1234)
                    {
                        NetworkSecurityGroupRules = {new NetworkSecurityGroupRule(1234, NetworkSecurityGroupRuleAccess.Allow, "<sourceAddressPrefix>")
                        {
                            SourcePortRanges = {"<sourcePortRanges>"},
                        }},
                    }
                }),
                PublicIpAddressConfiguration = new PublicIpAddressConfiguration
                {
                    IpAddressProvisioningType = IpAddressProvisioningType.BatchManaged,
                    IpAddressIds = { "<ipAddressIds>" },
                },
                EnableAcceleratedNetworking = true,
            },
            StartTask = new BatchStartTask("<commandLine>")
            {
                ContainerSettings = default,
                ResourceFiles = { default },
                EnvironmentSettings = { default },
                UserIdentity = default,
                MaxTaskRetryCount = 1234,
                WaitForSuccess = true,
            },
            ApplicationPackageReferences = { default },
            UserAccounts = {new UserAccount("<name>", "<password>")
            {
                ElevationLevel = ElevationLevel.NonAdmin,
                LinuxUserConfiguration = new LinuxUserConfiguration
                {
                    Uid = 1234,
                    Gid = 1234,
                    SshPrivateKey = "<sshPrivateKey>",
                },
                WindowsUserConfiguration = new WindowsUserConfiguration
                {
                    LoginMode = LoginMode.Batch,
                },
            }},
            Metadata = { new MetadataItem("<name>", "<value>") },
            MountConfiguration = {new MountConfiguration
            {
                AzureBlobFileSystemConfiguration = new AzureBlobFileSystemConfiguration("<accountName>", "<containerName>", "<relativeMountPath>")
                {
                    AccountKey = "<accountKey>",
                    SasKey = "<sasKey>",
                    BlobfuseOptions = "<blobfuseOptions>",
                    IdentityReference = default,
                },
                NfsMountConfiguration = new NfsMountConfiguration("<source>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
                CifsMountConfiguration = new CifsMountConfiguration("<username>", "<source>", "<relativeMountPath>", "<password>")
                {
                    MountOptions = "<mountOptions>",
                },
                AzureFileShareConfiguration = new AzureFileShareConfiguration("<accountName>", "<azureFileUrl>", "<accountKey>", "<relativeMountPath>")
                {
                    MountOptions = "<mountOptions>",
                },
            }},
            TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
            UpgradePolicy = new UpgradePolicy(UpgradeMode.Automatic)
            {
                AutomaticOsUpgradePolicy = new AutomaticOsUpgradePolicy
                {
                    DisableAutomaticRollback = true,
                    EnableAutomaticOsUpgrade = true,
                    UseRollingUpgradePolicy = true,
                    OsRollingUpgradeDeferral = true,
                },
                RollingUpgradePolicy = new RollingUpgradePolicy
                {
                    EnableCrossZoneUpgrade = true,
                    MaxBatchInstancePercent = 1234,
                    MaxUnhealthyInstancePercent = 1234,
                    MaxUnhealthyUpgradedInstancePercent = 1234,
                    PauseTimeBetweenBatches = XmlConvert.ToTimeSpan("PT1H23M45S"),
                    PrioritizeUnhealthyInstances = true,
                    RollbackFailedInstancesOnPolicyBreach = true,
                },
            },
        },
    },
})
{
    Priority = 1234,
    AllowTaskPreemption = true,
    MaxParallelTasks = 1234,
    DisplayName = "<displayName>",
    UsesTaskDependencies = true,
    OnAllTasksComplete = OnAllBatchTasksComplete.NoAction,
    OnTaskFailure = OnBatchTaskFailure.NoAction,
    NetworkConfiguration = new BatchJobNetworkConfiguration("<subnetId>"),
    Constraints = new BatchJobConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
    JobManagerTask = new BatchJobManagerTask("<id>", "<commandLine>")
    {
        DisplayName = "<displayName>",
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        OutputFiles = {new OutputFile("<filePattern>", new OutputFileDestination
        {
            Container = new OutputFileBlobContainerDestination("<containerUrl>")
            {
                Path = "<path>",
                IdentityReference = default,
                UploadHeaders = {new HttpHeader("<name>")
                {
                    Value = "<value>",
                }},
            },
        }, new OutputFileUploadConfig(OutputFileUploadCondition.TaskSuccess))},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        Constraints = new BatchTaskConstraints
        {
            MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
            MaxTaskRetryCount = 1234,
        },
        RequiredSlots = 1234,
        KillJobOnCompletion = true,
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        RunExclusive = true,
        ApplicationPackageReferences = {new BatchApplicationPackageReference("<applicationId>")
        {
            Version = "<version>",
        }},
        AuthenticationTokenSettings = new AuthenticationTokenSettings
        {
            Access = { AccessScope.Job },
        },
        AllowLowPriorityNode = true,
    },
    JobPreparationTask = new BatchJobPreparationTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        Constraints = default,
        WaitForSuccess = true,
        UserIdentity = default,
        RerunOnNodeRebootAfterSuccess = true,
    },
    JobReleaseTask = new BatchJobReleaseTask("<commandLine>")
    {
        Id = "<id>",
        ContainerSettings = default,
        ResourceFiles = { default },
        EnvironmentSettings = { default },
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        UserIdentity = default,
    },
    CommonEnvironmentSettings = { default },
    Metadata = { default },
})
{
    Schedule = new BatchJobScheduleConfiguration
    {
        DoNotRunUntil = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
        DoNotRunAfter = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
        StartWindow = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RecurrenceInterval = XmlConvert.ToTimeSpan("PT1H23M45S"),
    },
    Metadata = { default },
};
Response response = await client.ReplaceJobScheduleAsync("<jobScheduleId>", jobSchedule, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplaceJobScheduleAsync (string jobScheduleId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplaceJobScheduleAsync(string jobScheduleId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceJobScheduleAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceJobScheduleAsync (jobScheduleId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplaceJobScheduleAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplaceJobScheduleAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplaceJobScheduleAsync (jobScheduleId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplaceJobScheduleAsync(System.String,Azure.Compute.Batch.BatchJobSchedule,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplaceJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    jobSpecification = new
    {
        poolInfo = new object(),
    },
});
Response response = await client.ReplaceJobScheduleAsync("<jobScheduleId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplaceJobScheduleAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    schedule = new
    {
        doNotRunUntil = "2022-05-10T18:57:31.2311892Z",
        doNotRunAfter = "2022-05-10T18:57:31.2311892Z",
        startWindow = "PT1H23M45S",
        recurrenceInterval = "PT1H23M45S",
    },
    jobSpecification = new
    {
        priority = 1234,
        allowTaskPreemption = true,
        maxParallelTasks = 1234,
        displayName = "<displayName>",
        usesTaskDependencies = true,
        onAllTasksComplete = "noaction",
        onTaskFailure = "noaction",
        networkConfiguration = new
        {
            subnetId = "<subnetId>",
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        jobManagerTask = new
        {
            id = "<id>",
            displayName = "<displayName>",
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            killJobOnCompletion = true,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            runExclusive = true,
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
            allowLowPriorityNode = true,
        },
        jobPreparationTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            waitForSuccess = true,
            rerunOnNodeRebootAfterSuccess = true,
        },
        jobReleaseTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
        },
        commonEnvironmentSettings = new object[]
        {
            null
        },
        poolInfo = new
        {
            poolId = "<poolId>",
            autoPoolSpecification = new
            {
                autoPoolIdPrefix = "<autoPoolIdPrefix>",
                poolLifetimeOption = "jobschedule",
                keepAlive = true,
                pool = new
                {
                    displayName = "<displayName>",
                    vmSize = "<vmSize>",
                    virtualMachineConfiguration = new
                    {
                        imageReference = new
                        {
                            publisher = "<publisher>",
                            offer = "<offer>",
                            sku = "<sku>",
                            version = "<version>",
                            virtualMachineImageId = "<virtualMachineImageId>",
                        },
                        nodeAgentSKUId = "<nodeAgentSKUId>",
                        windowsConfiguration = new
                        {
                            enableAutomaticUpdates = true,
                        },
                        dataDisks = new object[]
                        {
                            new
                            {
                                lun = 1234,
                                caching = "none",
                                diskSizeGB = 1234,
                                storageAccountType = "standard_lrs",
                            }
                        },
                        licenseType = "<licenseType>",
                        containerConfiguration = new
                        {
                            type = "dockerCompatible",
                            containerImageNames = new object[]
                            {
                                "<containerImageNames>"
                            },
                            containerRegistries = new object[]
                            {
                                null
                            },
                        },
                        diskEncryptionConfiguration = new
                        {
                            targets = new object[]
                            {
                                "osdisk"
                            },
                        },
                        nodePlacementConfiguration = new
                        {
                            policy = "regional",
                        },
                        extensions = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                publisher = "<publisher>",
                                type = "<type>",
                                typeHandlerVersion = "<typeHandlerVersion>",
                                autoUpgradeMinorVersion = true,
                                enableAutomaticUpgrade = true,
                                settings = new
                                {
                                    key = "<settings>",
                                },
                                protectedSettings = new
                                {
                                    key = "<protectedSettings>",
                                },
                                provisionAfterExtensions = new object[]
                                {
                                    "<provisionAfterExtensions>"
                                },
                            }
                        },
                        osDisk = new
                        {
                            ephemeralOSDiskSettings = new
                            {
                                placement = "cachedisk",
                            },
                            caching = "none",
                            diskSizeGB = 1234,
                            managedDisk = new
                            {
                                storageAccountType = "standard_lrs",
                            },
                            writeAcceleratorEnabled = true,
                        },
                        securityProfile = new
                        {
                            encryptionAtHost = true,
                            securityType = "trustedLaunch",
                            uefiSettings = new
                            {
                                secureBootEnabled = true,
                                vTpmEnabled = true,
                            },
                        },
                        serviceArtifactReference = new
                        {
                            id = "<id>",
                        },
                    },
                    taskSlotsPerNode = 1234,
                    taskSchedulingPolicy = new
                    {
                        nodeFillType = "spread",
                    },
                    resizeTimeout = "PT1H23M45S",
                    resourceTags = "<resourceTags>",
                    targetDedicatedNodes = 1234,
                    targetLowPriorityNodes = 1234,
                    enableAutoScale = true,
                    autoScaleFormula = "<autoScaleFormula>",
                    autoScaleEvaluationInterval = "PT1H23M45S",
                    enableInterNodeCommunication = true,
                    networkConfiguration = new
                    {
                        subnetId = "<subnetId>",
                        dynamicVNetAssignmentScope = "none",
                        endpointConfiguration = new
                        {
                            inboundNATPools = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    protocol = "tcp",
                                    backendPort = 1234,
                                    frontendPortRangeStart = 1234,
                                    frontendPortRangeEnd = 1234,
                                    networkSecurityGroupRules = new object[]
                                    {
                                        new
                                        {
                                            priority = 1234,
                                            access = "allow",
                                            sourceAddressPrefix = "<sourceAddressPrefix>",
                                            sourcePortRanges = new object[]
                                            {
                                                "<sourcePortRanges>"
                                            },
                                        }
                                    },
                                }
                            },
                        },
                        publicIPAddressConfiguration = new
                        {
                            provision = "batchmanaged",
                            ipAddressIds = new object[]
                            {
                                "<ipAddressIds>"
                            },
                        },
                        enableAcceleratedNetworking = true,
                    },
                    startTask = new
                    {
                        commandLine = "<commandLine>",
                        resourceFiles = new object[]
                        {
                            null
                        },
                        environmentSettings = new object[]
                        {
                            null
                        },
                        maxTaskRetryCount = 1234,
                        waitForSuccess = true,
                    },
                    applicationPackageReferences = new object[]
                    {
                        null
                    },
                    userAccounts = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            password = "<password>",
                            elevationLevel = "nonadmin",
                            linuxUserConfiguration = new
                            {
                                uid = 1234,
                                gid = 1234,
                                sshPrivateKey = "<sshPrivateKey>",
                            },
                            windowsUserConfiguration = new
                            {
                                loginMode = "batch",
                            },
                        }
                    },
                    metadata = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    mountConfiguration = new object[]
                    {
                        new
                        {
                            azureBlobFileSystemConfiguration = new
                            {
                                accountName = "<accountName>",
                                containerName = "<containerName>",
                                accountKey = "<accountKey>",
                                sasKey = "<sasKey>",
                                blobfuseOptions = "<blobfuseOptions>",
                                relativeMountPath = "<relativeMountPath>",
                            },
                            nfsMountConfiguration = new
                            {
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                            cifsMountConfiguration = new
                            {
                                username = "<username>",
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                                password = "<password>",
                            },
                            azureFileShareConfiguration = new
                            {
                                accountName = "<accountName>",
                                azureFileUrl = "<azureFileUrl>",
                                accountKey = "<accountKey>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                        }
                    },
                    targetNodeCommunicationMode = "default",
                    upgradePolicy = new
                    {
                        mode = "automatic",
                        automaticOSUpgradePolicy = new
                        {
                            disableAutomaticRollback = true,
                            enableAutomaticOSUpgrade = true,
                            useRollingUpgradePolicy = true,
                            osRollingUpgradeDeferral = true,
                        },
                        rollingUpgradePolicy = new
                        {
                            enableCrossZoneUpgrade = true,
                            maxBatchInstancePercent = 1234,
                            maxUnhealthyInstancePercent = 1234,
                            maxUnhealthyUpgradedInstancePercent = 1234,
                            pauseTimeBetweenBatches = "PT1H23M45S",
                            prioritizeUnhealthyInstances = true,
                            rollbackFailedInstancesOnPolicyBreach = true,
                        },
                    },
                },
            },
        },
        metadata = new object[]
        {
            null
        },
    },
    metadata = new object[]
    {
        null
    },
});
Response response = await client.ReplaceJobScheduleAsync("<jobScheduleId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceNodeUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplaceNodeUser (string poolId, string nodeId, string userName, Azure.Compute.Batch.BatchNodeUserUpdateContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplaceNodeUser(string poolId, string nodeId, string userName, class Azure.Compute.Batch.BatchNodeUserUpdateContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceNodeUser(System.String,System.String,System.String,Azure.Compute.Batch.BatchNodeUserUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceNodeUser (poolId As String, nodeId As String, userName As String, content As BatchNodeUserUpdateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplaceNodeUser : string * string * string * Azure.Compute.Batch.BatchNodeUserUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.ReplaceNodeUser : string * string * string * Azure.Compute.Batch.BatchNodeUserUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.ReplaceNodeUser (poolId, nodeId, userName, content, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchNodeUserUpdateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        <param name="userName"> The name of the user Account to update. </param>
        <param name="content"> The options to use for updating the user. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the password and expiration time of a user Account on the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>
            This operation replaces of all the updatable properties of the Account. For
            example, if the expiryTime element is not specified, the current value is
            replaced with the default value, not left unmodified. You can update a user
            Account on a Compute Node only when it is in the idle or running state.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" />, <paramref name="userName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="userName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplaceNodeUser.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeUserUpdateContent content = new BatchNodeUserUpdateContent();
Response response = client.ReplaceNodeUser("<poolId>", "<nodeId>", "<userName>", content);
]]></code>
This sample shows how to call ReplaceNodeUser with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeUserUpdateContent content = new BatchNodeUserUpdateContent
{
    Password = "<password>",
    ExpiryTime = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    SshPublicKey = "<sshPublicKey>",
};
Response response = client.ReplaceNodeUser("<poolId>", "<nodeId>", "<userName>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceNodeUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplaceNodeUser (string poolId, string nodeId, string userName, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplaceNodeUser(string poolId, string nodeId, string userName, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceNodeUser(System.String,System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceNodeUser (poolId As String, nodeId As String, userName As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplaceNodeUser : string * string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ReplaceNodeUser : string * string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.ReplaceNodeUser (poolId, nodeId, userName, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        <param name="userName"> The name of the user Account to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the password and expiration time of a user Account on the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplaceNodeUser(System.String,System.String,System.String,Azure.Compute.Batch.BatchNodeUserUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" />, <paramref name="userName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="userName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplaceNodeUser.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.ReplaceNodeUser("<poolId>", "<nodeId>", "<userName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplaceNodeUser with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    password = "<password>",
    expiryTime = "2022-05-10T18:57:31.2311892Z",
    sshPublicKey = "<sshPublicKey>",
});
Response response = client.ReplaceNodeUser("<poolId>", "<nodeId>", "<userName>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceNodeUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplaceNodeUserAsync (string poolId, string nodeId, string userName, Azure.Compute.Batch.BatchNodeUserUpdateContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplaceNodeUserAsync(string poolId, string nodeId, string userName, class Azure.Compute.Batch.BatchNodeUserUpdateContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceNodeUserAsync(System.String,System.String,System.String,Azure.Compute.Batch.BatchNodeUserUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceNodeUserAsync (poolId As String, nodeId As String, userName As String, content As BatchNodeUserUpdateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplaceNodeUserAsync : string * string * string * Azure.Compute.Batch.BatchNodeUserUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplaceNodeUserAsync : string * string * string * Azure.Compute.Batch.BatchNodeUserUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplaceNodeUserAsync (poolId, nodeId, userName, content, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchNodeUserUpdateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        <param name="userName"> The name of the user Account to update. </param>
        <param name="content"> The options to use for updating the user. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the password and expiration time of a user Account on the specified Compute Node. </summary>
        <returns>To be added.</returns>
        <remarks>
            This operation replaces of all the updatable properties of the Account. For
            example, if the expiryTime element is not specified, the current value is
            replaced with the default value, not left unmodified. You can update a user
            Account on a Compute Node only when it is in the idle or running state.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" />, <paramref name="userName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="userName" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplaceNodeUserAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeUserUpdateContent content = new BatchNodeUserUpdateContent();
Response response = await client.ReplaceNodeUserAsync("<poolId>", "<nodeId>", "<userName>", content);
]]></code>
This sample shows how to call ReplaceNodeUserAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchNodeUserUpdateContent content = new BatchNodeUserUpdateContent
{
    Password = "<password>",
    ExpiryTime = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    SshPublicKey = "<sshPublicKey>",
};
Response response = await client.ReplaceNodeUserAsync("<poolId>", "<nodeId>", "<userName>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceNodeUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplaceNodeUserAsync (string poolId, string nodeId, string userName, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplaceNodeUserAsync(string poolId, string nodeId, string userName, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceNodeUserAsync(System.String,System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceNodeUserAsync (poolId As String, nodeId As String, userName As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplaceNodeUserAsync : string * string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplaceNodeUserAsync : string * string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplaceNodeUserAsync (poolId, nodeId, userName, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        <param name="userName"> The name of the user Account to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the password and expiration time of a user Account on the specified Compute Node.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplaceNodeUserAsync(System.String,System.String,System.String,Azure.Compute.Batch.BatchNodeUserUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" />, <paramref name="userName" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="userName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplaceNodeUserAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.ReplaceNodeUserAsync("<poolId>", "<nodeId>", "<userName>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplaceNodeUserAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    password = "<password>",
    expiryTime = "2022-05-10T18:57:31.2311892Z",
    sshPublicKey = "<sshPublicKey>",
});
Response response = await client.ReplaceNodeUserAsync("<poolId>", "<nodeId>", "<userName>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplacePoolProperties">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplacePoolProperties (string poolId, Azure.Compute.Batch.BatchPoolReplaceContent pool, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplacePoolProperties(string poolId, class Azure.Compute.Batch.BatchPoolReplaceContent pool, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplacePoolProperties(System.String,Azure.Compute.Batch.BatchPoolReplaceContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplacePoolProperties (poolId As String, pool As BatchPoolReplaceContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplacePoolProperties : string * Azure.Compute.Batch.BatchPoolReplaceContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.ReplacePoolProperties : string * Azure.Compute.Batch.BatchPoolReplaceContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.ReplacePoolProperties (poolId, pool, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="pool" Type="Azure.Compute.Batch.BatchPoolReplaceContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to update. </param>
        <param name="pool"> The options to use for replacing properties on the pool. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the properties of the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            This fully replaces all the updatable properties of the Pool. For example, if
            the Pool has a StartTask associated with it and if StartTask is not specified
            with this request, then the Batch service will remove the existing StartTask.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="pool" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplacePoolProperties.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolReplaceContent pool = new BatchPoolReplaceContent(new BatchApplicationPackageReference[]
{
    new BatchApplicationPackageReference("<applicationId>")
}, new MetadataItem[]
{
    new MetadataItem("<name>", "<value>")
});
Response response = client.ReplacePoolProperties("<poolId>", pool);
]]></code>
This sample shows how to call ReplacePoolProperties with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolReplaceContent pool = new BatchPoolReplaceContent(new BatchApplicationPackageReference[]
{
    new BatchApplicationPackageReference("<applicationId>")
    {
        Version = "<version>",
    }
}, new MetadataItem[]
{
    new MetadataItem("<name>", "<value>")
})
{
    StartTask = new BatchStartTask("<commandLine>")
    {
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        MaxTaskRetryCount = 1234,
        WaitForSuccess = true,
    },
    TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
};
Response response = client.ReplacePoolProperties("<poolId>", pool, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplacePoolProperties">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplacePoolProperties (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplacePoolProperties(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplacePoolProperties(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplacePoolProperties (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplacePoolProperties : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ReplacePoolProperties : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.ReplacePoolProperties (poolId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplacePoolProperties(System.String,Azure.Compute.Batch.BatchPoolReplaceContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplacePoolProperties.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
});
Response response = client.ReplacePoolProperties("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplacePoolProperties with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    startTask = new
    {
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            registry = new
            {
                username = "<username>",
                password = "<password>",
                registryServer = "<registryServer>",
                identityReference = new
                {
                    resourceId = "<resourceId>",
                },
            },
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        maxTaskRetryCount = 1234,
        waitForSuccess = true,
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    targetNodeCommunicationMode = "default",
});
Response response = client.ReplacePoolProperties("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplacePoolPropertiesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplacePoolPropertiesAsync (string poolId, Azure.Compute.Batch.BatchPoolReplaceContent pool, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplacePoolPropertiesAsync(string poolId, class Azure.Compute.Batch.BatchPoolReplaceContent pool, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplacePoolPropertiesAsync(System.String,Azure.Compute.Batch.BatchPoolReplaceContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplacePoolPropertiesAsync (poolId As String, pool As BatchPoolReplaceContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplacePoolPropertiesAsync : string * Azure.Compute.Batch.BatchPoolReplaceContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplacePoolPropertiesAsync : string * Azure.Compute.Batch.BatchPoolReplaceContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplacePoolPropertiesAsync (poolId, pool, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="pool" Type="Azure.Compute.Batch.BatchPoolReplaceContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to update. </param>
        <param name="pool"> The options to use for replacing properties on the pool. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the properties of the specified Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            This fully replaces all the updatable properties of the Pool. For example, if
            the Pool has a StartTask associated with it and if StartTask is not specified
            with this request, then the Batch service will remove the existing StartTask.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="pool" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplacePoolPropertiesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolReplaceContent pool = new BatchPoolReplaceContent(new BatchApplicationPackageReference[]
{
    new BatchApplicationPackageReference("<applicationId>")
}, new MetadataItem[]
{
    new MetadataItem("<name>", "<value>")
});
Response response = await client.ReplacePoolPropertiesAsync("<poolId>", pool);
]]></code>
This sample shows how to call ReplacePoolPropertiesAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolReplaceContent pool = new BatchPoolReplaceContent(new BatchApplicationPackageReference[]
{
    new BatchApplicationPackageReference("<applicationId>")
    {
        Version = "<version>",
    }
}, new MetadataItem[]
{
    new MetadataItem("<name>", "<value>")
})
{
    StartTask = new BatchStartTask("<commandLine>")
    {
        ContainerSettings = new BatchTaskContainerSettings("<imageName>")
        {
            ContainerRunOptions = "<containerRunOptions>",
            Registry = new ContainerRegistryReference
            {
                Username = "<username>",
                Password = "<password>",
                RegistryServer = "<registryServer>",
                IdentityReference = new BatchNodeIdentityReference
                {
                    ResourceId = "<resourceId>",
                },
            },
            WorkingDirectory = ContainerWorkingDirectory.TaskWorkingDirectory,
        },
        ResourceFiles = {new ResourceFile
        {
            AutoStorageContainerName = "<autoStorageContainerName>",
            StorageContainerUrl = "<storageContainerUrl>",
            HttpUrl = "<httpUrl>",
            BlobPrefix = "<blobPrefix>",
            FilePath = "<filePath>",
            FileMode = "<fileMode>",
            IdentityReference = default,
        }},
        EnvironmentSettings = {new EnvironmentSetting("<name>")
        {
            Value = "<value>",
        }},
        UserIdentity = new UserIdentity
        {
            Username = "<username>",
            AutoUser = new AutoUserSpecification
            {
                Scope = AutoUserScope.Task,
                ElevationLevel = ElevationLevel.NonAdmin,
            },
        },
        MaxTaskRetryCount = 1234,
        WaitForSuccess = true,
    },
    TargetNodeCommunicationMode = BatchNodeCommunicationMode.Default,
};
Response response = await client.ReplacePoolPropertiesAsync("<poolId>", pool, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplacePoolPropertiesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplacePoolPropertiesAsync (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplacePoolPropertiesAsync(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplacePoolPropertiesAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplacePoolPropertiesAsync (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplacePoolPropertiesAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplacePoolPropertiesAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplacePoolPropertiesAsync (poolId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplacePoolPropertiesAsync(System.String,Azure.Compute.Batch.BatchPoolReplaceContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplacePoolPropertiesAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
});
Response response = await client.ReplacePoolPropertiesAsync("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplacePoolPropertiesAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    startTask = new
    {
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            registry = new
            {
                username = "<username>",
                password = "<password>",
                registryServer = "<registryServer>",
                identityReference = new
                {
                    resourceId = "<resourceId>",
                },
            },
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        maxTaskRetryCount = 1234,
        waitForSuccess = true,
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    targetNodeCommunicationMode = "default",
});
Response response = await client.ReplacePoolPropertiesAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplaceTask (string jobId, string taskId, Azure.Compute.Batch.BatchTask task, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplaceTask(string jobId, string taskId, class Azure.Compute.Batch.BatchTask task, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceTask(System.String,System.String,Azure.Compute.Batch.BatchTask,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceTask (jobId As String, taskId As String, task As BatchTask, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplaceTask : string * string * Azure.Compute.Batch.BatchTask * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.ReplaceTask : string * string * Azure.Compute.Batch.BatchTask * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.ReplaceTask (jobId, taskId, task, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="task" Type="Azure.Compute.Batch.BatchTask" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job containing the Task. </param>
        <param name="taskId"> The ID of the Task to update. </param>
        <param name="task"> The Task to update. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the properties of the specified Task. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="task" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplaceTask.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTask task = new BatchTask();
Response response = client.ReplaceTask("<jobId>", "<taskId>", task);
]]></code>
This sample shows how to call ReplaceTask with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTask task = new BatchTask
{
    Constraints = new BatchTaskConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
};
Response response = client.ReplaceTask("<jobId>", "<taskId>", task, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ReplaceTask (string jobId, string taskId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ReplaceTask(string jobId, string taskId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceTask(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceTask (jobId As String, taskId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ReplaceTask : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ReplaceTask : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.ReplaceTask (jobId, taskId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job containing the Task. </param>
        <param name="taskId"> The ID of the Task to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Task.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplaceTask(System.String,System.String,Azure.Compute.Batch.BatchTask,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplaceTask.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.ReplaceTask("<jobId>", "<taskId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplaceTask with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        retentionTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
});
Response response = client.ReplaceTask("<jobId>", "<taskId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplaceTaskAsync (string jobId, string taskId, Azure.Compute.Batch.BatchTask task, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplaceTaskAsync(string jobId, string taskId, class Azure.Compute.Batch.BatchTask task, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceTaskAsync(System.String,System.String,Azure.Compute.Batch.BatchTask,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceTaskAsync (jobId As String, taskId As String, task As BatchTask, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplaceTaskAsync : string * string * Azure.Compute.Batch.BatchTask * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplaceTaskAsync : string * string * Azure.Compute.Batch.BatchTask * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplaceTaskAsync (jobId, taskId, task, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="task" Type="Azure.Compute.Batch.BatchTask" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job containing the Task. </param>
        <param name="taskId"> The ID of the Task to update. </param>
        <param name="task"> The Task to update. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Updates the properties of the specified Task. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="task" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ReplaceTaskAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTask task = new BatchTask();
Response response = await client.ReplaceTaskAsync("<jobId>", "<taskId>", task);
]]></code>
This sample shows how to call ReplaceTaskAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchTask task = new BatchTask
{
    Constraints = new BatchTaskConstraints
    {
        MaxWallClockTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        RetentionTime = XmlConvert.ToTimeSpan("PT1H23M45S"),
        MaxTaskRetryCount = 1234,
    },
};
Response response = await client.ReplaceTaskAsync("<jobId>", "<taskId>", task, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ReplaceTaskAsync (string jobId, string taskId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ReplaceTaskAsync(string jobId, string taskId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ReplaceTaskAsync(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceTaskAsync (jobId As String, taskId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ReplaceTaskAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ReplaceTaskAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ReplaceTaskAsync (jobId, taskId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job containing the Task. </param>
        <param name="taskId"> The ID of the Task to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Task.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ReplaceTaskAsync(System.String,System.String,Azure.Compute.Batch.BatchTask,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" />, <paramref name="taskId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ReplaceTaskAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.ReplaceTaskAsync("<jobId>", "<taskId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ReplaceTaskAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        retentionTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
});
Response response = await client.ReplaceTaskAsync("<jobId>", "<taskId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ResizePool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ResizePool (string poolId, Azure.Compute.Batch.BatchPoolResizeContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ResizePool(string poolId, class Azure.Compute.Batch.BatchPoolResizeContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ResizePool(System.String,Azure.Compute.Batch.BatchPoolResizeContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResizePool (poolId As String, content As BatchPoolResizeContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ResizePool : string * Azure.Compute.Batch.BatchPoolResizeContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.ResizePool : string * Azure.Compute.Batch.BatchPoolResizeContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.ResizePool (poolId, content, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchPoolResizeContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The options to use for resizing the pool. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Changes the number of Compute Nodes that are assigned to a Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            You can only resize a Pool when its allocation state is steady. If the Pool is
            already resizing, the request fails with status code 409. When you resize a
            Pool, the Pool's allocation state changes from steady to resizing. You cannot
            resize Pools which are configured for automatic scaling. If you try to do this,
            the Batch service returns an error 409. If you resize a Pool downwards, the
            Batch service chooses which Compute Nodes to remove. To remove specific Compute
            Nodes, use the Pool remove Compute Nodes API instead.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ResizePool.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolResizeContent content = new BatchPoolResizeContent();
Response response = client.ResizePool("<poolId>", content);
]]></code>
This sample shows how to call ResizePool with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolResizeContent content = new BatchPoolResizeContent
{
    TargetDedicatedNodes = 1234,
    TargetLowPriorityNodes = 1234,
    ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
    NodeDeallocationOption = BatchNodeDeallocationOption.Requeue,
};
Response response = client.ResizePool("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ResizePool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ResizePool (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ResizePool(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ResizePool(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResizePool (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ResizePool : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ResizePool : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.ResizePool (poolId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Changes the number of Compute Nodes that are assigned to a Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ResizePool(System.String,Azure.Compute.Batch.BatchPoolResizeContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ResizePool.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.ResizePool("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ResizePool with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    targetDedicatedNodes = 1234,
    targetLowPriorityNodes = 1234,
    resizeTimeout = "PT1H23M45S",
    nodeDeallocationOption = "requeue",
});
Response response = client.ResizePool("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ResizePoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ResizePoolAsync (string poolId, Azure.Compute.Batch.BatchPoolResizeContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ResizePoolAsync(string poolId, class Azure.Compute.Batch.BatchPoolResizeContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ResizePoolAsync(System.String,Azure.Compute.Batch.BatchPoolResizeContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResizePoolAsync (poolId As String, content As BatchPoolResizeContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ResizePoolAsync : string * Azure.Compute.Batch.BatchPoolResizeContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ResizePoolAsync : string * Azure.Compute.Batch.BatchPoolResizeContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ResizePoolAsync (poolId, content, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.BatchPoolResizeContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The options to use for resizing the pool. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Changes the number of Compute Nodes that are assigned to a Pool. </summary>
        <returns>To be added.</returns>
        <remarks>
            You can only resize a Pool when its allocation state is steady. If the Pool is
            already resizing, the request fails with status code 409. When you resize a
            Pool, the Pool's allocation state changes from steady to resizing. You cannot
            resize Pools which are configured for automatic scaling. If you try to do this,
            the Batch service returns an error 409. If you resize a Pool downwards, the
            Batch service chooses which Compute Nodes to remove. To remove specific Compute
            Nodes, use the Pool remove Compute Nodes API instead.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call ResizePoolAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolResizeContent content = new BatchPoolResizeContent();
Response response = await client.ResizePoolAsync("<poolId>", content);
]]></code>
This sample shows how to call ResizePoolAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchPoolResizeContent content = new BatchPoolResizeContent
{
    TargetDedicatedNodes = 1234,
    TargetLowPriorityNodes = 1234,
    ResizeTimeout = XmlConvert.ToTimeSpan("PT1H23M45S"),
    NodeDeallocationOption = BatchNodeDeallocationOption.Requeue,
};
Response response = await client.ResizePoolAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ResizePoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ResizePoolAsync (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ResizePoolAsync(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.ResizePoolAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResizePoolAsync (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ResizePoolAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ResizePoolAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.ResizePoolAsync (poolId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Changes the number of Compute Nodes that are assigned to a Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.ResizePoolAsync(System.String,Azure.Compute.Batch.BatchPoolResizeContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ResizePoolAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.ResizePoolAsync("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call ResizePoolAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    targetDedicatedNodes = 1234,
    targetLowPriorityNodes = 1234,
    resizeTimeout = "PT1H23M45S",
    nodeDeallocationOption = "requeue",
});
Response response = await client.ResizePoolAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="StopPoolResize">
      <MemberSignature Language="C#" Value="public virtual Azure.Response StopPoolResize (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response StopPoolResize(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.StopPoolResize(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopPoolResize (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member StopPoolResize : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.StopPoolResize : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.StopPoolResize (poolId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Stops an ongoing resize operation on the Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call StopPoolResize.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.StopPoolResize("<poolId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call StopPoolResize with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.StopPoolResize("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="StopPoolResizeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; StopPoolResizeAsync (string poolId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; StopPoolResizeAsync(string poolId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.StopPoolResizeAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopPoolResizeAsync (poolId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member StopPoolResizeAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.StopPoolResizeAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.StopPoolResizeAsync (poolId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Stops an ongoing resize operation on the Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call StopPoolResizeAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.StopPoolResizeAsync("<poolId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call StopPoolResizeAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.StopPoolResizeAsync("<poolId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="TerminateJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response TerminateJob (string jobId, Azure.Compute.Batch.BatchJobTerminateContent parameters = default, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response TerminateJob(string jobId, class Azure.Compute.Batch.BatchJobTerminateContent parameters, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.TerminateJob(System.String,Azure.Compute.Batch.BatchJobTerminateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TerminateJob (jobId As String, Optional parameters As BatchJobTerminateContent = Nothing, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member TerminateJob : string * Azure.Compute.Batch.BatchJobTerminateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.TerminateJob : string * Azure.Compute.Batch.BatchJobTerminateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.TerminateJob (jobId, parameters, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="parameters" Type="Azure.Compute.Batch.BatchJobTerminateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to terminate. </param>
        <param name="parameters"> The options to use for terminating the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Terminates the specified Job, marking it as completed. </summary>
        <returns>To be added.</returns>
        <remarks>
            When a Terminate Job request is received, the Batch service sets the Job to the
            terminating state. The Batch service then terminates any running Tasks
            associated with the Job and runs any required Job release Tasks. Then the Job
            moves into the completed state. If there are any Tasks in the Job in the active
            state, they will remain in the active state. Once a Job is terminated, new
            Tasks cannot be added and any remaining active Tasks will not be scheduled.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call TerminateJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.TerminateJob("<jobId>");
]]></code>
This sample shows how to call TerminateJob with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobTerminateContent parameters = new BatchJobTerminateContent
{
    TerminationReason = "<terminateReason>",
};
Response response = client.TerminateJob("<jobId>", parameters: parameters, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="TerminateJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response TerminateJob (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response TerminateJob(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.TerminateJob(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TerminateJob (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member TerminateJob : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.TerminateJob : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.TerminateJob (jobId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to terminate. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Terminates the specified Job, marking it as completed.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.TerminateJob(System.String,Azure.Compute.Batch.BatchJobTerminateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call TerminateJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = null;
Response response = client.TerminateJob("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call TerminateJob with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    terminateReason = "<terminateReason>",
});
Response response = client.TerminateJob("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="TerminateJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; TerminateJobAsync (string jobId, Azure.Compute.Batch.BatchJobTerminateContent parameters = default, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; TerminateJobAsync(string jobId, class Azure.Compute.Batch.BatchJobTerminateContent parameters, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.TerminateJobAsync(System.String,Azure.Compute.Batch.BatchJobTerminateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TerminateJobAsync (jobId As String, Optional parameters As BatchJobTerminateContent = Nothing, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member TerminateJobAsync : string * Azure.Compute.Batch.BatchJobTerminateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.TerminateJobAsync : string * Azure.Compute.Batch.BatchJobTerminateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.TerminateJobAsync (jobId, parameters, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="parameters" Type="Azure.Compute.Batch.BatchJobTerminateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to terminate. </param>
        <param name="parameters"> The options to use for terminating the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Terminates the specified Job, marking it as completed. </summary>
        <returns>To be added.</returns>
        <remarks>
            When a Terminate Job request is received, the Batch service sets the Job to the
            terminating state. The Batch service then terminates any running Tasks
            associated with the Job and runs any required Job release Tasks. Then the Job
            moves into the completed state. If there are any Tasks in the Job in the active
            state, they will remain in the active state. Once a Job is terminated, new
            Tasks cannot be added and any remaining active Tasks will not be scheduled.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call TerminateJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.TerminateJobAsync("<jobId>");
]]></code>
This sample shows how to call TerminateJobAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

BatchJobTerminateContent parameters = new BatchJobTerminateContent
{
    TerminationReason = "<terminateReason>",
};
Response response = await client.TerminateJobAsync("<jobId>", parameters: parameters, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="TerminateJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; TerminateJobAsync (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; TerminateJobAsync(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.TerminateJobAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TerminateJobAsync (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member TerminateJobAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.TerminateJobAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.TerminateJobAsync (jobId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job to terminate. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Terminates the specified Job, marking it as completed.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.TerminateJobAsync(System.String,Azure.Compute.Batch.BatchJobTerminateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call TerminateJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = null;
Response response = await client.TerminateJobAsync("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call TerminateJobAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    terminateReason = "<terminateReason>",
});
Response response = await client.TerminateJobAsync("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="TerminateJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response TerminateJobSchedule (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response TerminateJobSchedule(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.TerminateJobSchedule(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TerminateJobSchedule (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member TerminateJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.TerminateJobSchedule : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.TerminateJobSchedule (jobScheduleId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to terminates. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Terminates a Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call TerminateJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.TerminateJobSchedule("<jobScheduleId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call TerminateJobSchedule with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.TerminateJobSchedule("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="TerminateJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; TerminateJobScheduleAsync (string jobScheduleId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; TerminateJobScheduleAsync(string jobScheduleId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.TerminateJobScheduleAsync(System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TerminateJobScheduleAsync (jobScheduleId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member TerminateJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.TerminateJobScheduleAsync : string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.TerminateJobScheduleAsync (jobScheduleId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to terminates. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Terminates a Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call TerminateJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.TerminateJobScheduleAsync("<jobScheduleId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call TerminateJobScheduleAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.TerminateJobScheduleAsync("<jobScheduleId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="TerminateTask">
      <MemberSignature Language="C#" Value="public virtual Azure.Response TerminateTask (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response TerminateTask(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.TerminateTask(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TerminateTask (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member TerminateTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.TerminateTask : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.TerminateTask (jobId, taskId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job containing the Task. </param>
        <param name="taskId"> The ID of the Task to terminate. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Terminates the specified Task.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call TerminateTask.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.TerminateTask("<jobId>", "<taskId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call TerminateTask with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = client.TerminateTask("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="TerminateTaskAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; TerminateTaskAsync (string jobId, string taskId, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; TerminateTaskAsync(string jobId, string taskId, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.TerminateTaskAsync(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TerminateTaskAsync (jobId As String, taskId As String, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member TerminateTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.TerminateTaskAsync : string * string * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.TerminateTaskAsync (jobId, taskId, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="taskId" Type="System.String" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job containing the Task. </param>
        <param name="taskId"> The ID of the Task to terminate. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Terminates the specified Task.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> or <paramref name="taskId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call TerminateTaskAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.TerminateTaskAsync("<jobId>", "<taskId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call TerminateTaskAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

Response response = await client.TerminateTaskAsync("<jobId>", "<taskId>", timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateJob (string jobId, Azure.Compute.Batch.BatchJobUpdateContent job, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateJob(string jobId, class Azure.Compute.Batch.BatchJobUpdateContent job, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdateJob(System.String,Azure.Compute.Batch.BatchJobUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateJob (jobId As String, job As BatchJobUpdateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateJob : string * Azure.Compute.Batch.BatchJobUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.UpdateJob : string * Azure.Compute.Batch.BatchJobUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.UpdateJob (jobId, job, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="job" Type="Azure.Compute.Batch.BatchJobUpdateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        <param name="job"> The options to use for updating the Job. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="job" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdateJob("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateJob with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    priority = 1234,
    allowTaskPreemption = true,
    maxParallelTasks = 1234,
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    poolInfo = new
    {
        poolId = "<poolId>",
        autoPoolSpecification = new
        {
            autoPoolIdPrefix = "<autoPoolIdPrefix>",
            poolLifetimeOption = "jobschedule",
            keepAlive = true,
            pool = new
            {
                displayName = "<displayName>",
                vmSize = "<vmSize>",
                virtualMachineConfiguration = new
                {
                    imageReference = new
                    {
                        publisher = "<publisher>",
                        offer = "<offer>",
                        sku = "<sku>",
                        version = "<version>",
                        virtualMachineImageId = "<virtualMachineImageId>",
                    },
                    nodeAgentSKUId = "<nodeAgentSKUId>",
                    windowsConfiguration = new
                    {
                        enableAutomaticUpdates = true,
                    },
                    dataDisks = new object[]
                    {
                        new
                        {
                            lun = 1234,
                            caching = "none",
                            diskSizeGB = 1234,
                            storageAccountType = "standard_lrs",
                        }
                    },
                    licenseType = "<licenseType>",
                    containerConfiguration = new
                    {
                        type = "dockerCompatible",
                        containerImageNames = new object[]
                        {
                            "<containerImageNames>"
                        },
                        containerRegistries = new object[]
                        {
                            new
                            {
                                username = "<username>",
                                password = "<password>",
                                registryServer = "<registryServer>",
                                identityReference = new
                                {
                                    resourceId = "<resourceId>",
                                },
                            }
                        },
                    },
                    diskEncryptionConfiguration = new
                    {
                        targets = new object[]
                        {
                            "osdisk"
                        },
                    },
                    nodePlacementConfiguration = new
                    {
                        policy = "regional",
                    },
                    extensions = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            publisher = "<publisher>",
                            type = "<type>",
                            typeHandlerVersion = "<typeHandlerVersion>",
                            autoUpgradeMinorVersion = true,
                            enableAutomaticUpgrade = true,
                            settings = new
                            {
                                key = "<settings>",
                            },
                            protectedSettings = new
                            {
                                key = "<protectedSettings>",
                            },
                            provisionAfterExtensions = new object[]
                            {
                                "<provisionAfterExtensions>"
                            },
                        }
                    },
                    osDisk = new
                    {
                        ephemeralOSDiskSettings = new
                        {
                            placement = "cachedisk",
                        },
                        caching = "none",
                        diskSizeGB = 1234,
                        managedDisk = new
                        {
                            storageAccountType = "standard_lrs",
                        },
                        writeAcceleratorEnabled = true,
                    },
                    securityProfile = new
                    {
                        encryptionAtHost = true,
                        securityType = "trustedLaunch",
                        uefiSettings = new
                        {
                            secureBootEnabled = true,
                            vTpmEnabled = true,
                        },
                    },
                    serviceArtifactReference = new
                    {
                        id = "<id>",
                    },
                },
                taskSlotsPerNode = 1234,
                taskSchedulingPolicy = new
                {
                    nodeFillType = "spread",
                },
                resizeTimeout = "PT1H23M45S",
                resourceTags = "<resourceTags>",
                targetDedicatedNodes = 1234,
                targetLowPriorityNodes = 1234,
                enableAutoScale = true,
                autoScaleFormula = "<autoScaleFormula>",
                autoScaleEvaluationInterval = "PT1H23M45S",
                enableInterNodeCommunication = true,
                networkConfiguration = new
                {
                    subnetId = "<subnetId>",
                    dynamicVNetAssignmentScope = "none",
                    endpointConfiguration = new
                    {
                        inboundNATPools = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                protocol = "tcp",
                                backendPort = 1234,
                                frontendPortRangeStart = 1234,
                                frontendPortRangeEnd = 1234,
                                networkSecurityGroupRules = new object[]
                                {
                                    new
                                    {
                                        priority = 1234,
                                        access = "allow",
                                        sourceAddressPrefix = "<sourceAddressPrefix>",
                                        sourcePortRanges = new object[]
                                        {
                                            "<sourcePortRanges>"
                                        },
                                    }
                                },
                            }
                        },
                    },
                    publicIPAddressConfiguration = new
                    {
                        provision = "batchmanaged",
                        ipAddressIds = new object[]
                        {
                            "<ipAddressIds>"
                        },
                    },
                    enableAcceleratedNetworking = true,
                },
                startTask = new
                {
                    commandLine = "<commandLine>",
                    containerSettings = new
                    {
                        containerRunOptions = "<containerRunOptions>",
                        imageName = "<imageName>",
                        workingDirectory = "taskWorkingDirectory",
                    },
                    resourceFiles = new object[]
                    {
                        new
                        {
                            autoStorageContainerName = "<autoStorageContainerName>",
                            storageContainerUrl = "<storageContainerUrl>",
                            httpUrl = "<httpUrl>",
                            blobPrefix = "<blobPrefix>",
                            filePath = "<filePath>",
                            fileMode = "<fileMode>",
                        }
                    },
                    environmentSettings = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    userIdentity = new
                    {
                        username = "<username>",
                        autoUser = new
                        {
                            scope = "task",
                            elevationLevel = "nonadmin",
                        },
                    },
                    maxTaskRetryCount = 1234,
                    waitForSuccess = true,
                },
                applicationPackageReferences = new object[]
                {
                    new
                    {
                        applicationId = "<applicationId>",
                        version = "<version>",
                    }
                },
                userAccounts = new object[]
                {
                    new
                    {
                        name = "<name>",
                        password = "<password>",
                        elevationLevel = "nonadmin",
                        linuxUserConfiguration = new
                        {
                            uid = 1234,
                            gid = 1234,
                            sshPrivateKey = "<sshPrivateKey>",
                        },
                        windowsUserConfiguration = new
                        {
                            loginMode = "batch",
                        },
                    }
                },
                metadata = new object[]
                {
                    new
                    {
                        name = "<name>",
                        value = "<value>",
                    }
                },
                mountConfiguration = new object[]
                {
                    new
                    {
                        azureBlobFileSystemConfiguration = new
                        {
                            accountName = "<accountName>",
                            containerName = "<containerName>",
                            accountKey = "<accountKey>",
                            sasKey = "<sasKey>",
                            blobfuseOptions = "<blobfuseOptions>",
                            relativeMountPath = "<relativeMountPath>",
                        },
                        nfsMountConfiguration = new
                        {
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                        cifsMountConfiguration = new
                        {
                            username = "<username>",
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                            password = "<password>",
                        },
                        azureFileShareConfiguration = new
                        {
                            accountName = "<accountName>",
                            azureFileUrl = "<azureFileUrl>",
                            accountKey = "<accountKey>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                    }
                },
                targetNodeCommunicationMode = "default",
                upgradePolicy = new
                {
                    mode = "automatic",
                    automaticOSUpgradePolicy = new
                    {
                        disableAutomaticRollback = true,
                        enableAutomaticOSUpgrade = true,
                        useRollingUpgradePolicy = true,
                        osRollingUpgradeDeferral = true,
                    },
                    rollingUpgradePolicy = new
                    {
                        enableCrossZoneUpgrade = true,
                        maxBatchInstancePercent = 1234,
                        maxUnhealthyInstancePercent = 1234,
                        maxUnhealthyUpgradedInstancePercent = 1234,
                        pauseTimeBetweenBatches = "PT1H23M45S",
                        prioritizeUnhealthyInstances = true,
                        rollbackFailedInstancesOnPolicyBreach = true,
                    },
                },
            },
        },
    },
    onAllTasksComplete = "noaction",
    metadata = new object[]
    {
        null
    },
});
Response response = client.UpdateJob("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateJob">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateJob (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateJob(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdateJob(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateJob (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateJob : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdateJob : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.UpdateJob (jobId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateJob.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdateJob("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateJob with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    priority = 1234,
    allowTaskPreemption = true,
    maxParallelTasks = 1234,
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    poolInfo = new
    {
        poolId = "<poolId>",
        autoPoolSpecification = new
        {
            autoPoolIdPrefix = "<autoPoolIdPrefix>",
            poolLifetimeOption = "jobschedule",
            keepAlive = true,
            pool = new
            {
                displayName = "<displayName>",
                vmSize = "<vmSize>",
                virtualMachineConfiguration = new
                {
                    imageReference = new
                    {
                        publisher = "<publisher>",
                        offer = "<offer>",
                        sku = "<sku>",
                        version = "<version>",
                        virtualMachineImageId = "<virtualMachineImageId>",
                    },
                    nodeAgentSKUId = "<nodeAgentSKUId>",
                    windowsConfiguration = new
                    {
                        enableAutomaticUpdates = true,
                    },
                    dataDisks = new object[]
                    {
                        new
                        {
                            lun = 1234,
                            caching = "none",
                            diskSizeGB = 1234,
                            storageAccountType = "standard_lrs",
                        }
                    },
                    licenseType = "<licenseType>",
                    containerConfiguration = new
                    {
                        type = "dockerCompatible",
                        containerImageNames = new object[]
                        {
                            "<containerImageNames>"
                        },
                        containerRegistries = new object[]
                        {
                            new
                            {
                                username = "<username>",
                                password = "<password>",
                                registryServer = "<registryServer>",
                                identityReference = new
                                {
                                    resourceId = "<resourceId>",
                                },
                            }
                        },
                    },
                    diskEncryptionConfiguration = new
                    {
                        targets = new object[]
                        {
                            "osdisk"
                        },
                    },
                    nodePlacementConfiguration = new
                    {
                        policy = "regional",
                    },
                    extensions = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            publisher = "<publisher>",
                            type = "<type>",
                            typeHandlerVersion = "<typeHandlerVersion>",
                            autoUpgradeMinorVersion = true,
                            enableAutomaticUpgrade = true,
                            settings = new
                            {
                                key = "<settings>",
                            },
                            protectedSettings = new
                            {
                                key = "<protectedSettings>",
                            },
                            provisionAfterExtensions = new object[]
                            {
                                "<provisionAfterExtensions>"
                            },
                        }
                    },
                    osDisk = new
                    {
                        ephemeralOSDiskSettings = new
                        {
                            placement = "cachedisk",
                        },
                        caching = "none",
                        diskSizeGB = 1234,
                        managedDisk = new
                        {
                            storageAccountType = "standard_lrs",
                        },
                        writeAcceleratorEnabled = true,
                    },
                    securityProfile = new
                    {
                        encryptionAtHost = true,
                        securityType = "trustedLaunch",
                        uefiSettings = new
                        {
                            secureBootEnabled = true,
                            vTpmEnabled = true,
                        },
                    },
                    serviceArtifactReference = new
                    {
                        id = "<id>",
                    },
                },
                taskSlotsPerNode = 1234,
                taskSchedulingPolicy = new
                {
                    nodeFillType = "spread",
                },
                resizeTimeout = "PT1H23M45S",
                resourceTags = "<resourceTags>",
                targetDedicatedNodes = 1234,
                targetLowPriorityNodes = 1234,
                enableAutoScale = true,
                autoScaleFormula = "<autoScaleFormula>",
                autoScaleEvaluationInterval = "PT1H23M45S",
                enableInterNodeCommunication = true,
                networkConfiguration = new
                {
                    subnetId = "<subnetId>",
                    dynamicVNetAssignmentScope = "none",
                    endpointConfiguration = new
                    {
                        inboundNATPools = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                protocol = "tcp",
                                backendPort = 1234,
                                frontendPortRangeStart = 1234,
                                frontendPortRangeEnd = 1234,
                                networkSecurityGroupRules = new object[]
                                {
                                    new
                                    {
                                        priority = 1234,
                                        access = "allow",
                                        sourceAddressPrefix = "<sourceAddressPrefix>",
                                        sourcePortRanges = new object[]
                                        {
                                            "<sourcePortRanges>"
                                        },
                                    }
                                },
                            }
                        },
                    },
                    publicIPAddressConfiguration = new
                    {
                        provision = "batchmanaged",
                        ipAddressIds = new object[]
                        {
                            "<ipAddressIds>"
                        },
                    },
                    enableAcceleratedNetworking = true,
                },
                startTask = new
                {
                    commandLine = "<commandLine>",
                    containerSettings = new
                    {
                        containerRunOptions = "<containerRunOptions>",
                        imageName = "<imageName>",
                        workingDirectory = "taskWorkingDirectory",
                    },
                    resourceFiles = new object[]
                    {
                        new
                        {
                            autoStorageContainerName = "<autoStorageContainerName>",
                            storageContainerUrl = "<storageContainerUrl>",
                            httpUrl = "<httpUrl>",
                            blobPrefix = "<blobPrefix>",
                            filePath = "<filePath>",
                            fileMode = "<fileMode>",
                        }
                    },
                    environmentSettings = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    userIdentity = new
                    {
                        username = "<username>",
                        autoUser = new
                        {
                            scope = "task",
                            elevationLevel = "nonadmin",
                        },
                    },
                    maxTaskRetryCount = 1234,
                    waitForSuccess = true,
                },
                applicationPackageReferences = new object[]
                {
                    new
                    {
                        applicationId = "<applicationId>",
                        version = "<version>",
                    }
                },
                userAccounts = new object[]
                {
                    new
                    {
                        name = "<name>",
                        password = "<password>",
                        elevationLevel = "nonadmin",
                        linuxUserConfiguration = new
                        {
                            uid = 1234,
                            gid = 1234,
                            sshPrivateKey = "<sshPrivateKey>",
                        },
                        windowsUserConfiguration = new
                        {
                            loginMode = "batch",
                        },
                    }
                },
                metadata = new object[]
                {
                    new
                    {
                        name = "<name>",
                        value = "<value>",
                    }
                },
                mountConfiguration = new object[]
                {
                    new
                    {
                        azureBlobFileSystemConfiguration = new
                        {
                            accountName = "<accountName>",
                            containerName = "<containerName>",
                            accountKey = "<accountKey>",
                            sasKey = "<sasKey>",
                            blobfuseOptions = "<blobfuseOptions>",
                            relativeMountPath = "<relativeMountPath>",
                        },
                        nfsMountConfiguration = new
                        {
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                        cifsMountConfiguration = new
                        {
                            username = "<username>",
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                            password = "<password>",
                        },
                        azureFileShareConfiguration = new
                        {
                            accountName = "<accountName>",
                            azureFileUrl = "<azureFileUrl>",
                            accountKey = "<accountKey>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                    }
                },
                targetNodeCommunicationMode = "default",
                upgradePolicy = new
                {
                    mode = "automatic",
                    automaticOSUpgradePolicy = new
                    {
                        disableAutomaticRollback = true,
                        enableAutomaticOSUpgrade = true,
                        useRollingUpgradePolicy = true,
                        osRollingUpgradeDeferral = true,
                    },
                    rollingUpgradePolicy = new
                    {
                        enableCrossZoneUpgrade = true,
                        maxBatchInstancePercent = 1234,
                        maxUnhealthyInstancePercent = 1234,
                        maxUnhealthyUpgradedInstancePercent = 1234,
                        pauseTimeBetweenBatches = "PT1H23M45S",
                        prioritizeUnhealthyInstances = true,
                        rollbackFailedInstancesOnPolicyBreach = true,
                    },
                },
            },
        },
    },
    onAllTasksComplete = "noaction",
    metadata = new object[]
    {
        null
    },
});
Response response = client.UpdateJob("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateJobAsync (string jobId, Azure.Compute.Batch.BatchJobUpdateContent job, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateJobAsync(string jobId, class Azure.Compute.Batch.BatchJobUpdateContent job, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdateJobAsync(System.String,Azure.Compute.Batch.BatchJobUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateJobAsync (jobId As String, job As BatchJobUpdateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateJobAsync : string * Azure.Compute.Batch.BatchJobUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateJobAsync : string * Azure.Compute.Batch.BatchJobUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.UpdateJobAsync (jobId, job, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="job" Type="Azure.Compute.Batch.BatchJobUpdateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        <param name="job"> The options to use for updating the Job.. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="job" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdateJobAsync("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateJobAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    priority = 1234,
    allowTaskPreemption = true,
    maxParallelTasks = 1234,
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    poolInfo = new
    {
        poolId = "<poolId>",
        autoPoolSpecification = new
        {
            autoPoolIdPrefix = "<autoPoolIdPrefix>",
            poolLifetimeOption = "jobschedule",
            keepAlive = true,
            pool = new
            {
                displayName = "<displayName>",
                vmSize = "<vmSize>",
                virtualMachineConfiguration = new
                {
                    imageReference = new
                    {
                        publisher = "<publisher>",
                        offer = "<offer>",
                        sku = "<sku>",
                        version = "<version>",
                        virtualMachineImageId = "<virtualMachineImageId>",
                    },
                    nodeAgentSKUId = "<nodeAgentSKUId>",
                    windowsConfiguration = new
                    {
                        enableAutomaticUpdates = true,
                    },
                    dataDisks = new object[]
                    {
                        new
                        {
                            lun = 1234,
                            caching = "none",
                            diskSizeGB = 1234,
                            storageAccountType = "standard_lrs",
                        }
                    },
                    licenseType = "<licenseType>",
                    containerConfiguration = new
                    {
                        type = "dockerCompatible",
                        containerImageNames = new object[]
                        {
                            "<containerImageNames>"
                        },
                        containerRegistries = new object[]
                        {
                            new
                            {
                                username = "<username>",
                                password = "<password>",
                                registryServer = "<registryServer>",
                                identityReference = new
                                {
                                    resourceId = "<resourceId>",
                                },
                            }
                        },
                    },
                    diskEncryptionConfiguration = new
                    {
                        targets = new object[]
                        {
                            "osdisk"
                        },
                    },
                    nodePlacementConfiguration = new
                    {
                        policy = "regional",
                    },
                    extensions = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            publisher = "<publisher>",
                            type = "<type>",
                            typeHandlerVersion = "<typeHandlerVersion>",
                            autoUpgradeMinorVersion = true,
                            enableAutomaticUpgrade = true,
                            settings = new
                            {
                                key = "<settings>",
                            },
                            protectedSettings = new
                            {
                                key = "<protectedSettings>",
                            },
                            provisionAfterExtensions = new object[]
                            {
                                "<provisionAfterExtensions>"
                            },
                        }
                    },
                    osDisk = new
                    {
                        ephemeralOSDiskSettings = new
                        {
                            placement = "cachedisk",
                        },
                        caching = "none",
                        diskSizeGB = 1234,
                        managedDisk = new
                        {
                            storageAccountType = "standard_lrs",
                        },
                        writeAcceleratorEnabled = true,
                    },
                    securityProfile = new
                    {
                        encryptionAtHost = true,
                        securityType = "trustedLaunch",
                        uefiSettings = new
                        {
                            secureBootEnabled = true,
                            vTpmEnabled = true,
                        },
                    },
                    serviceArtifactReference = new
                    {
                        id = "<id>",
                    },
                },
                taskSlotsPerNode = 1234,
                taskSchedulingPolicy = new
                {
                    nodeFillType = "spread",
                },
                resizeTimeout = "PT1H23M45S",
                resourceTags = "<resourceTags>",
                targetDedicatedNodes = 1234,
                targetLowPriorityNodes = 1234,
                enableAutoScale = true,
                autoScaleFormula = "<autoScaleFormula>",
                autoScaleEvaluationInterval = "PT1H23M45S",
                enableInterNodeCommunication = true,
                networkConfiguration = new
                {
                    subnetId = "<subnetId>",
                    dynamicVNetAssignmentScope = "none",
                    endpointConfiguration = new
                    {
                        inboundNATPools = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                protocol = "tcp",
                                backendPort = 1234,
                                frontendPortRangeStart = 1234,
                                frontendPortRangeEnd = 1234,
                                networkSecurityGroupRules = new object[]
                                {
                                    new
                                    {
                                        priority = 1234,
                                        access = "allow",
                                        sourceAddressPrefix = "<sourceAddressPrefix>",
                                        sourcePortRanges = new object[]
                                        {
                                            "<sourcePortRanges>"
                                        },
                                    }
                                },
                            }
                        },
                    },
                    publicIPAddressConfiguration = new
                    {
                        provision = "batchmanaged",
                        ipAddressIds = new object[]
                        {
                            "<ipAddressIds>"
                        },
                    },
                    enableAcceleratedNetworking = true,
                },
                startTask = new
                {
                    commandLine = "<commandLine>",
                    containerSettings = new
                    {
                        containerRunOptions = "<containerRunOptions>",
                        imageName = "<imageName>",
                        workingDirectory = "taskWorkingDirectory",
                    },
                    resourceFiles = new object[]
                    {
                        new
                        {
                            autoStorageContainerName = "<autoStorageContainerName>",
                            storageContainerUrl = "<storageContainerUrl>",
                            httpUrl = "<httpUrl>",
                            blobPrefix = "<blobPrefix>",
                            filePath = "<filePath>",
                            fileMode = "<fileMode>",
                        }
                    },
                    environmentSettings = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    userIdentity = new
                    {
                        username = "<username>",
                        autoUser = new
                        {
                            scope = "task",
                            elevationLevel = "nonadmin",
                        },
                    },
                    maxTaskRetryCount = 1234,
                    waitForSuccess = true,
                },
                applicationPackageReferences = new object[]
                {
                    new
                    {
                        applicationId = "<applicationId>",
                        version = "<version>",
                    }
                },
                userAccounts = new object[]
                {
                    new
                    {
                        name = "<name>",
                        password = "<password>",
                        elevationLevel = "nonadmin",
                        linuxUserConfiguration = new
                        {
                            uid = 1234,
                            gid = 1234,
                            sshPrivateKey = "<sshPrivateKey>",
                        },
                        windowsUserConfiguration = new
                        {
                            loginMode = "batch",
                        },
                    }
                },
                metadata = new object[]
                {
                    new
                    {
                        name = "<name>",
                        value = "<value>",
                    }
                },
                mountConfiguration = new object[]
                {
                    new
                    {
                        azureBlobFileSystemConfiguration = new
                        {
                            accountName = "<accountName>",
                            containerName = "<containerName>",
                            accountKey = "<accountKey>",
                            sasKey = "<sasKey>",
                            blobfuseOptions = "<blobfuseOptions>",
                            relativeMountPath = "<relativeMountPath>",
                        },
                        nfsMountConfiguration = new
                        {
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                        cifsMountConfiguration = new
                        {
                            username = "<username>",
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                            password = "<password>",
                        },
                        azureFileShareConfiguration = new
                        {
                            accountName = "<accountName>",
                            azureFileUrl = "<azureFileUrl>",
                            accountKey = "<accountKey>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                    }
                },
                targetNodeCommunicationMode = "default",
                upgradePolicy = new
                {
                    mode = "automatic",
                    automaticOSUpgradePolicy = new
                    {
                        disableAutomaticRollback = true,
                        enableAutomaticOSUpgrade = true,
                        useRollingUpgradePolicy = true,
                        osRollingUpgradeDeferral = true,
                    },
                    rollingUpgradePolicy = new
                    {
                        enableCrossZoneUpgrade = true,
                        maxBatchInstancePercent = 1234,
                        maxUnhealthyInstancePercent = 1234,
                        maxUnhealthyUpgradedInstancePercent = 1234,
                        pauseTimeBetweenBatches = "PT1H23M45S",
                        prioritizeUnhealthyInstances = true,
                        rollbackFailedInstancesOnPolicyBreach = true,
                    },
                },
            },
        },
    },
    onAllTasksComplete = "noaction",
    metadata = new object[]
    {
        null
    },
});
Response response = await client.UpdateJobAsync("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateJobAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateJobAsync (string jobId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateJobAsync(string jobId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdateJobAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateJobAsync (jobId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateJobAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateJobAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.UpdateJobAsync (jobId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateJobAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdateJobAsync("<jobId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateJobAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    priority = 1234,
    allowTaskPreemption = true,
    maxParallelTasks = 1234,
    constraints = new
    {
        maxWallClockTime = "PT1H23M45S",
        maxTaskRetryCount = 1234,
    },
    poolInfo = new
    {
        poolId = "<poolId>",
        autoPoolSpecification = new
        {
            autoPoolIdPrefix = "<autoPoolIdPrefix>",
            poolLifetimeOption = "jobschedule",
            keepAlive = true,
            pool = new
            {
                displayName = "<displayName>",
                vmSize = "<vmSize>",
                virtualMachineConfiguration = new
                {
                    imageReference = new
                    {
                        publisher = "<publisher>",
                        offer = "<offer>",
                        sku = "<sku>",
                        version = "<version>",
                        virtualMachineImageId = "<virtualMachineImageId>",
                    },
                    nodeAgentSKUId = "<nodeAgentSKUId>",
                    windowsConfiguration = new
                    {
                        enableAutomaticUpdates = true,
                    },
                    dataDisks = new object[]
                    {
                        new
                        {
                            lun = 1234,
                            caching = "none",
                            diskSizeGB = 1234,
                            storageAccountType = "standard_lrs",
                        }
                    },
                    licenseType = "<licenseType>",
                    containerConfiguration = new
                    {
                        type = "dockerCompatible",
                        containerImageNames = new object[]
                        {
                            "<containerImageNames>"
                        },
                        containerRegistries = new object[]
                        {
                            new
                            {
                                username = "<username>",
                                password = "<password>",
                                registryServer = "<registryServer>",
                                identityReference = new
                                {
                                    resourceId = "<resourceId>",
                                },
                            }
                        },
                    },
                    diskEncryptionConfiguration = new
                    {
                        targets = new object[]
                        {
                            "osdisk"
                        },
                    },
                    nodePlacementConfiguration = new
                    {
                        policy = "regional",
                    },
                    extensions = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            publisher = "<publisher>",
                            type = "<type>",
                            typeHandlerVersion = "<typeHandlerVersion>",
                            autoUpgradeMinorVersion = true,
                            enableAutomaticUpgrade = true,
                            settings = new
                            {
                                key = "<settings>",
                            },
                            protectedSettings = new
                            {
                                key = "<protectedSettings>",
                            },
                            provisionAfterExtensions = new object[]
                            {
                                "<provisionAfterExtensions>"
                            },
                        }
                    },
                    osDisk = new
                    {
                        ephemeralOSDiskSettings = new
                        {
                            placement = "cachedisk",
                        },
                        caching = "none",
                        diskSizeGB = 1234,
                        managedDisk = new
                        {
                            storageAccountType = "standard_lrs",
                        },
                        writeAcceleratorEnabled = true,
                    },
                    securityProfile = new
                    {
                        encryptionAtHost = true,
                        securityType = "trustedLaunch",
                        uefiSettings = new
                        {
                            secureBootEnabled = true,
                            vTpmEnabled = true,
                        },
                    },
                    serviceArtifactReference = new
                    {
                        id = "<id>",
                    },
                },
                taskSlotsPerNode = 1234,
                taskSchedulingPolicy = new
                {
                    nodeFillType = "spread",
                },
                resizeTimeout = "PT1H23M45S",
                resourceTags = "<resourceTags>",
                targetDedicatedNodes = 1234,
                targetLowPriorityNodes = 1234,
                enableAutoScale = true,
                autoScaleFormula = "<autoScaleFormula>",
                autoScaleEvaluationInterval = "PT1H23M45S",
                enableInterNodeCommunication = true,
                networkConfiguration = new
                {
                    subnetId = "<subnetId>",
                    dynamicVNetAssignmentScope = "none",
                    endpointConfiguration = new
                    {
                        inboundNATPools = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                protocol = "tcp",
                                backendPort = 1234,
                                frontendPortRangeStart = 1234,
                                frontendPortRangeEnd = 1234,
                                networkSecurityGroupRules = new object[]
                                {
                                    new
                                    {
                                        priority = 1234,
                                        access = "allow",
                                        sourceAddressPrefix = "<sourceAddressPrefix>",
                                        sourcePortRanges = new object[]
                                        {
                                            "<sourcePortRanges>"
                                        },
                                    }
                                },
                            }
                        },
                    },
                    publicIPAddressConfiguration = new
                    {
                        provision = "batchmanaged",
                        ipAddressIds = new object[]
                        {
                            "<ipAddressIds>"
                        },
                    },
                    enableAcceleratedNetworking = true,
                },
                startTask = new
                {
                    commandLine = "<commandLine>",
                    containerSettings = new
                    {
                        containerRunOptions = "<containerRunOptions>",
                        imageName = "<imageName>",
                        workingDirectory = "taskWorkingDirectory",
                    },
                    resourceFiles = new object[]
                    {
                        new
                        {
                            autoStorageContainerName = "<autoStorageContainerName>",
                            storageContainerUrl = "<storageContainerUrl>",
                            httpUrl = "<httpUrl>",
                            blobPrefix = "<blobPrefix>",
                            filePath = "<filePath>",
                            fileMode = "<fileMode>",
                        }
                    },
                    environmentSettings = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    userIdentity = new
                    {
                        username = "<username>",
                        autoUser = new
                        {
                            scope = "task",
                            elevationLevel = "nonadmin",
                        },
                    },
                    maxTaskRetryCount = 1234,
                    waitForSuccess = true,
                },
                applicationPackageReferences = new object[]
                {
                    new
                    {
                        applicationId = "<applicationId>",
                        version = "<version>",
                    }
                },
                userAccounts = new object[]
                {
                    new
                    {
                        name = "<name>",
                        password = "<password>",
                        elevationLevel = "nonadmin",
                        linuxUserConfiguration = new
                        {
                            uid = 1234,
                            gid = 1234,
                            sshPrivateKey = "<sshPrivateKey>",
                        },
                        windowsUserConfiguration = new
                        {
                            loginMode = "batch",
                        },
                    }
                },
                metadata = new object[]
                {
                    new
                    {
                        name = "<name>",
                        value = "<value>",
                    }
                },
                mountConfiguration = new object[]
                {
                    new
                    {
                        azureBlobFileSystemConfiguration = new
                        {
                            accountName = "<accountName>",
                            containerName = "<containerName>",
                            accountKey = "<accountKey>",
                            sasKey = "<sasKey>",
                            blobfuseOptions = "<blobfuseOptions>",
                            relativeMountPath = "<relativeMountPath>",
                        },
                        nfsMountConfiguration = new
                        {
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                        cifsMountConfiguration = new
                        {
                            username = "<username>",
                            source = "<source>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                            password = "<password>",
                        },
                        azureFileShareConfiguration = new
                        {
                            accountName = "<accountName>",
                            azureFileUrl = "<azureFileUrl>",
                            accountKey = "<accountKey>",
                            relativeMountPath = "<relativeMountPath>",
                            mountOptions = "<mountOptions>",
                        },
                    }
                },
                targetNodeCommunicationMode = "default",
                upgradePolicy = new
                {
                    mode = "automatic",
                    automaticOSUpgradePolicy = new
                    {
                        disableAutomaticRollback = true,
                        enableAutomaticOSUpgrade = true,
                        useRollingUpgradePolicy = true,
                        osRollingUpgradeDeferral = true,
                    },
                    rollingUpgradePolicy = new
                    {
                        enableCrossZoneUpgrade = true,
                        maxBatchInstancePercent = 1234,
                        maxUnhealthyInstancePercent = 1234,
                        maxUnhealthyUpgradedInstancePercent = 1234,
                        pauseTimeBetweenBatches = "PT1H23M45S",
                        prioritizeUnhealthyInstances = true,
                        rollbackFailedInstancesOnPolicyBreach = true,
                    },
                },
            },
        },
    },
    onAllTasksComplete = "noaction",
    metadata = new object[]
    {
        null
    },
});
Response response = await client.UpdateJobAsync("<jobId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateJobSchedule (string jobScheduleId, Azure.Compute.Batch.BatchJobScheduleUpdateContent jobSchedule, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateJobSchedule(string jobScheduleId, class Azure.Compute.Batch.BatchJobScheduleUpdateContent jobSchedule, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdateJobSchedule(System.String,Azure.Compute.Batch.BatchJobScheduleUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateJobSchedule (jobScheduleId As String, jobSchedule As BatchJobScheduleUpdateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateJobSchedule : string * Azure.Compute.Batch.BatchJobScheduleUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.UpdateJobSchedule : string * Azure.Compute.Batch.BatchJobScheduleUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.UpdateJobSchedule (jobScheduleId, jobSchedule, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="jobSchedule" Type="Azure.Compute.Batch.BatchJobScheduleUpdateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        <param name="jobSchedule"> The options to use for updating the Job Schedule. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> or <paramref name="jobSchedule" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdateJobSchedule("<jobScheduleId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateJobSchedule with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    schedule = new
    {
        doNotRunUntil = "2022-05-10T18:57:31.2311892Z",
        doNotRunAfter = "2022-05-10T18:57:31.2311892Z",
        startWindow = "PT1H23M45S",
        recurrenceInterval = "PT1H23M45S",
    },
    jobSpecification = new
    {
        priority = 1234,
        allowTaskPreemption = true,
        maxParallelTasks = 1234,
        displayName = "<displayName>",
        usesTaskDependencies = true,
        onAllTasksComplete = "noaction",
        onTaskFailure = "noaction",
        networkConfiguration = new
        {
            subnetId = "<subnetId>",
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        jobManagerTask = new
        {
            id = "<id>",
            displayName = "<displayName>",
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            killJobOnCompletion = true,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            runExclusive = true,
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
            allowLowPriorityNode = true,
        },
        jobPreparationTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            waitForSuccess = true,
            rerunOnNodeRebootAfterSuccess = true,
        },
        jobReleaseTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
        },
        commonEnvironmentSettings = new object[]
        {
            null
        },
        poolInfo = new
        {
            poolId = "<poolId>",
            autoPoolSpecification = new
            {
                autoPoolIdPrefix = "<autoPoolIdPrefix>",
                poolLifetimeOption = "jobschedule",
                keepAlive = true,
                pool = new
                {
                    displayName = "<displayName>",
                    vmSize = "<vmSize>",
                    virtualMachineConfiguration = new
                    {
                        imageReference = new
                        {
                            publisher = "<publisher>",
                            offer = "<offer>",
                            sku = "<sku>",
                            version = "<version>",
                            virtualMachineImageId = "<virtualMachineImageId>",
                        },
                        nodeAgentSKUId = "<nodeAgentSKUId>",
                        windowsConfiguration = new
                        {
                            enableAutomaticUpdates = true,
                        },
                        dataDisks = new object[]
                        {
                            new
                            {
                                lun = 1234,
                                caching = "none",
                                diskSizeGB = 1234,
                                storageAccountType = "standard_lrs",
                            }
                        },
                        licenseType = "<licenseType>",
                        containerConfiguration = new
                        {
                            type = "dockerCompatible",
                            containerImageNames = new object[]
                            {
                                "<containerImageNames>"
                            },
                            containerRegistries = new object[]
                            {
                                null
                            },
                        },
                        diskEncryptionConfiguration = new
                        {
                            targets = new object[]
                            {
                                "osdisk"
                            },
                        },
                        nodePlacementConfiguration = new
                        {
                            policy = "regional",
                        },
                        extensions = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                publisher = "<publisher>",
                                type = "<type>",
                                typeHandlerVersion = "<typeHandlerVersion>",
                                autoUpgradeMinorVersion = true,
                                enableAutomaticUpgrade = true,
                                settings = new
                                {
                                    key = "<settings>",
                                },
                                protectedSettings = new
                                {
                                    key = "<protectedSettings>",
                                },
                                provisionAfterExtensions = new object[]
                                {
                                    "<provisionAfterExtensions>"
                                },
                            }
                        },
                        osDisk = new
                        {
                            ephemeralOSDiskSettings = new
                            {
                                placement = "cachedisk",
                            },
                            caching = "none",
                            diskSizeGB = 1234,
                            managedDisk = new
                            {
                                storageAccountType = "standard_lrs",
                            },
                            writeAcceleratorEnabled = true,
                        },
                        securityProfile = new
                        {
                            encryptionAtHost = true,
                            securityType = "trustedLaunch",
                            uefiSettings = new
                            {
                                secureBootEnabled = true,
                                vTpmEnabled = true,
                            },
                        },
                        serviceArtifactReference = new
                        {
                            id = "<id>",
                        },
                    },
                    taskSlotsPerNode = 1234,
                    taskSchedulingPolicy = new
                    {
                        nodeFillType = "spread",
                    },
                    resizeTimeout = "PT1H23M45S",
                    resourceTags = "<resourceTags>",
                    targetDedicatedNodes = 1234,
                    targetLowPriorityNodes = 1234,
                    enableAutoScale = true,
                    autoScaleFormula = "<autoScaleFormula>",
                    autoScaleEvaluationInterval = "PT1H23M45S",
                    enableInterNodeCommunication = true,
                    networkConfiguration = new
                    {
                        subnetId = "<subnetId>",
                        dynamicVNetAssignmentScope = "none",
                        endpointConfiguration = new
                        {
                            inboundNATPools = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    protocol = "tcp",
                                    backendPort = 1234,
                                    frontendPortRangeStart = 1234,
                                    frontendPortRangeEnd = 1234,
                                    networkSecurityGroupRules = new object[]
                                    {
                                        new
                                        {
                                            priority = 1234,
                                            access = "allow",
                                            sourceAddressPrefix = "<sourceAddressPrefix>",
                                            sourcePortRanges = new object[]
                                            {
                                                "<sourcePortRanges>"
                                            },
                                        }
                                    },
                                }
                            },
                        },
                        publicIPAddressConfiguration = new
                        {
                            provision = "batchmanaged",
                            ipAddressIds = new object[]
                            {
                                "<ipAddressIds>"
                            },
                        },
                        enableAcceleratedNetworking = true,
                    },
                    startTask = new
                    {
                        commandLine = "<commandLine>",
                        resourceFiles = new object[]
                        {
                            null
                        },
                        environmentSettings = new object[]
                        {
                            null
                        },
                        maxTaskRetryCount = 1234,
                        waitForSuccess = true,
                    },
                    applicationPackageReferences = new object[]
                    {
                        null
                    },
                    userAccounts = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            password = "<password>",
                            elevationLevel = "nonadmin",
                            linuxUserConfiguration = new
                            {
                                uid = 1234,
                                gid = 1234,
                                sshPrivateKey = "<sshPrivateKey>",
                            },
                            windowsUserConfiguration = new
                            {
                                loginMode = "batch",
                            },
                        }
                    },
                    metadata = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    mountConfiguration = new object[]
                    {
                        new
                        {
                            azureBlobFileSystemConfiguration = new
                            {
                                accountName = "<accountName>",
                                containerName = "<containerName>",
                                accountKey = "<accountKey>",
                                sasKey = "<sasKey>",
                                blobfuseOptions = "<blobfuseOptions>",
                                relativeMountPath = "<relativeMountPath>",
                            },
                            nfsMountConfiguration = new
                            {
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                            cifsMountConfiguration = new
                            {
                                username = "<username>",
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                                password = "<password>",
                            },
                            azureFileShareConfiguration = new
                            {
                                accountName = "<accountName>",
                                azureFileUrl = "<azureFileUrl>",
                                accountKey = "<accountKey>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                        }
                    },
                    targetNodeCommunicationMode = "default",
                    upgradePolicy = new
                    {
                        mode = "automatic",
                        automaticOSUpgradePolicy = new
                        {
                            disableAutomaticRollback = true,
                            enableAutomaticOSUpgrade = true,
                            useRollingUpgradePolicy = true,
                            osRollingUpgradeDeferral = true,
                        },
                        rollingUpgradePolicy = new
                        {
                            enableCrossZoneUpgrade = true,
                            maxBatchInstancePercent = 1234,
                            maxUnhealthyInstancePercent = 1234,
                            maxUnhealthyUpgradedInstancePercent = 1234,
                            pauseTimeBetweenBatches = "PT1H23M45S",
                            prioritizeUnhealthyInstances = true,
                            rollbackFailedInstancesOnPolicyBreach = true,
                        },
                    },
                },
            },
        },
        metadata = new object[]
        {
            null
        },
    },
    metadata = new object[]
    {
        null
    },
});
Response response = client.UpdateJobSchedule("<jobScheduleId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateJobSchedule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateJobSchedule (string jobScheduleId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateJobSchedule(string jobScheduleId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdateJobSchedule(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateJobSchedule (jobScheduleId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateJobSchedule : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdateJobSchedule : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.UpdateJobSchedule (jobScheduleId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateJobSchedule.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdateJobSchedule("<jobScheduleId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateJobSchedule with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    schedule = new
    {
        doNotRunUntil = "2022-05-10T18:57:31.2311892Z",
        doNotRunAfter = "2022-05-10T18:57:31.2311892Z",
        startWindow = "PT1H23M45S",
        recurrenceInterval = "PT1H23M45S",
    },
    jobSpecification = new
    {
        priority = 1234,
        allowTaskPreemption = true,
        maxParallelTasks = 1234,
        displayName = "<displayName>",
        usesTaskDependencies = true,
        onAllTasksComplete = "noaction",
        onTaskFailure = "noaction",
        networkConfiguration = new
        {
            subnetId = "<subnetId>",
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        jobManagerTask = new
        {
            id = "<id>",
            displayName = "<displayName>",
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            killJobOnCompletion = true,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            runExclusive = true,
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
            allowLowPriorityNode = true,
        },
        jobPreparationTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            waitForSuccess = true,
            rerunOnNodeRebootAfterSuccess = true,
        },
        jobReleaseTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
        },
        commonEnvironmentSettings = new object[]
        {
            null
        },
        poolInfo = new
        {
            poolId = "<poolId>",
            autoPoolSpecification = new
            {
                autoPoolIdPrefix = "<autoPoolIdPrefix>",
                poolLifetimeOption = "jobschedule",
                keepAlive = true,
                pool = new
                {
                    displayName = "<displayName>",
                    vmSize = "<vmSize>",
                    virtualMachineConfiguration = new
                    {
                        imageReference = new
                        {
                            publisher = "<publisher>",
                            offer = "<offer>",
                            sku = "<sku>",
                            version = "<version>",
                            virtualMachineImageId = "<virtualMachineImageId>",
                        },
                        nodeAgentSKUId = "<nodeAgentSKUId>",
                        windowsConfiguration = new
                        {
                            enableAutomaticUpdates = true,
                        },
                        dataDisks = new object[]
                        {
                            new
                            {
                                lun = 1234,
                                caching = "none",
                                diskSizeGB = 1234,
                                storageAccountType = "standard_lrs",
                            }
                        },
                        licenseType = "<licenseType>",
                        containerConfiguration = new
                        {
                            type = "dockerCompatible",
                            containerImageNames = new object[]
                            {
                                "<containerImageNames>"
                            },
                            containerRegistries = new object[]
                            {
                                null
                            },
                        },
                        diskEncryptionConfiguration = new
                        {
                            targets = new object[]
                            {
                                "osdisk"
                            },
                        },
                        nodePlacementConfiguration = new
                        {
                            policy = "regional",
                        },
                        extensions = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                publisher = "<publisher>",
                                type = "<type>",
                                typeHandlerVersion = "<typeHandlerVersion>",
                                autoUpgradeMinorVersion = true,
                                enableAutomaticUpgrade = true,
                                settings = new
                                {
                                    key = "<settings>",
                                },
                                protectedSettings = new
                                {
                                    key = "<protectedSettings>",
                                },
                                provisionAfterExtensions = new object[]
                                {
                                    "<provisionAfterExtensions>"
                                },
                            }
                        },
                        osDisk = new
                        {
                            ephemeralOSDiskSettings = new
                            {
                                placement = "cachedisk",
                            },
                            caching = "none",
                            diskSizeGB = 1234,
                            managedDisk = new
                            {
                                storageAccountType = "standard_lrs",
                            },
                            writeAcceleratorEnabled = true,
                        },
                        securityProfile = new
                        {
                            encryptionAtHost = true,
                            securityType = "trustedLaunch",
                            uefiSettings = new
                            {
                                secureBootEnabled = true,
                                vTpmEnabled = true,
                            },
                        },
                        serviceArtifactReference = new
                        {
                            id = "<id>",
                        },
                    },
                    taskSlotsPerNode = 1234,
                    taskSchedulingPolicy = new
                    {
                        nodeFillType = "spread",
                    },
                    resizeTimeout = "PT1H23M45S",
                    resourceTags = "<resourceTags>",
                    targetDedicatedNodes = 1234,
                    targetLowPriorityNodes = 1234,
                    enableAutoScale = true,
                    autoScaleFormula = "<autoScaleFormula>",
                    autoScaleEvaluationInterval = "PT1H23M45S",
                    enableInterNodeCommunication = true,
                    networkConfiguration = new
                    {
                        subnetId = "<subnetId>",
                        dynamicVNetAssignmentScope = "none",
                        endpointConfiguration = new
                        {
                            inboundNATPools = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    protocol = "tcp",
                                    backendPort = 1234,
                                    frontendPortRangeStart = 1234,
                                    frontendPortRangeEnd = 1234,
                                    networkSecurityGroupRules = new object[]
                                    {
                                        new
                                        {
                                            priority = 1234,
                                            access = "allow",
                                            sourceAddressPrefix = "<sourceAddressPrefix>",
                                            sourcePortRanges = new object[]
                                            {
                                                "<sourcePortRanges>"
                                            },
                                        }
                                    },
                                }
                            },
                        },
                        publicIPAddressConfiguration = new
                        {
                            provision = "batchmanaged",
                            ipAddressIds = new object[]
                            {
                                "<ipAddressIds>"
                            },
                        },
                        enableAcceleratedNetworking = true,
                    },
                    startTask = new
                    {
                        commandLine = "<commandLine>",
                        resourceFiles = new object[]
                        {
                            null
                        },
                        environmentSettings = new object[]
                        {
                            null
                        },
                        maxTaskRetryCount = 1234,
                        waitForSuccess = true,
                    },
                    applicationPackageReferences = new object[]
                    {
                        null
                    },
                    userAccounts = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            password = "<password>",
                            elevationLevel = "nonadmin",
                            linuxUserConfiguration = new
                            {
                                uid = 1234,
                                gid = 1234,
                                sshPrivateKey = "<sshPrivateKey>",
                            },
                            windowsUserConfiguration = new
                            {
                                loginMode = "batch",
                            },
                        }
                    },
                    metadata = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    mountConfiguration = new object[]
                    {
                        new
                        {
                            azureBlobFileSystemConfiguration = new
                            {
                                accountName = "<accountName>",
                                containerName = "<containerName>",
                                accountKey = "<accountKey>",
                                sasKey = "<sasKey>",
                                blobfuseOptions = "<blobfuseOptions>",
                                relativeMountPath = "<relativeMountPath>",
                            },
                            nfsMountConfiguration = new
                            {
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                            cifsMountConfiguration = new
                            {
                                username = "<username>",
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                                password = "<password>",
                            },
                            azureFileShareConfiguration = new
                            {
                                accountName = "<accountName>",
                                azureFileUrl = "<azureFileUrl>",
                                accountKey = "<accountKey>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                        }
                    },
                    targetNodeCommunicationMode = "default",
                    upgradePolicy = new
                    {
                        mode = "automatic",
                        automaticOSUpgradePolicy = new
                        {
                            disableAutomaticRollback = true,
                            enableAutomaticOSUpgrade = true,
                            useRollingUpgradePolicy = true,
                            osRollingUpgradeDeferral = true,
                        },
                        rollingUpgradePolicy = new
                        {
                            enableCrossZoneUpgrade = true,
                            maxBatchInstancePercent = 1234,
                            maxUnhealthyInstancePercent = 1234,
                            maxUnhealthyUpgradedInstancePercent = 1234,
                            pauseTimeBetweenBatches = "PT1H23M45S",
                            prioritizeUnhealthyInstances = true,
                            rollbackFailedInstancesOnPolicyBreach = true,
                        },
                    },
                },
            },
        },
        metadata = new object[]
        {
            null
        },
    },
    metadata = new object[]
    {
        null
    },
});
Response response = client.UpdateJobSchedule("<jobScheduleId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateJobScheduleAsync (string jobScheduleId, Azure.Compute.Batch.BatchJobScheduleUpdateContent jobSchedule, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateJobScheduleAsync(string jobScheduleId, class Azure.Compute.Batch.BatchJobScheduleUpdateContent jobSchedule, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdateJobScheduleAsync(System.String,Azure.Compute.Batch.BatchJobScheduleUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateJobScheduleAsync (jobScheduleId As String, jobSchedule As BatchJobScheduleUpdateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateJobScheduleAsync : string * Azure.Compute.Batch.BatchJobScheduleUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateJobScheduleAsync : string * Azure.Compute.Batch.BatchJobScheduleUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.UpdateJobScheduleAsync (jobScheduleId, jobSchedule, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="jobSchedule" Type="Azure.Compute.Batch.BatchJobScheduleUpdateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        <param name="jobSchedule"> The options to use for updating the Job Schedule. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> or <paramref name="jobSchedule" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdateJobScheduleAsync("<jobScheduleId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateJobScheduleAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    schedule = new
    {
        doNotRunUntil = "2022-05-10T18:57:31.2311892Z",
        doNotRunAfter = "2022-05-10T18:57:31.2311892Z",
        startWindow = "PT1H23M45S",
        recurrenceInterval = "PT1H23M45S",
    },
    jobSpecification = new
    {
        priority = 1234,
        allowTaskPreemption = true,
        maxParallelTasks = 1234,
        displayName = "<displayName>",
        usesTaskDependencies = true,
        onAllTasksComplete = "noaction",
        onTaskFailure = "noaction",
        networkConfiguration = new
        {
            subnetId = "<subnetId>",
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        jobManagerTask = new
        {
            id = "<id>",
            displayName = "<displayName>",
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            killJobOnCompletion = true,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            runExclusive = true,
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
            allowLowPriorityNode = true,
        },
        jobPreparationTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            waitForSuccess = true,
            rerunOnNodeRebootAfterSuccess = true,
        },
        jobReleaseTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
        },
        commonEnvironmentSettings = new object[]
        {
            null
        },
        poolInfo = new
        {
            poolId = "<poolId>",
            autoPoolSpecification = new
            {
                autoPoolIdPrefix = "<autoPoolIdPrefix>",
                poolLifetimeOption = "jobschedule",
                keepAlive = true,
                pool = new
                {
                    displayName = "<displayName>",
                    vmSize = "<vmSize>",
                    virtualMachineConfiguration = new
                    {
                        imageReference = new
                        {
                            publisher = "<publisher>",
                            offer = "<offer>",
                            sku = "<sku>",
                            version = "<version>",
                            virtualMachineImageId = "<virtualMachineImageId>",
                        },
                        nodeAgentSKUId = "<nodeAgentSKUId>",
                        windowsConfiguration = new
                        {
                            enableAutomaticUpdates = true,
                        },
                        dataDisks = new object[]
                        {
                            new
                            {
                                lun = 1234,
                                caching = "none",
                                diskSizeGB = 1234,
                                storageAccountType = "standard_lrs",
                            }
                        },
                        licenseType = "<licenseType>",
                        containerConfiguration = new
                        {
                            type = "dockerCompatible",
                            containerImageNames = new object[]
                            {
                                "<containerImageNames>"
                            },
                            containerRegistries = new object[]
                            {
                                null
                            },
                        },
                        diskEncryptionConfiguration = new
                        {
                            targets = new object[]
                            {
                                "osdisk"
                            },
                        },
                        nodePlacementConfiguration = new
                        {
                            policy = "regional",
                        },
                        extensions = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                publisher = "<publisher>",
                                type = "<type>",
                                typeHandlerVersion = "<typeHandlerVersion>",
                                autoUpgradeMinorVersion = true,
                                enableAutomaticUpgrade = true,
                                settings = new
                                {
                                    key = "<settings>",
                                },
                                protectedSettings = new
                                {
                                    key = "<protectedSettings>",
                                },
                                provisionAfterExtensions = new object[]
                                {
                                    "<provisionAfterExtensions>"
                                },
                            }
                        },
                        osDisk = new
                        {
                            ephemeralOSDiskSettings = new
                            {
                                placement = "cachedisk",
                            },
                            caching = "none",
                            diskSizeGB = 1234,
                            managedDisk = new
                            {
                                storageAccountType = "standard_lrs",
                            },
                            writeAcceleratorEnabled = true,
                        },
                        securityProfile = new
                        {
                            encryptionAtHost = true,
                            securityType = "trustedLaunch",
                            uefiSettings = new
                            {
                                secureBootEnabled = true,
                                vTpmEnabled = true,
                            },
                        },
                        serviceArtifactReference = new
                        {
                            id = "<id>",
                        },
                    },
                    taskSlotsPerNode = 1234,
                    taskSchedulingPolicy = new
                    {
                        nodeFillType = "spread",
                    },
                    resizeTimeout = "PT1H23M45S",
                    resourceTags = "<resourceTags>",
                    targetDedicatedNodes = 1234,
                    targetLowPriorityNodes = 1234,
                    enableAutoScale = true,
                    autoScaleFormula = "<autoScaleFormula>",
                    autoScaleEvaluationInterval = "PT1H23M45S",
                    enableInterNodeCommunication = true,
                    networkConfiguration = new
                    {
                        subnetId = "<subnetId>",
                        dynamicVNetAssignmentScope = "none",
                        endpointConfiguration = new
                        {
                            inboundNATPools = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    protocol = "tcp",
                                    backendPort = 1234,
                                    frontendPortRangeStart = 1234,
                                    frontendPortRangeEnd = 1234,
                                    networkSecurityGroupRules = new object[]
                                    {
                                        new
                                        {
                                            priority = 1234,
                                            access = "allow",
                                            sourceAddressPrefix = "<sourceAddressPrefix>",
                                            sourcePortRanges = new object[]
                                            {
                                                "<sourcePortRanges>"
                                            },
                                        }
                                    },
                                }
                            },
                        },
                        publicIPAddressConfiguration = new
                        {
                            provision = "batchmanaged",
                            ipAddressIds = new object[]
                            {
                                "<ipAddressIds>"
                            },
                        },
                        enableAcceleratedNetworking = true,
                    },
                    startTask = new
                    {
                        commandLine = "<commandLine>",
                        resourceFiles = new object[]
                        {
                            null
                        },
                        environmentSettings = new object[]
                        {
                            null
                        },
                        maxTaskRetryCount = 1234,
                        waitForSuccess = true,
                    },
                    applicationPackageReferences = new object[]
                    {
                        null
                    },
                    userAccounts = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            password = "<password>",
                            elevationLevel = "nonadmin",
                            linuxUserConfiguration = new
                            {
                                uid = 1234,
                                gid = 1234,
                                sshPrivateKey = "<sshPrivateKey>",
                            },
                            windowsUserConfiguration = new
                            {
                                loginMode = "batch",
                            },
                        }
                    },
                    metadata = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    mountConfiguration = new object[]
                    {
                        new
                        {
                            azureBlobFileSystemConfiguration = new
                            {
                                accountName = "<accountName>",
                                containerName = "<containerName>",
                                accountKey = "<accountKey>",
                                sasKey = "<sasKey>",
                                blobfuseOptions = "<blobfuseOptions>",
                                relativeMountPath = "<relativeMountPath>",
                            },
                            nfsMountConfiguration = new
                            {
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                            cifsMountConfiguration = new
                            {
                                username = "<username>",
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                                password = "<password>",
                            },
                            azureFileShareConfiguration = new
                            {
                                accountName = "<accountName>",
                                azureFileUrl = "<azureFileUrl>",
                                accountKey = "<accountKey>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                        }
                    },
                    targetNodeCommunicationMode = "default",
                    upgradePolicy = new
                    {
                        mode = "automatic",
                        automaticOSUpgradePolicy = new
                        {
                            disableAutomaticRollback = true,
                            enableAutomaticOSUpgrade = true,
                            useRollingUpgradePolicy = true,
                            osRollingUpgradeDeferral = true,
                        },
                        rollingUpgradePolicy = new
                        {
                            enableCrossZoneUpgrade = true,
                            maxBatchInstancePercent = 1234,
                            maxUnhealthyInstancePercent = 1234,
                            maxUnhealthyUpgradedInstancePercent = 1234,
                            pauseTimeBetweenBatches = "PT1H23M45S",
                            prioritizeUnhealthyInstances = true,
                            rollbackFailedInstancesOnPolicyBreach = true,
                        },
                    },
                },
            },
        },
        metadata = new object[]
        {
            null
        },
    },
    metadata = new object[]
    {
        null
    },
});
Response response = await client.UpdateJobScheduleAsync("<jobScheduleId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateJobScheduleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateJobScheduleAsync (string jobScheduleId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateJobScheduleAsync(string jobScheduleId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdateJobScheduleAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateJobScheduleAsync (jobScheduleId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateJobScheduleAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateJobScheduleAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.UpdateJobScheduleAsync (jobScheduleId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="jobScheduleId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Job Schedule.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jobScheduleId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="jobScheduleId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateJobScheduleAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdateJobScheduleAsync("<jobScheduleId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateJobScheduleAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    schedule = new
    {
        doNotRunUntil = "2022-05-10T18:57:31.2311892Z",
        doNotRunAfter = "2022-05-10T18:57:31.2311892Z",
        startWindow = "PT1H23M45S",
        recurrenceInterval = "PT1H23M45S",
    },
    jobSpecification = new
    {
        priority = 1234,
        allowTaskPreemption = true,
        maxParallelTasks = 1234,
        displayName = "<displayName>",
        usesTaskDependencies = true,
        onAllTasksComplete = "noaction",
        onTaskFailure = "noaction",
        networkConfiguration = new
        {
            subnetId = "<subnetId>",
        },
        constraints = new
        {
            maxWallClockTime = "PT1H23M45S",
            maxTaskRetryCount = 1234,
        },
        jobManagerTask = new
        {
            id = "<id>",
            displayName = "<displayName>",
            commandLine = "<commandLine>",
            containerSettings = new
            {
                containerRunOptions = "<containerRunOptions>",
                imageName = "<imageName>",
                registry = new
                {
                    username = "<username>",
                    password = "<password>",
                    registryServer = "<registryServer>",
                    identityReference = new
                    {
                        resourceId = "<resourceId>",
                    },
                },
                workingDirectory = "taskWorkingDirectory",
            },
            resourceFiles = new object[]
            {
                new
                {
                    autoStorageContainerName = "<autoStorageContainerName>",
                    storageContainerUrl = "<storageContainerUrl>",
                    httpUrl = "<httpUrl>",
                    blobPrefix = "<blobPrefix>",
                    filePath = "<filePath>",
                    fileMode = "<fileMode>",
                }
            },
            outputFiles = new object[]
            {
                new
                {
                    filePattern = "<filePattern>",
                    destination = new
                    {
                        container = new
                        {
                            path = "<path>",
                            containerUrl = "<containerUrl>",
                            uploadHeaders = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    value = "<value>",
                                }
                            },
                        },
                    },
                    uploadOptions = new
                    {
                        uploadCondition = "tasksuccess",
                    },
                }
            },
            environmentSettings = new object[]
            {
                new
                {
                    name = "<name>",
                    value = "<value>",
                }
            },
            constraints = new
            {
                maxWallClockTime = "PT1H23M45S",
                retentionTime = "PT1H23M45S",
                maxTaskRetryCount = 1234,
            },
            requiredSlots = 1234,
            killJobOnCompletion = true,
            userIdentity = new
            {
                username = "<username>",
                autoUser = new
                {
                    scope = "task",
                    elevationLevel = "nonadmin",
                },
            },
            runExclusive = true,
            applicationPackageReferences = new object[]
            {
                new
                {
                    applicationId = "<applicationId>",
                    version = "<version>",
                }
            },
            authenticationTokenSettings = new
            {
                access = new object[]
                {
                    "job"
                },
            },
            allowLowPriorityNode = true,
        },
        jobPreparationTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            waitForSuccess = true,
            rerunOnNodeRebootAfterSuccess = true,
        },
        jobReleaseTask = new
        {
            id = "<id>",
            commandLine = "<commandLine>",
            resourceFiles = new object[]
            {
                null
            },
            environmentSettings = new object[]
            {
                null
            },
            maxWallClockTime = "PT1H23M45S",
            retentionTime = "PT1H23M45S",
        },
        commonEnvironmentSettings = new object[]
        {
            null
        },
        poolInfo = new
        {
            poolId = "<poolId>",
            autoPoolSpecification = new
            {
                autoPoolIdPrefix = "<autoPoolIdPrefix>",
                poolLifetimeOption = "jobschedule",
                keepAlive = true,
                pool = new
                {
                    displayName = "<displayName>",
                    vmSize = "<vmSize>",
                    virtualMachineConfiguration = new
                    {
                        imageReference = new
                        {
                            publisher = "<publisher>",
                            offer = "<offer>",
                            sku = "<sku>",
                            version = "<version>",
                            virtualMachineImageId = "<virtualMachineImageId>",
                        },
                        nodeAgentSKUId = "<nodeAgentSKUId>",
                        windowsConfiguration = new
                        {
                            enableAutomaticUpdates = true,
                        },
                        dataDisks = new object[]
                        {
                            new
                            {
                                lun = 1234,
                                caching = "none",
                                diskSizeGB = 1234,
                                storageAccountType = "standard_lrs",
                            }
                        },
                        licenseType = "<licenseType>",
                        containerConfiguration = new
                        {
                            type = "dockerCompatible",
                            containerImageNames = new object[]
                            {
                                "<containerImageNames>"
                            },
                            containerRegistries = new object[]
                            {
                                null
                            },
                        },
                        diskEncryptionConfiguration = new
                        {
                            targets = new object[]
                            {
                                "osdisk"
                            },
                        },
                        nodePlacementConfiguration = new
                        {
                            policy = "regional",
                        },
                        extensions = new object[]
                        {
                            new
                            {
                                name = "<name>",
                                publisher = "<publisher>",
                                type = "<type>",
                                typeHandlerVersion = "<typeHandlerVersion>",
                                autoUpgradeMinorVersion = true,
                                enableAutomaticUpgrade = true,
                                settings = new
                                {
                                    key = "<settings>",
                                },
                                protectedSettings = new
                                {
                                    key = "<protectedSettings>",
                                },
                                provisionAfterExtensions = new object[]
                                {
                                    "<provisionAfterExtensions>"
                                },
                            }
                        },
                        osDisk = new
                        {
                            ephemeralOSDiskSettings = new
                            {
                                placement = "cachedisk",
                            },
                            caching = "none",
                            diskSizeGB = 1234,
                            managedDisk = new
                            {
                                storageAccountType = "standard_lrs",
                            },
                            writeAcceleratorEnabled = true,
                        },
                        securityProfile = new
                        {
                            encryptionAtHost = true,
                            securityType = "trustedLaunch",
                            uefiSettings = new
                            {
                                secureBootEnabled = true,
                                vTpmEnabled = true,
                            },
                        },
                        serviceArtifactReference = new
                        {
                            id = "<id>",
                        },
                    },
                    taskSlotsPerNode = 1234,
                    taskSchedulingPolicy = new
                    {
                        nodeFillType = "spread",
                    },
                    resizeTimeout = "PT1H23M45S",
                    resourceTags = "<resourceTags>",
                    targetDedicatedNodes = 1234,
                    targetLowPriorityNodes = 1234,
                    enableAutoScale = true,
                    autoScaleFormula = "<autoScaleFormula>",
                    autoScaleEvaluationInterval = "PT1H23M45S",
                    enableInterNodeCommunication = true,
                    networkConfiguration = new
                    {
                        subnetId = "<subnetId>",
                        dynamicVNetAssignmentScope = "none",
                        endpointConfiguration = new
                        {
                            inboundNATPools = new object[]
                            {
                                new
                                {
                                    name = "<name>",
                                    protocol = "tcp",
                                    backendPort = 1234,
                                    frontendPortRangeStart = 1234,
                                    frontendPortRangeEnd = 1234,
                                    networkSecurityGroupRules = new object[]
                                    {
                                        new
                                        {
                                            priority = 1234,
                                            access = "allow",
                                            sourceAddressPrefix = "<sourceAddressPrefix>",
                                            sourcePortRanges = new object[]
                                            {
                                                "<sourcePortRanges>"
                                            },
                                        }
                                    },
                                }
                            },
                        },
                        publicIPAddressConfiguration = new
                        {
                            provision = "batchmanaged",
                            ipAddressIds = new object[]
                            {
                                "<ipAddressIds>"
                            },
                        },
                        enableAcceleratedNetworking = true,
                    },
                    startTask = new
                    {
                        commandLine = "<commandLine>",
                        resourceFiles = new object[]
                        {
                            null
                        },
                        environmentSettings = new object[]
                        {
                            null
                        },
                        maxTaskRetryCount = 1234,
                        waitForSuccess = true,
                    },
                    applicationPackageReferences = new object[]
                    {
                        null
                    },
                    userAccounts = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            password = "<password>",
                            elevationLevel = "nonadmin",
                            linuxUserConfiguration = new
                            {
                                uid = 1234,
                                gid = 1234,
                                sshPrivateKey = "<sshPrivateKey>",
                            },
                            windowsUserConfiguration = new
                            {
                                loginMode = "batch",
                            },
                        }
                    },
                    metadata = new object[]
                    {
                        new
                        {
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                    mountConfiguration = new object[]
                    {
                        new
                        {
                            azureBlobFileSystemConfiguration = new
                            {
                                accountName = "<accountName>",
                                containerName = "<containerName>",
                                accountKey = "<accountKey>",
                                sasKey = "<sasKey>",
                                blobfuseOptions = "<blobfuseOptions>",
                                relativeMountPath = "<relativeMountPath>",
                            },
                            nfsMountConfiguration = new
                            {
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                            cifsMountConfiguration = new
                            {
                                username = "<username>",
                                source = "<source>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                                password = "<password>",
                            },
                            azureFileShareConfiguration = new
                            {
                                accountName = "<accountName>",
                                azureFileUrl = "<azureFileUrl>",
                                accountKey = "<accountKey>",
                                relativeMountPath = "<relativeMountPath>",
                                mountOptions = "<mountOptions>",
                            },
                        }
                    },
                    targetNodeCommunicationMode = "default",
                    upgradePolicy = new
                    {
                        mode = "automatic",
                        automaticOSUpgradePolicy = new
                        {
                            disableAutomaticRollback = true,
                            enableAutomaticOSUpgrade = true,
                            useRollingUpgradePolicy = true,
                            osRollingUpgradeDeferral = true,
                        },
                        rollingUpgradePolicy = new
                        {
                            enableCrossZoneUpgrade = true,
                            maxBatchInstancePercent = 1234,
                            maxUnhealthyInstancePercent = 1234,
                            maxUnhealthyUpgradedInstancePercent = 1234,
                            pauseTimeBetweenBatches = "PT1H23M45S",
                            prioritizeUnhealthyInstances = true,
                            rollbackFailedInstancesOnPolicyBreach = true,
                        },
                    },
                },
            },
        },
        metadata = new object[]
        {
            null
        },
    },
    metadata = new object[]
    {
        null
    },
});
Response response = await client.UpdateJobScheduleAsync("<jobScheduleId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdatePool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdatePool (string poolId, Azure.Compute.Batch.BatchPoolUpdateContent pool, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdatePool(string poolId, class Azure.Compute.Batch.BatchPoolUpdateContent pool, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdatePool(System.String,Azure.Compute.Batch.BatchPoolUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdatePool (poolId As String, pool As BatchPoolUpdateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdatePool : string * Azure.Compute.Batch.BatchPoolUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response&#xA;override this.UpdatePool : string * Azure.Compute.Batch.BatchPoolUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; Azure.Response" Usage="batchClient.UpdatePool (poolId, pool, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="pool" Type="Azure.Compute.Batch.BatchPoolUpdateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="pool"> The pool properties to update. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="pool" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdatePool.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdatePool("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdatePool with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    startTask = new
    {
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            registry = new
            {
                username = "<username>",
                password = "<password>",
                registryServer = "<registryServer>",
                identityReference = new
                {
                    resourceId = "<resourceId>",
                },
            },
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        maxTaskRetryCount = 1234,
        waitForSuccess = true,
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    targetNodeCommunicationMode = "default",
});
Response response = client.UpdatePool("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdatePool">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdatePool (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdatePool(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdatePool(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdatePool (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdatePool : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdatePool : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.UpdatePool (poolId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdatePool.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdatePool("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdatePool with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    startTask = new
    {
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            registry = new
            {
                username = "<username>",
                password = "<password>",
                registryServer = "<registryServer>",
                identityReference = new
                {
                    resourceId = "<resourceId>",
                },
            },
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        maxTaskRetryCount = 1234,
        waitForSuccess = true,
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    targetNodeCommunicationMode = "default",
});
Response response = client.UpdatePool("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdatePoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdatePoolAsync (string poolId, Azure.Compute.Batch.BatchPoolUpdateContent pool, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdatePoolAsync(string poolId, class Azure.Compute.Batch.BatchPoolUpdateContent pool, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdatePoolAsync(System.String,Azure.Compute.Batch.BatchPoolUpdateContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdatePoolAsync (poolId As String, pool As BatchPoolUpdateContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdatePoolAsync : string * Azure.Compute.Batch.BatchPoolUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdatePoolAsync : string * Azure.Compute.Batch.BatchPoolUpdateContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.UpdatePoolAsync (poolId, pool, timeOutInSeconds, ocpdate, requestConditions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="pool" Type="Azure.Compute.Batch.BatchPoolUpdateContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="pool"> The pool properties to update. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="pool" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdatePoolAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdatePoolAsync("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdatePoolAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    startTask = new
    {
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            registry = new
            {
                username = "<username>",
                password = "<password>",
                registryServer = "<registryServer>",
                identityReference = new
                {
                    resourceId = "<resourceId>",
                },
            },
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        maxTaskRetryCount = 1234,
        waitForSuccess = true,
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    targetNodeCommunicationMode = "default",
});
Response response = await client.UpdatePoolAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdatePoolAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdatePoolAsync (string poolId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestConditions requestConditions = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdatePoolAsync(string poolId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestConditions requestConditions, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UpdatePoolAsync(System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestConditions,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdatePoolAsync (poolId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional requestConditions As RequestConditions = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdatePoolAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdatePoolAsync : string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestConditions * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.UpdatePoolAsync (poolId, content, timeOutInSeconds, ocpdate, requestConditions, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="requestConditions" Type="Azure.RequestConditions" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool to get. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Updates the properties of the specified Pool.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdatePoolAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdatePoolAsync("<poolId>", content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdatePoolAsync with all parameters and request content.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    startTask = new
    {
        commandLine = "<commandLine>",
        containerSettings = new
        {
            containerRunOptions = "<containerRunOptions>",
            imageName = "<imageName>",
            registry = new
            {
                username = "<username>",
                password = "<password>",
                registryServer = "<registryServer>",
                identityReference = new
                {
                    resourceId = "<resourceId>",
                },
            },
            workingDirectory = "taskWorkingDirectory",
        },
        resourceFiles = new object[]
        {
            new
            {
                autoStorageContainerName = "<autoStorageContainerName>",
                storageContainerUrl = "<storageContainerUrl>",
                httpUrl = "<httpUrl>",
                blobPrefix = "<blobPrefix>",
                filePath = "<filePath>",
                fileMode = "<fileMode>",
            }
        },
        environmentSettings = new object[]
        {
            new
            {
                name = "<name>",
                value = "<value>",
            }
        },
        userIdentity = new
        {
            username = "<username>",
            autoUser = new
            {
                scope = "task",
                elevationLevel = "nonadmin",
            },
        },
        maxTaskRetryCount = 1234,
        waitForSuccess = true,
    },
    applicationPackageReferences = new object[]
    {
        new
        {
            applicationId = "<applicationId>",
            version = "<version>",
        }
    },
    metadata = new object[]
    {
        new
        {
            name = "<name>",
            value = "<value>",
        }
    },
    targetNodeCommunicationMode = "default",
});
Response response = await client.UpdatePoolAsync("<poolId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"), requestConditions: null);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UploadNodeLogs">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Compute.Batch.UploadBatchServiceLogsResult&gt; UploadNodeLogs (string poolId, string nodeId, Azure.Compute.Batch.UploadBatchServiceLogsContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Compute.Batch.UploadBatchServiceLogsResult&gt; UploadNodeLogs(string poolId, string nodeId, class Azure.Compute.Batch.UploadBatchServiceLogsContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UploadNodeLogs(System.String,System.String,Azure.Compute.Batch.UploadBatchServiceLogsContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UploadNodeLogs (poolId As String, nodeId As String, content As UploadBatchServiceLogsContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of UploadBatchServiceLogsResult)" />
      <MemberSignature Language="F#" Value="abstract member UploadNodeLogs : string * string * Azure.Compute.Batch.UploadBatchServiceLogsContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.UploadBatchServiceLogsResult&gt;&#xA;override this.UploadNodeLogs : string * string * Azure.Compute.Batch.UploadBatchServiceLogsContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Compute.Batch.UploadBatchServiceLogsResult&gt;" Usage="batchClient.UploadNodeLogs (poolId, nodeId, content, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Compute.Batch.UploadBatchServiceLogsResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.UploadBatchServiceLogsContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId">
            The ID of the Compute Node for which you want to get the Remote Desktop
            Protocol file.
            </param>
        <param name="content"> The Azure Batch service log files upload options. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Upload Azure Batch service log files from the specified Compute Node to Azure
            Blob Storage.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            This is for gathering Azure Batch service log files in an automated fashion
            from Compute Nodes if you are experiencing an error and wish to escalate to
            Azure support. The Azure Batch service log files should be shared with Azure
            support to aid in debugging issues with the Batch service.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UploadNodeLogs.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

UploadBatchServiceLogsContent content = new UploadBatchServiceLogsContent("<containerUrl>", DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"));
Response<UploadBatchServiceLogsResult> response = client.UploadNodeLogs("<poolId>", "<nodeId>", content);
]]></code>
This sample shows how to call UploadNodeLogs with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

UploadBatchServiceLogsContent content = new UploadBatchServiceLogsContent("<containerUrl>", DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"))
{
    EndTime = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    IdentityReference = new BatchNodeIdentityReference
    {
        ResourceId = "<resourceId>",
    },
};
Response<UploadBatchServiceLogsResult> response = client.UploadNodeLogs("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UploadNodeLogs">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UploadNodeLogs (string poolId, string nodeId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UploadNodeLogs(string poolId, string nodeId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UploadNodeLogs(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UploadNodeLogs (poolId As String, nodeId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UploadNodeLogs : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UploadNodeLogs : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; Azure.Response" Usage="batchClient.UploadNodeLogs (poolId, nodeId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId">
            The ID of the Compute Node for which you want to get the Remote Desktop
            Protocol file.
            </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Upload Azure Batch service log files from the specified Compute Node to Azure
            Blob Storage.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.UploadNodeLogs(System.String,System.String,Azure.Compute.Batch.UploadBatchServiceLogsContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UploadNodeLogs and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    containerUrl = "<containerUrl>",
    startTime = "2022-05-10T18:57:31.2311892Z",
});
Response response = client.UploadNodeLogs("<poolId>", "<nodeId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("virtualDirectoryName").ToString());
Console.WriteLine(result.GetProperty("numberOfFilesUploaded").ToString());
]]></code>
This sample shows how to call UploadNodeLogs with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    containerUrl = "<containerUrl>",
    startTime = "2022-05-10T18:57:31.2311892Z",
    endTime = "2022-05-10T18:57:31.2311892Z",
    identityReference = new
    {
        resourceId = "<resourceId>",
    },
});
Response response = client.UploadNodeLogs("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("virtualDirectoryName").ToString());
Console.WriteLine(result.GetProperty("numberOfFilesUploaded").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UploadNodeLogsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.UploadBatchServiceLogsResult&gt;&gt; UploadNodeLogsAsync (string poolId, string nodeId, Azure.Compute.Batch.UploadBatchServiceLogsContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Compute.Batch.UploadBatchServiceLogsResult&gt;&gt; UploadNodeLogsAsync(string poolId, string nodeId, class Azure.Compute.Batch.UploadBatchServiceLogsContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UploadNodeLogsAsync(System.String,System.String,Azure.Compute.Batch.UploadBatchServiceLogsContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UploadNodeLogsAsync (poolId As String, nodeId As String, content As UploadBatchServiceLogsContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of UploadBatchServiceLogsResult))" />
      <MemberSignature Language="F#" Value="abstract member UploadNodeLogsAsync : string * string * Azure.Compute.Batch.UploadBatchServiceLogsContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.UploadBatchServiceLogsResult&gt;&gt;&#xA;override this.UploadNodeLogsAsync : string * string * Azure.Compute.Batch.UploadBatchServiceLogsContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.UploadBatchServiceLogsResult&gt;&gt;" Usage="batchClient.UploadNodeLogsAsync (poolId, nodeId, content, timeOutInSeconds, ocpdate, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Compute.Batch.UploadBatchServiceLogsResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Compute.Batch.UploadBatchServiceLogsContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId">
            The ID of the Compute Node for which you want to get the Remote Desktop
            Protocol file.
            </param>
        <param name="content"> The Azure Batch service log files upload options. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Upload Azure Batch service log files from the specified Compute Node to Azure
            Blob Storage.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            This is for gathering Azure Batch service log files in an automated fashion
            from Compute Nodes if you are experiencing an error and wish to escalate to
            Azure support. The Azure Batch service log files should be shared with Azure
            support to aid in debugging issues with the Batch service.
            </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <example>
This sample shows how to call UploadNodeLogsAsync.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

UploadBatchServiceLogsContent content = new UploadBatchServiceLogsContent("<containerUrl>", DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"));
Response<UploadBatchServiceLogsResult> response = await client.UploadNodeLogsAsync("<poolId>", "<nodeId>", content);
]]></code>
This sample shows how to call UploadNodeLogsAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

UploadBatchServiceLogsContent content = new UploadBatchServiceLogsContent("<containerUrl>", DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"))
{
    EndTime = DateTimeOffset.Parse("2022-05-10T18:57:31.2311892Z"),
    IdentityReference = new BatchNodeIdentityReference
    {
        ResourceId = "<resourceId>",
    },
};
Response<UploadBatchServiceLogsResult> response = await client.UploadNodeLogsAsync("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UploadNodeLogsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UploadNodeLogsAsync (string poolId, string nodeId, Azure.Core.RequestContent content, int? timeOutInSeconds = default, DateTimeOffset? ocpdate = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UploadNodeLogsAsync(string poolId, string nodeId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;int32&gt; timeOutInSeconds, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; ocpdate, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Compute.Batch.BatchClient.UploadNodeLogsAsync(System.String,System.String,Azure.Core.RequestContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UploadNodeLogsAsync (poolId As String, nodeId As String, content As RequestContent, Optional timeOutInSeconds As Nullable(Of Integer) = Nothing, Optional ocpdate As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UploadNodeLogsAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UploadNodeLogsAsync : string * string * Azure.Core.RequestContent * Nullable&lt;int&gt; * Nullable&lt;DateTimeOffset&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="batchClient.UploadNodeLogsAsync (poolId, nodeId, content, timeOutInSeconds, ocpdate, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Compute.Batch</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="poolId" Type="System.String" />
        <Parameter Name="nodeId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeOutInSeconds" Type="System.Nullable&lt;System.Int32&gt;" />
        <Parameter Name="ocpdate" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        <param name="nodeId">
            The ID of the Compute Node for which you want to get the Remote Desktop
            Protocol file.
            </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        <param name="ocpdate">
            The time the request was issued. Client libraries typically set this to the
            current system clock time; set it explicitly if you are calling the REST API
            directly.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Upload Azure Batch service log files from the specified Compute Node to Azure
            Blob Storage.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Compute.Batch.BatchClient.UploadNodeLogsAsync(System.String,System.String,Azure.Compute.Batch.UploadBatchServiceLogsContent,System.Nullable{System.Int32},System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="poolId" />, <paramref name="nodeId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="poolId" /> or <paramref name="nodeId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UploadNodeLogsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    containerUrl = "<containerUrl>",
    startTime = "2022-05-10T18:57:31.2311892Z",
});
Response response = await client.UploadNodeLogsAsync("<poolId>", "<nodeId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("virtualDirectoryName").ToString());
Console.WriteLine(result.GetProperty("numberOfFilesUploaded").ToString());
]]></code>
This sample shows how to call UploadNodeLogsAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<https://my-service.azure.com>");
TokenCredential credential = new DefaultAzureCredential();
BatchClient client = new BatchClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    containerUrl = "<containerUrl>",
    startTime = "2022-05-10T18:57:31.2311892Z",
    endTime = "2022-05-10T18:57:31.2311892Z",
    identityReference = new
    {
        resourceId = "<resourceId>",
    },
});
Response response = await client.UploadNodeLogsAsync("<poolId>", "<nodeId>", content, timeOutInSeconds: 1234, ocpdate: DateTimeOffset.Parse("Tue, 10 May 2022 18:57:31 GMT"));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("virtualDirectoryName").ToString());
Console.WriteLine(result.GetProperty("numberOfFilesUploaded").ToString());
]]></code></example>
      </Docs>
    </Member>
  </Members>
</Type>
