<Type Name="LoadTestRunClient" FullName="Azure.Developer.LoadTesting.LoadTestRunClient">
  <TypeSignature Language="C#" Value="public class LoadTestRunClient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LoadTestRunClient extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Developer.LoadTesting.LoadTestRunClient" />
  <TypeSignature Language="VB.NET" Value="Public Class LoadTestRunClient" />
  <TypeSignature Language="F#" Value="type LoadTestRunClient = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>1.0.1.0</AssemblyVersion>
    <AssemblyVersion>1.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The LoadTestRun service client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected LoadTestRunClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of LoadTestRunClient for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LoadTestRunClient (Uri endpoint, Azure.Core.TokenCredential credential);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri endpoint, class Azure.Core.TokenCredential credential) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.#ctor(System.Uri,Azure.Core.TokenCredential)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (endpoint As Uri, credential As TokenCredential)" />
      <MemberSignature Language="F#" Value="new Azure.Developer.LoadTesting.LoadTestRunClient : Uri * Azure.Core.TokenCredential -&gt; Azure.Developer.LoadTesting.LoadTestRunClient" Usage="new Azure.Developer.LoadTesting.LoadTestRunClient (endpoint, credential)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
      </Parameters>
      <Docs>
        <param name="endpoint"> URL to perform data plane API operations on the resource. </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <summary> Initializes a new instance of LoadTestRunClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endpoint" /> or <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LoadTestRunClient (Uri endpoint, Azure.Core.TokenCredential credential, Azure.Developer.LoadTesting.LoadTestingClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri endpoint, class Azure.Core.TokenCredential credential, class Azure.Developer.LoadTesting.LoadTestingClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.#ctor(System.Uri,Azure.Core.TokenCredential,Azure.Developer.LoadTesting.LoadTestingClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (endpoint As Uri, credential As TokenCredential, options As LoadTestingClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Developer.LoadTesting.LoadTestRunClient : Uri * Azure.Core.TokenCredential * Azure.Developer.LoadTesting.LoadTestingClientOptions -&gt; Azure.Developer.LoadTesting.LoadTestRunClient" Usage="new Azure.Developer.LoadTesting.LoadTestRunClient (endpoint, credential, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
        <Parameter Name="options" Type="Azure.Developer.LoadTesting.LoadTestingClientOptions" />
      </Parameters>
      <Docs>
        <param name="endpoint"> URL to perform data plane API operations on the resource. </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of LoadTestRunClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endpoint" /> or <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Developer.LoadTesting.TestRunResultOperation BeginTestRun (Azure.WaitUntil waitUntil, string testRunId, Azure.Core.RequestContent content, TimeSpan? timeSpan = default, string oldTestRunId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Developer.LoadTesting.TestRunResultOperation BeginTestRun(valuetype Azure.WaitUntil waitUntil, string testRunId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; timeSpan, string oldTestRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.BeginTestRun(Azure.WaitUntil,System.String,Azure.Core.RequestContent,System.Nullable{System.TimeSpan},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginTestRun (waitUntil As WaitUntil, testRunId As String, content As RequestContent, Optional timeSpan As Nullable(Of TimeSpan) = Nothing, Optional oldTestRunId As String = Nothing, Optional context As RequestContext = Nothing) As TestRunResultOperation" />
      <MemberSignature Language="F#" Value="abstract member BeginTestRun : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * string * Azure.RequestContext -&gt; Azure.Developer.LoadTesting.TestRunResultOperation&#xA;override this.BeginTestRun : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * string * Azure.RequestContext -&gt; Azure.Developer.LoadTesting.TestRunResultOperation" Usage="loadTestRunClient.BeginTestRun (waitUntil, testRunId, content, timeSpan, oldTestRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Developer.LoadTesting.TestRunResultOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeSpan" Type="System.Nullable&lt;System.TimeSpan&gt;" />
        <Parameter Name="oldTestRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="waitUntil"> Defines how to use the LRO, if passed WaitUntil.Completed then waits for test run to get completed</param>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="timeSpan"> pollingInterval for poller class, default value or null value is treated as 5 secs</param>
        <param name="oldTestRunId"> Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file, configuration and app components from the existing test run. You can override the configuration values for new test run in the request body. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Developer.LoadTesting.TestRunResultOperation&gt; BeginTestRunAsync (Azure.WaitUntil waitUntil, string testRunId, Azure.Core.RequestContent content, TimeSpan? timeSpan = default, string oldTestRunId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Developer.LoadTesting.TestRunResultOperation&gt; BeginTestRunAsync(valuetype Azure.WaitUntil waitUntil, string testRunId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; timeSpan, string oldTestRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.BeginTestRunAsync(Azure.WaitUntil,System.String,Azure.Core.RequestContent,System.Nullable{System.TimeSpan},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginTestRunAsync (waitUntil As WaitUntil, testRunId As String, content As RequestContent, Optional timeSpan As Nullable(Of TimeSpan) = Nothing, Optional oldTestRunId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of TestRunResultOperation)" />
      <MemberSignature Language="F#" Value="abstract member BeginTestRunAsync : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Developer.LoadTesting.TestRunResultOperation&gt;&#xA;override this.BeginTestRunAsync : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Developer.LoadTesting.TestRunResultOperation&gt;" Usage="loadTestRunClient.BeginTestRunAsync (waitUntil, testRunId, content, timeSpan, oldTestRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Developer.LoadTesting.TestRunResultOperation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeSpan" Type="System.Nullable&lt;System.TimeSpan&gt;" />
        <Parameter Name="oldTestRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="waitUntil"> Defines how to use the LRO, if passed WaitUntil.Completed then waits for test run to get completed</param>
        <param name="timeSpan"> pollingInterval for poller class, default value or null value is treated as 5 secs</param>
        <param name="oldTestRunId"> Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file, configuration and app components from the existing test run. You can override the configuration values for new test run in the request body. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateAppComponents">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateAppComponents (string testRunId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateAppComponents(string testRunId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateAppComponents(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateAppComponents (testRunId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateAppComponents : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateAppComponents : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.CreateOrUpdateAppComponents (testRunId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Associate an app component (collection of azure resources) to a test run
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateAppComponents and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    components = new
    {
        key = new object(),
    },
});
Response response = client.CreateOrUpdateAppComponents("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").ToString());
]]></code>
This sample shows how to call CreateOrUpdateAppComponents with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    components = new
    {
        key = new
        {
            resourceName = "<resourceName>",
            resourceType = "<resourceType>",
            displayName = "<displayName>",
            kind = "<kind>",
        },
    },
});
Response response = client.CreateOrUpdateAppComponents("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceGroup").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("subscriptionId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateAppComponentsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateAppComponentsAsync (string testRunId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateAppComponentsAsync(string testRunId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateAppComponentsAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateAppComponentsAsync (testRunId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateAppComponentsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateAppComponentsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.CreateOrUpdateAppComponentsAsync (testRunId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Associate an app component (collection of azure resources) to a test run
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateAppComponentsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    components = new
    {
        key = new object(),
    },
});
Response response = await client.CreateOrUpdateAppComponentsAsync("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").ToString());
]]></code>
This sample shows how to call CreateOrUpdateAppComponentsAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    components = new
    {
        key = new
        {
            resourceName = "<resourceName>",
            resourceType = "<resourceType>",
            displayName = "<displayName>",
            kind = "<kind>",
        },
    },
});
Response response = await client.CreateOrUpdateAppComponentsAsync("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceGroup").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("subscriptionId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateServerMetricsConfig">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateServerMetricsConfig (string testRunId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateServerMetricsConfig(string testRunId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateServerMetricsConfig(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateServerMetricsConfig (testRunId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateServerMetricsConfig : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateServerMetricsConfig : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.CreateOrUpdateServerMetricsConfig (testRunId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Configure server metrics for a test run
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateServerMetricsConfig and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.CreateOrUpdateServerMetricsConfig("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateServerMetricsConfig with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    metrics = new
    {
        key = new
        {
            resourceId = "<resourceId>",
            metricNamespace = "<metricNamespace>",
            displayDescription = "<displayDescription>",
            name = "<name>",
            aggregation = "<aggregation>",
            unit = "<unit>",
            resourceType = "<resourceType>",
        },
    },
});
Response response = client.CreateOrUpdateServerMetricsConfig("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("metricNamespace").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("displayDescription").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("aggregation").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateServerMetricsConfigAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateServerMetricsConfigAsync (string testRunId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateServerMetricsConfigAsync(string testRunId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateServerMetricsConfigAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateServerMetricsConfigAsync (testRunId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateServerMetricsConfigAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateServerMetricsConfigAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.CreateOrUpdateServerMetricsConfigAsync (testRunId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Configure server metrics for a test run
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateServerMetricsConfigAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.CreateOrUpdateServerMetricsConfigAsync("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateServerMetricsConfigAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    metrics = new
    {
        key = new
        {
            resourceId = "<resourceId>",
            metricNamespace = "<metricNamespace>",
            displayDescription = "<displayDescription>",
            name = "<name>",
            aggregation = "<aggregation>",
            unit = "<unit>",
            resourceType = "<resourceType>",
        },
    },
});
Response response = await client.CreateOrUpdateServerMetricsConfigAsync("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("metricNamespace").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("displayDescription").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("aggregation").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateTestRun (string testRunId, Azure.Core.RequestContent content, string oldTestRunId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateTestRun(string testRunId, class Azure.Core.RequestContent content, string oldTestRunId, class Azure.RequestContext context) cil managed" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateTestRun(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateTestRun (testRunId As String, content As RequestContent, Optional oldTestRunId As String = Nothing, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateTestRun : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateTestRun : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.CreateOrUpdateTestRun (testRunId, content, oldTestRunId, context)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="azure-dotnet-preview">Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="oldTestRunId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="3" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="oldTestRunId"> Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file, configuration and app components from the existing test run. You can override the configuration values for new test run in the request body. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateTestRun with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {};

Response response = client.CreateOrUpdateTestRun("<testRunId>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateTestRun with all parameters and request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {
    passFailCriteria = new {
        passFailMetrics = new {
            key = new {
                clientMetric = "response_time_ms",
                aggregate = "count",
                condition = "<condition>",
                requestName = "<requestName>",
                value = 123.45d,
                action = "continue",
            },
        },
    },
    secrets = new {
        key = new {
            value = "<value>",
            type = "AKV_SECRET_URI",
        },
    },
    certificate = new {
        value = "<value>",
        type = "AKV_CERT_URI",
        name = "<name>",
    },
    environmentVariables = new {
        key = "<String>",
    },
    loadTestConfiguration = new {
        engineInstances = 1234,
        splitAllCSVs = true,
        quickStartTest = true,
        optionalLoadTestConfig = new {
            endpointUrl = "<endpointUrl>",
            virtualUsers = 1234,
            rampUpTime = 1234,
            duration = 1234,
        },
    },
    displayName = "<displayName>",
    testId = "<testId>",
    description = "<description>",
};

Response response = client.CreateOrUpdateTestRun("<testRunId>", RequestContent.Create(data), "<oldTestRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateTestRunAsync (string testRunId, Azure.Core.RequestContent content, string oldTestRunId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateTestRunAsync(string testRunId, class Azure.Core.RequestContent content, string oldTestRunId, class Azure.RequestContext context) cil managed" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateTestRunAsync(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateTestRunAsync (testRunId As String, content As RequestContent, Optional oldTestRunId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateTestRunAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateTestRunAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.CreateOrUpdateTestRunAsync (testRunId, content, oldTestRunId, context)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="azure-dotnet-preview">System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="oldTestRunId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="3" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="oldTestRunId"> Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file, configuration and app components from the existing test run. You can override the configuration values for new test run in the request body. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateTestRunAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {};

Response response = await client.CreateOrUpdateTestRunAsync("<testRunId>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateTestRunAsync with all parameters and request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {
    passFailCriteria = new {
        passFailMetrics = new {
            key = new {
                clientMetric = "response_time_ms",
                aggregate = "count",
                condition = "<condition>",
                requestName = "<requestName>",
                value = 123.45d,
                action = "continue",
            },
        },
    },
    secrets = new {
        key = new {
            value = "<value>",
            type = "AKV_SECRET_URI",
        },
    },
    certificate = new {
        value = "<value>",
        type = "AKV_CERT_URI",
        name = "<name>",
    },
    environmentVariables = new {
        key = "<String>",
    },
    loadTestConfiguration = new {
        engineInstances = 1234,
        splitAllCSVs = true,
        quickStartTest = true,
        optionalLoadTestConfig = new {
            endpointUrl = "<endpointUrl>",
            virtualUsers = 1234,
            rampUpTime = 1234,
            duration = 1234,
        },
    },
    displayName = "<displayName>",
    testId = "<testId>",
    description = "<description>",
};

Response response = await client.CreateOrUpdateTestRunAsync("<testRunId>", RequestContent.Create(data), "<oldTestRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteTestRun (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteTestRun(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.DeleteTestRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTestRun (testRunId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteTestRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteTestRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.DeleteTestRun (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete a test run by its name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteTestRun.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.DeleteTestRun("<testRunId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTestRun with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.DeleteTestRun("<testRunId>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteTestRunAsync (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteTestRunAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.DeleteTestRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTestRunAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.DeleteTestRunAsync (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete a test run by its name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteTestRunAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.DeleteTestRunAsync("<testRunId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTestRunAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.DeleteTestRunAsync("<testRunId>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetAppComponents">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetAppComponents (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetAppComponents(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetAppComponents(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAppComponents (testRunId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetAppComponents : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetAppComponents : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetAppComponents (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get associated app component (collection of azure resources) for the given test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetAppComponents and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetAppComponents("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").ToString());
]]></code>
This sample shows how to call GetAppComponents with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetAppComponents("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceGroup").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("subscriptionId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetAppComponentsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetAppComponentsAsync (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetAppComponentsAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetAppComponentsAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAppComponentsAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetAppComponentsAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetAppComponentsAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetAppComponentsAsync (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get associated app component (collection of azure resources) for the given test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetAppComponentsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetAppComponentsAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").ToString());
]]></code>
This sample shows how to call GetAppComponentsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetAppComponentsAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceGroup").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("subscriptionId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDefinitions">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetMetricDefinitions (string testRunId, string metricNamespace, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetMetricDefinitions(string testRunId, string metricNamespace, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDefinitions(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDefinitions (testRunId As String, metricNamespace As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDefinitions : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetMetricDefinitions : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetMetricDefinitions (testRunId, metricNamespace, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the metric definitions for a load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>MetricDefinitionCollection</c>:
<code>{
  value: [
    {
      dimensions: [
        {
          description: string, # Optional. The description
          name: string, # Optional. The name
        }
      ], # Optional. List of dimensions
      description: string, # Optional. The metric description
      name: string, # Optional. The metric name
      namespace: string, # Optional. The namespace the metric belongs to.
      primaryAggregationType: "Average" | "Count" | "None" | "Total" | "Percentile90" | "Percentile95" | "Percentile99", # Optional. The primary aggregation type value defining how to use the values for display.
      supportedAggregationTypes: [string], # Optional. The collection of what all aggregation types are supported.
      unit: "NotSpecified" | "Percent" | "Count" | "Seconds" | "Milliseconds" | "Bytes" | "BytesPerSecond" | "CountPerSecond", # Optional. The unit of the metric.
      metricAvailabilities: [
        {
          timeGrain: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H", # Optional. The time grain specifies the aggregation interval for the metric. Expressed as a duration 'PT1M', 'PT1H', etc.
        }
      ], # Optional. Metric availability specifies the time grain (aggregation interval or frequency).
    }
  ], # Required. the values for the metric definitions.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="metricNamespace" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetMetricDefinitions and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetMetricDefinitions("<testRunId>", "<metricNamespace>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].ToString());
]]></code>
This sample shows how to call GetMetricDefinitions with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetMetricDefinitions("<testRunId>", "<metricNamespace>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("namespace").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("primaryAggregationType").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("supportedAggregationTypes")[0].ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("metricAvailabilities")[0].GetProperty("timeGrain").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDefinitionsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetMetricDefinitionsAsync (string testRunId, string metricNamespace, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetMetricDefinitionsAsync(string testRunId, string metricNamespace, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDefinitionsAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDefinitionsAsync (testRunId As String, metricNamespace As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDefinitionsAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetMetricDefinitionsAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetMetricDefinitionsAsync (testRunId, metricNamespace, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the metric definitions for a load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>MetricDefinitionCollection</c>:
<code>{
  value: [
    {
      dimensions: [
        {
          description: string, # Optional. The description
          name: string, # Optional. The name
        }
      ], # Optional. List of dimensions
      description: string, # Optional. The metric description
      name: string, # Optional. The metric name
      namespace: string, # Optional. The namespace the metric belongs to.
      primaryAggregationType: "Average" | "Count" | "None" | "Total" | "Percentile90" | "Percentile95" | "Percentile99", # Optional. The primary aggregation type value defining how to use the values for display.
      supportedAggregationTypes: [string], # Optional. The collection of what all aggregation types are supported.
      unit: "NotSpecified" | "Percent" | "Count" | "Seconds" | "Milliseconds" | "Bytes" | "BytesPerSecond" | "CountPerSecond", # Optional. The unit of the metric.
      metricAvailabilities: [
        {
          timeGrain: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H", # Optional. The time grain specifies the aggregation interval for the metric. Expressed as a duration 'PT1M', 'PT1H', etc.
        }
      ], # Optional. Metric availability specifies the time grain (aggregation interval or frequency).
    }
  ], # Required. the values for the metric definitions.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="metricNamespace" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetMetricDefinitionsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetMetricDefinitionsAsync("<testRunId>", "<metricNamespace>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].ToString());
]]></code>
This sample shows how to call GetMetricDefinitionsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetMetricDefinitionsAsync("<testRunId>", "<metricNamespace>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("namespace").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("primaryAggregationType").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("supportedAggregationTypes")[0].ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("metricAvailabilities")[0].GetProperty("timeGrain").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDimensionValues">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetMetricDimensionValues (string testRunId, string name, string metricName, string metricNamespace, string timeInterval, string interval = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetMetricDimensionValues(string testRunId, string name, string metricName, string metricNamespace, string timeInterval, string interval, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDimensionValues(System.String,System.String,System.String,System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDimensionValues (testRunId As String, name As String, metricName As String, metricNamespace As String, timeInterval As String, Optional interval As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDimensionValues : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetMetricDimensionValues : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetricDimensionValues (testRunId, name, metricName, metricNamespace, timeInterval, interval, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="metricName" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="timeInterval" Type="System.String" />
        <Parameter Name="interval" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="name"> Dimension name. </param>
        <param name="metricName"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timeInterval"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the dimension values for the given metric dimension name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="name" />, <paramref name="metricName" />, <paramref name="metricNamespace" /> or <paramref name="timeInterval" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetMetricDimensionValues and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

foreach (BinaryData item in client.GetMetricDimensionValues("<testRunId>", "<name>", "<metricName>", "<metricNamespace>", "<timeInterval>"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetMetricDimensionValues with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

foreach (BinaryData item in client.GetMetricDimensionValues("<testRunId>", "<name>", "<metricName>", "<metricNamespace>", "<timeInterval>", interval: "PT5S"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDimensionValuesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetMetricDimensionValuesAsync (string testRunId, string name, string metricName, string metricNamespace, string timeInterval, string interval = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetMetricDimensionValuesAsync(string testRunId, string name, string metricName, string metricNamespace, string timeInterval, string interval, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDimensionValuesAsync(System.String,System.String,System.String,System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDimensionValuesAsync (testRunId As String, name As String, metricName As String, metricNamespace As String, timeInterval As String, Optional interval As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDimensionValuesAsync : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetMetricDimensionValuesAsync : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetricDimensionValuesAsync (testRunId, name, metricName, metricNamespace, timeInterval, interval, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="metricName" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="timeInterval" Type="System.String" />
        <Parameter Name="interval" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="name"> Dimension name. </param>
        <param name="metricName"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timeInterval"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the dimension values for the given metric dimension name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="name" />, <paramref name="metricName" />, <paramref name="metricNamespace" /> or <paramref name="timeInterval" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetMetricDimensionValuesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

await foreach (BinaryData item in client.GetMetricDimensionValuesAsync("<testRunId>", "<name>", "<metricName>", "<metricNamespace>", "<timeInterval>"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetMetricDimensionValuesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

await foreach (BinaryData item in client.GetMetricDimensionValuesAsync("<testRunId>", "<name>", "<metricName>", "<metricNamespace>", "<timeInterval>", interval: "PT5S"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetMetricNamespaces">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetMetricNamespaces (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetMetricNamespaces(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricNamespaces(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricNamespaces (testRunId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetMetricNamespaces : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetMetricNamespaces : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetMetricNamespaces (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the metric namespaces for a load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>MetricNamespaceCollection</c>:
<code>{
  value: [
    {
      description: string, # Optional. The namespace description.
      name: string, # Optional. The metric namespace name.
    }
  ], # Required. The values for the metric namespaces.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetMetricNamespaces and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetMetricNamespaces("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].ToString());
]]></code>
This sample shows how to call GetMetricNamespaces with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetMetricNamespaces("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetMetricNamespacesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetMetricNamespacesAsync (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetMetricNamespacesAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricNamespacesAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricNamespacesAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricNamespacesAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetMetricNamespacesAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetMetricNamespacesAsync (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the metric namespaces for a load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>MetricNamespaceCollection</c>:
<code>{
  value: [
    {
      description: string, # Optional. The namespace description.
      name: string, # Optional. The metric namespace name.
    }
  ], # Required. The values for the metric namespaces.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetMetricNamespacesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetMetricNamespacesAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].ToString());
]]></code>
This sample shows how to call GetMetricNamespacesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetMetricNamespacesAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetMetrics">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetMetrics (string testRunId, string metricName, string metricNamespace, string timespan, Azure.Core.RequestContent content = default, string aggregation = default, string interval = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetMetrics(string testRunId, string metricName, string metricNamespace, string timespan, class Azure.Core.RequestContent content, string aggregation, string interval, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetrics(System.String,System.String,System.String,System.String,Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetrics (testRunId As String, metricName As String, metricNamespace As String, timespan As String, Optional content As RequestContent = Nothing, Optional aggregation As String = Nothing, Optional interval As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetMetrics : string * string * string * string * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetMetrics : string * string * string * string * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetrics (testRunId, metricName, metricNamespace, timespan, content, aggregation, interval, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="metricName" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="timespan" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="aggregation" Type="System.String" />
        <Parameter Name="interval" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="metricName"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="aggregation"> The aggregation. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> List the metric values for a load     test run. </summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>
Below is the JSON schema for the request payload and one item in the pageable response.

Request Body:

Schema for <c>MetricRequestPayload</c>:
<code>{
  filters: [
    {
      name: string, # Optional. The dimension name
      values: [string], # Optional. The dimension values. Maximum values can be 20.
    }
  ], # Optional. Get metrics for specific dimension values. Example: Metric contains dimension like SamplerName, Error. To retrieve all the time series data where SamplerName is equals to HTTPRequest1 or HTTPRequest2, the DimensionFilter value will be {"SamplerName", ["HTTPRequest1", "HTTPRequest2"}
}
</code>

Response Body:

Schema for <c>MetricsValue</c>:
<code>{
  data: [
    {
      timestamp: string, # Optional. The timestamp for the metric value in ISO 8601 format.
      value: number, # Optional. The metric value.
    }
  ], # Optional. An array of data points representing the metric values.
  dimensionValues: [
    {
      name: string, # Optional. The name of the dimension.
      value: string, # Optional. The value of the dimension.
    }
  ], # Optional. The dimension values 
}
</code></remarks>
        <example>
This sample shows how to call GetMetrics with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {};

foreach (var data in client.GetMetrics("<testRunId>", "<metricname>", "<metricNamespace>", "<timespan>", RequestContent.Create(data)))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetMetrics with all parameters and request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {
    filters = new[] {
        new {
            name = "<name>",
            values = new[] {
                "<String>"
            },
        }
    },
};

foreach (var data in client.GetMetrics("<testRunId>", "<metricname>", "<metricNamespace>", "<timespan>", RequestContent.Create(data), "<aggregation>", "<interval>"))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("data")[0].GetProperty("timestamp").ToString());
    Console.WriteLine(result.GetProperty("data")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("dimensionValues")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("dimensionValues")[0].GetProperty("value").ToString());
}
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="metricName" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <!-- No matching elements were found for the following include tag -->
        <include file="Generated/Docs/LoadTestRunClient.xml" path="doc/members/member[@name='GetMetrics(String,String,String,String,RequestContent,String,String,RequestContext)']/*" />
      </Docs>
    </Member>
    <Member MemberName="GetMetricsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetMetricsAsync (string testRunId, string metricName, string metricNamespace, string timespan, Azure.Core.RequestContent content = default, string aggregation = default, string interval = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetMetricsAsync(string testRunId, string metricName, string metricNamespace, string timespan, class Azure.Core.RequestContent content, string aggregation, string interval, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricsAsync(System.String,System.String,System.String,System.String,Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricsAsync (testRunId As String, metricName As String, metricNamespace As String, timespan As String, Optional content As RequestContent = Nothing, Optional aggregation As String = Nothing, Optional interval As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricsAsync : string * string * string * string * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetMetricsAsync : string * string * string * string * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetricsAsync (testRunId, metricName, metricNamespace, timespan, content, aggregation, interval, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="metricName" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="timespan" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="aggregation" Type="System.String" />
        <Parameter Name="interval" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="metricName"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="aggregation"> The aggregation. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> List the metric values for a load test run. </summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>
Below is the JSON schema for the request payload and one item in the pageable response.

Request Body:

Schema for <c>MetricRequestPayload</c>:
<code>{
  filters: [
    {
      name: string, # Optional. The dimension name
      values: [string], # Optional. The dimension values. Maximum values can be 20.
    }
  ], # Optional. Get metrics for specific dimension values. Example: Metric contains dimension like SamplerName, Error. To retrieve all the time series data where SamplerName is equals to HTTPRequest1 or HTTPRequest2, the DimensionFilter value will be {"SamplerName", ["HTTPRequest1", "HTTPRequest2"}
}
</code>

Response Body:

Schema for <c>MetricsValue</c>:
<code>{
  data: [
    {
      timestamp: string, # Optional. The timestamp for the metric value in ISO 8601 format.
      value: number, # Optional. The metric value.
    }
  ], # Optional. An array of data points representing the metric values.
  dimensionValues: [
    {
      name: string, # Optional. The name of the dimension.
      value: string, # Optional. The value of the dimension.
    }
  ], # Optional. The dimension values 
}
</code></remarks>
        <example>
This sample shows how to call GetMetricsAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {};

await foreach (var data in client.GetMetricsAsync("<testRunId>", "<metricname>", "<metricNamespace>", "<timespan>", RequestContent.Create(data)))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetMetricsAsync with all parameters and request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {
    filters = new[] {
        new {
            name = "<name>",
            values = new[] {
                "<String>"
            },
        }
    },
};

await foreach (var data in client.GetMetricsAsync("<testRunId>", "<metricname>", "<metricNamespace>", "<timespan>", RequestContent.Create(data), "<aggregation>", "<interval>"))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("data")[0].GetProperty("timestamp").ToString());
    Console.WriteLine(result.GetProperty("data")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("dimensionValues")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("dimensionValues")[0].GetProperty("value").ToString());
}
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="metricName" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <!-- No matching elements were found for the following include tag -->
        <include file="Generated/Docs/LoadTestRunClient.xml" path="doc/members/member[@name='GetMetricsAsync(String,String,String,String,RequestContent,String,String,RequestContext)']/*" />
      </Docs>
    </Member>
    <Member MemberName="GetServerMetricsConfig">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetServerMetricsConfig (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetServerMetricsConfig(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetServerMetricsConfig(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServerMetricsConfig (testRunId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetServerMetricsConfig : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetServerMetricsConfig : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetServerMetricsConfig (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List server metrics configuration for the given test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetServerMetricsConfig and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetServerMetricsConfig("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetServerMetricsConfig with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetServerMetricsConfig("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("metricNamespace").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("displayDescription").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("aggregation").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetServerMetricsConfigAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetServerMetricsConfigAsync (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetServerMetricsConfigAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetServerMetricsConfigAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServerMetricsConfigAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetServerMetricsConfigAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetServerMetricsConfigAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetServerMetricsConfigAsync (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List server metrics configuration for the given test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetServerMetricsConfigAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetServerMetricsConfigAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetServerMetricsConfigAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetServerMetricsConfigAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("metricNamespace").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("displayDescription").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("aggregation").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTestRun (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTestRun(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRun (testRunId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTestRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTestRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetTestRun (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test run details by name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTestRun and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetTestRun("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTestRun with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetTestRun("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTestRunAsync (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTestRunAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetTestRunAsync (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test run details by name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTestRunAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetTestRunAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTestRunAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetTestRunAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTestRunFile (string testRunId, string fileName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTestRunFile(string testRunId, string fileName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunFile(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunFile (testRunId As String, fileName As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunFile : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTestRunFile : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetTestRunFile (testRunId, fileName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="fileName"> Test run file name with file extension. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test run file by file name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>FileInfo</c>:
<code>{
  url: string, # Optional. File URL.
  fileName: string, # Optional. Name of the file.
  fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
  expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
  validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
  validationFailureDetails: string, # Optional. Validation failure error details
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTestRunFile and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetTestRunFile("<testRunId>", "<fileName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTestRunFile with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetTestRunFile("<testRunId>", "<fileName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("validationFailureDetails").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTestRunFileAsync (string testRunId, string fileName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTestRunFileAsync(string testRunId, string fileName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunFileAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunFileAsync (testRunId As String, fileName As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunFileAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTestRunFileAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetTestRunFileAsync (testRunId, fileName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="fileName"> Test run file name with file extension. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test run file by file name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>FileInfo</c>:
<code>{
  url: string, # Optional. File URL.
  fileName: string, # Optional. Name of the file.
  fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
  expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
  validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
  validationFailureDetails: string, # Optional. Validation failure error details
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTestRunFileAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetTestRunFileAsync("<testRunId>", "<fileName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTestRunFileAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetTestRunFileAsync("<testRunId>", "<fileName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("validationFailureDetails").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTestRuns">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetTestRuns (string orderby = default, string search = default, string testId = default, DateTimeOffset? executionFrom = default, DateTimeOffset? executionTo = default, string status = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetTestRuns(string orderby, string search, string testId, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionFrom, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionTo, string status, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRuns(System.String,System.String,System.String,System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRuns (Optional orderby As String = Nothing, Optional search As String = Nothing, Optional testId As String = Nothing, Optional executionFrom As Nullable(Of DateTimeOffset) = Nothing, Optional executionTo As Nullable(Of DateTimeOffset) = Nothing, Optional status As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTestRuns : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetTestRuns : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetTestRuns (orderby, search, testId, executionFrom, executionTo, status, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orderby" Type="System.String" />
        <Parameter Name="search" Type="System.String" />
        <Parameter Name="testId" Type="System.String" />
        <Parameter Name="executionFrom" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="executionTo" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="status" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="orderby"> Sort on the supported fields in (field asc/desc) format. eg: executedDateTime asc. Supported fields - executedDateTime. </param>
        <param name="search"> Prefix based, case sensitive search on searchable fields - description, executedUser. For example, to search for a test run, with description 500 VUs, the search parameter can be 500. </param>
        <param name="testId"> Unique name of an existing load test. </param>
        <param name="executionFrom"> Start DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        <param name="executionTo"> End DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        <param name="status"> Comma separated list of test run status. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Get all test runs with given filters. </summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetTestRunsAsync (string orderby = default, string search = default, string testId = default, DateTimeOffset? executionFrom = default, DateTimeOffset? executionTo = default, string status = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetTestRunsAsync(string orderby, string search, string testId, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionFrom, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionTo, string status, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunsAsync(System.String,System.String,System.String,System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunsAsync (Optional orderby As String = Nothing, Optional search As String = Nothing, Optional testId As String = Nothing, Optional executionFrom As Nullable(Of DateTimeOffset) = Nothing, Optional executionTo As Nullable(Of DateTimeOffset) = Nothing, Optional status As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunsAsync : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetTestRunsAsync : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetTestRunsAsync (orderby, search, testId, executionFrom, executionTo, status, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orderby" Type="System.String" />
        <Parameter Name="search" Type="System.String" />
        <Parameter Name="testId" Type="System.String" />
        <Parameter Name="executionFrom" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="executionTo" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="status" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="orderby"> Sort on the supported fields in (field asc/desc) format. eg: executedDateTime asc. Supported fields - executedDateTime. </param>
        <param name="search"> Prefix based, case sensitive search on searchable fields - description, executedUser. For example, to search for a test run, with description 500 VUs, the search parameter can be 500. </param>
        <param name="testId"> Unique name of an existing load test. </param>
        <param name="executionFrom"> Start DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        <param name="executionTo"> End DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        <param name="status"> Comma separated list of test run status. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Get all test runs with given filters. </summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Developer.LoadTesting.LoadTestRunClient.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Developer.LoadTesting.LoadTestRunClient.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response StopTestRun (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response StopTestRun(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestRun (testRunId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member StopTestRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.StopTestRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.StopTestRun (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Stop test run by name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call StopTestRun and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.StopTestRun("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call StopTestRun with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.StopTestRun("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="StopTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; StopTestRunAsync (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; StopTestRunAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestRunAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member StopTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.StopTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.StopTestRunAsync (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.1.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Stop test run by name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call StopTestRunAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.StopTestRunAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call StopTestRunAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.StopTestRunAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
  </Members>
</Type>
