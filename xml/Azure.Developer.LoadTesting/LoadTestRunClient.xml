<Type Name="LoadTestRunClient" FullName="Azure.Developer.LoadTesting.LoadTestRunClient">
  <TypeSignature Language="C#" Value="public class LoadTestRunClient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LoadTestRunClient extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Developer.LoadTesting.LoadTestRunClient" />
  <TypeSignature Language="VB.NET" Value="Public Class LoadTestRunClient" />
  <TypeSignature Language="F#" Value="type LoadTestRunClient = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>1.0.1.0</AssemblyVersion>
    <AssemblyVersion>1.0.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The LoadTestRun service client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected LoadTestRunClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of LoadTestRunClient for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LoadTestRunClient (Uri endpoint, Azure.Core.TokenCredential credential);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri endpoint, class Azure.Core.TokenCredential credential) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.#ctor(System.Uri,Azure.Core.TokenCredential)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (endpoint As Uri, credential As TokenCredential)" />
      <MemberSignature Language="F#" Value="new Azure.Developer.LoadTesting.LoadTestRunClient : Uri * Azure.Core.TokenCredential -&gt; Azure.Developer.LoadTesting.LoadTestRunClient" Usage="new Azure.Developer.LoadTesting.LoadTestRunClient (endpoint, credential)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
      </Parameters>
      <Docs>
        <param name="endpoint"> The <see cref="T:System.Uri" /> to use. </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <summary> Initializes a new instance of LoadTestRunClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endpoint" /> or <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LoadTestRunClient (Uri endpoint, Azure.Core.TokenCredential credential, Azure.Developer.LoadTesting.LoadTestingClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri endpoint, class Azure.Core.TokenCredential credential, class Azure.Developer.LoadTesting.LoadTestingClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.#ctor(System.Uri,Azure.Core.TokenCredential,Azure.Developer.LoadTesting.LoadTestingClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (endpoint As Uri, credential As TokenCredential, options As LoadTestingClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Developer.LoadTesting.LoadTestRunClient : Uri * Azure.Core.TokenCredential * Azure.Developer.LoadTesting.LoadTestingClientOptions -&gt; Azure.Developer.LoadTesting.LoadTestRunClient" Usage="new Azure.Developer.LoadTesting.LoadTestRunClient (endpoint, credential, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
        <Parameter Name="options" Type="Azure.Developer.LoadTesting.LoadTestingClientOptions" />
      </Parameters>
      <Docs>
        <param name="endpoint"> The <see cref="T:System.Uri" /> to use. </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of LoadTestRunClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endpoint" /> or <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTestProfileRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Operation&lt;BinaryData&gt; BeginTestProfileRun (Azure.WaitUntil waitUntil, string testProfileRunId, Azure.Core.RequestContent content, TimeSpan? timeSpan = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Operation`1&lt;class System.BinaryData&gt; BeginTestProfileRun(valuetype Azure.WaitUntil waitUntil, string testProfileRunId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; timeSpan, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.BeginTestProfileRun(Azure.WaitUntil,System.String,Azure.Core.RequestContent,System.Nullable{System.TimeSpan},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginTestProfileRun (waitUntil As WaitUntil, testProfileRunId As String, content As RequestContent, Optional timeSpan As Nullable(Of TimeSpan) = Nothing, Optional context As RequestContext = Nothing) As Operation(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member BeginTestProfileRun : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * Azure.RequestContext -&gt; Azure.Operation&lt;BinaryData&gt;&#xA;override this.BeginTestProfileRun : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * Azure.RequestContext -&gt; Azure.Operation&lt;BinaryData&gt;" Usage="loadTestRunClient.BeginTestProfileRun (waitUntil, testProfileRunId, content, timeSpan, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Operation&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileRunId" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="timeSpan" Type="System.Nullable&lt;System.TimeSpan&gt;" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="4" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="waitUntil"> Defines how to use the LRO, if passed WaitUntil.Completed then waits for test profile run to get completed</param>
        <param name="testProfileRunId"> Unique name for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="timeSpan"> pollingInterval for poller class, default value or null value is treated as 5 secs</param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test profile run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTestProfileRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Operation&lt;BinaryData&gt;&gt; BeginTestProfileRunAsync (Azure.WaitUntil waitUntil, string testProfileRunId, Azure.Core.RequestContent content, TimeSpan? timeSpan = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Operation`1&lt;class System.BinaryData&gt;&gt; BeginTestProfileRunAsync(valuetype Azure.WaitUntil waitUntil, string testProfileRunId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; timeSpan, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.BeginTestProfileRunAsync(Azure.WaitUntil,System.String,Azure.Core.RequestContent,System.Nullable{System.TimeSpan},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginTestProfileRunAsync (waitUntil As WaitUntil, testProfileRunId As String, content As RequestContent, Optional timeSpan As Nullable(Of TimeSpan) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Operation(Of BinaryData))" />
      <MemberSignature Language="F#" Value="abstract member BeginTestProfileRunAsync : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Operation&lt;BinaryData&gt;&gt;&#xA;override this.BeginTestProfileRunAsync : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Operation&lt;BinaryData&gt;&gt;" Usage="loadTestRunClient.BeginTestProfileRunAsync (waitUntil, testProfileRunId, content, timeSpan, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Operation&lt;System.BinaryData&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileRunId" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="timeSpan" Type="System.Nullable&lt;System.TimeSpan&gt;" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="4" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="waitUntil"> Defines how to use the LRO, if passed WaitUntil.Completed then waits for test profile run to get completed</param>
        <param name="testProfileRunId"> Unique name for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="timeSpan"> pollingInterval for poller class, default value or null value is treated as 5 secs</param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test profile run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Developer.LoadTesting.TestRunResultOperation BeginTestRun (Azure.WaitUntil waitUntil, string testRunId, Azure.Core.RequestContent content, TimeSpan? timeSpan = default, string oldTestRunId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Developer.LoadTesting.TestRunResultOperation BeginTestRun(valuetype Azure.WaitUntil waitUntil, string testRunId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; timeSpan, string oldTestRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.BeginTestRun(Azure.WaitUntil,System.String,Azure.Core.RequestContent,System.Nullable{System.TimeSpan},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginTestRun (waitUntil As WaitUntil, testRunId As String, content As RequestContent, Optional timeSpan As Nullable(Of TimeSpan) = Nothing, Optional oldTestRunId As String = Nothing, Optional context As RequestContext = Nothing) As TestRunResultOperation" />
      <MemberSignature Language="F#" Value="abstract member BeginTestRun : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * string * Azure.RequestContext -&gt; Azure.Developer.LoadTesting.TestRunResultOperation&#xA;override this.BeginTestRun : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * string * Azure.RequestContext -&gt; Azure.Developer.LoadTesting.TestRunResultOperation" Usage="loadTestRunClient.BeginTestRun (waitUntil, testRunId, content, timeSpan, oldTestRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Developer.LoadTesting.TestRunResultOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeSpan" Type="System.Nullable&lt;System.TimeSpan&gt;" />
        <Parameter Name="oldTestRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="waitUntil"> Defines how to use the LRO, if passed WaitUntil.Completed then waits for test run to get completed</param>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="timeSpan"> pollingInterval for poller class, default value or null value is treated as 5 secs</param>
        <param name="oldTestRunId"> Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file, configuration and app components from the existing test run. You can override the configuration values for new test run in the request body. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Developer.LoadTesting.TestRunResultOperation&gt; BeginTestRunAsync (Azure.WaitUntil waitUntil, string testRunId, Azure.Core.RequestContent content, TimeSpan? timeSpan = default, string oldTestRunId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Developer.LoadTesting.TestRunResultOperation&gt; BeginTestRunAsync(valuetype Azure.WaitUntil waitUntil, string testRunId, class Azure.Core.RequestContent content, valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; timeSpan, string oldTestRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.BeginTestRunAsync(Azure.WaitUntil,System.String,Azure.Core.RequestContent,System.Nullable{System.TimeSpan},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginTestRunAsync (waitUntil As WaitUntil, testRunId As String, content As RequestContent, Optional timeSpan As Nullable(Of TimeSpan) = Nothing, Optional oldTestRunId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of TestRunResultOperation)" />
      <MemberSignature Language="F#" Value="abstract member BeginTestRunAsync : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Developer.LoadTesting.TestRunResultOperation&gt;&#xA;override this.BeginTestRunAsync : Azure.WaitUntil * string * Azure.Core.RequestContent * Nullable&lt;TimeSpan&gt; * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Developer.LoadTesting.TestRunResultOperation&gt;" Usage="loadTestRunClient.BeginTestRunAsync (waitUntil, testRunId, content, timeSpan, oldTestRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Developer.LoadTesting.TestRunResultOperation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="timeSpan" Type="System.Nullable&lt;System.TimeSpan&gt;" />
        <Parameter Name="oldTestRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="waitUntil"> Defines how to use the LRO, if passed WaitUntil.Completed then waits for test run to get completed</param>
        <param name="timeSpan"> pollingInterval for poller class, default value or null value is treated as 5 secs</param>
        <param name="oldTestRunId"> Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file, configuration and app components from the existing test run. You can override the configuration values for new test run in the request body. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateAppComponents">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateAppComponents (string testRunId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateAppComponents(string testRunId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateAppComponents(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateAppComponents (testRunId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateAppComponents : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateAppComponents : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.CreateOrUpdateAppComponents (testRunId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique Id for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add an app component to a test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call CreateOrUpdateAppComponents and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    components = new
    {
        key = new object(),
    },
});
Response response = client.CreateOrUpdateAppComponents("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").ToString());
]]></code>
This sample shows how to call CreateOrUpdateAppComponents with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    components = new
    {
        key = new
        {
            resourceName = "<resourceName>",
            resourceType = "<resourceType>",
            displayName = "<displayName>",
            kind = "<kind>",
        },
    },
});
Response response = client.CreateOrUpdateAppComponents("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceGroup").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("subscriptionId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateAppComponentsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateAppComponentsAsync (string testRunId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateAppComponentsAsync(string testRunId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateAppComponentsAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateAppComponentsAsync (testRunId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateAppComponentsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateAppComponentsAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.CreateOrUpdateAppComponentsAsync (testRunId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique Id for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Add an app component to a test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call CreateOrUpdateAppComponentsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    components = new
    {
        key = new object(),
    },
});
Response response = await client.CreateOrUpdateAppComponentsAsync("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").ToString());
]]></code>
This sample shows how to call CreateOrUpdateAppComponentsAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    components = new
    {
        key = new
        {
            resourceName = "<resourceName>",
            resourceType = "<resourceType>",
            displayName = "<displayName>",
            kind = "<kind>",
        },
    },
});
Response response = await client.CreateOrUpdateAppComponentsAsync("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceGroup").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("subscriptionId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateServerMetricsConfig">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateServerMetricsConfig (string testRunId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateServerMetricsConfig(string testRunId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateServerMetricsConfig(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateServerMetricsConfig (testRunId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateServerMetricsConfig : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateServerMetricsConfig : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.CreateOrUpdateServerMetricsConfig (testRunId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique Id for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Configure server metrics for a test run
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call CreateOrUpdateServerMetricsConfig and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.CreateOrUpdateServerMetricsConfig("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateServerMetricsConfig with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    metrics = new
    {
        key = new
        {
            resourceId = "<resourceId>",
            metricNamespace = "<metricNamespace>",
            displayDescription = "<displayDescription>",
            name = "<name>",
            aggregation = "<aggregation>",
            unit = "<unit>",
            resourceType = "<resourceType>",
        },
    },
});
Response response = client.CreateOrUpdateServerMetricsConfig("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("metricNamespace").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("displayDescription").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("aggregation").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateServerMetricsConfigAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateServerMetricsConfigAsync (string testRunId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateServerMetricsConfigAsync(string testRunId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateServerMetricsConfigAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateServerMetricsConfigAsync (testRunId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateServerMetricsConfigAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateServerMetricsConfigAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.CreateOrUpdateServerMetricsConfigAsync (testRunId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique Id for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Configure server metrics for a test run
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call CreateOrUpdateServerMetricsConfigAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.CreateOrUpdateServerMetricsConfigAsync("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateServerMetricsConfigAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    metrics = new
    {
        key = new
        {
            resourceId = "<resourceId>",
            metricNamespace = "<metricNamespace>",
            displayDescription = "<displayDescription>",
            name = "<name>",
            aggregation = "<aggregation>",
            unit = "<unit>",
            resourceType = "<resourceType>",
        },
    },
});
Response response = await client.CreateOrUpdateServerMetricsConfigAsync("<testRunId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("metricNamespace").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("displayDescription").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("aggregation").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateTestRun (string testRunId, Azure.Core.RequestContent content, string oldTestRunId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateTestRun(string testRunId, class Azure.Core.RequestContent content, string oldTestRunId, class Azure.RequestContext context) cil managed" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateTestRun(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateTestRun (testRunId As String, content As RequestContent, Optional oldTestRunId As String = Nothing, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateTestRun : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateTestRun : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.CreateOrUpdateTestRun (testRunId, content, oldTestRunId, context)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="azure-dotnet-preview">Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="oldTestRunId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="3" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="oldTestRunId"> Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file, configuration and app components from the existing test run. You can override the configuration values for new test run in the request body. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateTestRun with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {};

Response response = client.CreateOrUpdateTestRun("<testRunId>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateTestRun with all parameters and request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {
    passFailCriteria = new {
        passFailMetrics = new {
            key = new {
                clientMetric = "response_time_ms",
                aggregate = "count",
                condition = "<condition>",
                requestName = "<requestName>",
                value = 123.45d,
                action = "continue",
            },
        },
    },
    secrets = new {
        key = new {
            value = "<value>",
            type = "AKV_SECRET_URI",
        },
    },
    certificate = new {
        value = "<value>",
        type = "AKV_CERT_URI",
        name = "<name>",
    },
    environmentVariables = new {
        key = "<String>",
    },
    loadTestConfiguration = new {
        engineInstances = 1234,
        splitAllCSVs = true,
        quickStartTest = true,
        optionalLoadTestConfig = new {
            endpointUrl = "<endpointUrl>",
            virtualUsers = 1234,
            rampUpTime = 1234,
            duration = 1234,
        },
    },
    displayName = "<displayName>",
    testId = "<testId>",
    description = "<description>",
};

Response response = client.CreateOrUpdateTestRun("<testRunId>", RequestContent.Create(data), "<oldTestRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateTestRunAsync (string testRunId, Azure.Core.RequestContent content, string oldTestRunId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateTestRunAsync(string testRunId, class Azure.Core.RequestContent content, string oldTestRunId, class Azure.RequestContext context) cil managed" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.CreateOrUpdateTestRunAsync(System.String,Azure.Core.RequestContent,System.String,Azure.RequestContext)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateTestRunAsync (testRunId As String, content As RequestContent, Optional oldTestRunId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateTestRunAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateTestRunAsync : string * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.CreateOrUpdateTestRunAsync (testRunId, content, oldTestRunId, context)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="azure-dotnet-preview">System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="oldTestRunId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="3" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="oldTestRunId"> Existing test run identifier that should be rerun, if this is provided, the test will run with the JMX file, configuration and app components from the existing test run. You can override the configuration values for new test run in the request body. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Create and start a new test run with the given name. </summary>
        <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        <remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code>

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateTestRunAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {};

Response response = await client.CreateOrUpdateTestRunAsync("<testRunId>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateOrUpdateTestRunAsync with all parameters and request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {
    passFailCriteria = new {
        passFailMetrics = new {
            key = new {
                clientMetric = "response_time_ms",
                aggregate = "count",
                condition = "<condition>",
                requestName = "<requestName>",
                value = 123.45d,
                action = "continue",
            },
        },
    },
    secrets = new {
        key = new {
            value = "<value>",
            type = "AKV_SECRET_URI",
        },
    },
    certificate = new {
        value = "<value>",
        type = "AKV_CERT_URI",
        name = "<name>",
    },
    environmentVariables = new {
        key = "<String>",
    },
    loadTestConfiguration = new {
        engineInstances = 1234,
        splitAllCSVs = true,
        quickStartTest = true,
        optionalLoadTestConfig = new {
            endpointUrl = "<endpointUrl>",
            virtualUsers = 1234,
            rampUpTime = 1234,
            duration = 1234,
        },
    },
    displayName = "<displayName>",
    testId = "<testId>",
    description = "<description>",
};

Response response = await client.CreateOrUpdateTestRunAsync("<testRunId>", RequestContent.Create(data), "<oldTestRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteTestProfileRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteTestProfileRun (string testProfileRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteTestProfileRun(string testProfileRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.DeleteTestProfileRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTestProfileRun (testProfileRunId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteTestProfileRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteTestProfileRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.DeleteTestProfileRun (testProfileRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete an existing load test profile run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteTestProfileRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteTestProfileRunAsync (string testProfileRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteTestProfileRunAsync(string testProfileRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.DeleteTestProfileRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTestProfileRunAsync (testProfileRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteTestProfileRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteTestProfileRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.DeleteTestProfileRunAsync (testProfileRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete an existing load test profile run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteTestRun (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteTestRun(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.DeleteTestRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTestRun (testRunId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteTestRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteTestRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.DeleteTestRun (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete an existing load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call DeleteTestRun.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.DeleteTestRun("<testRunId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTestRun with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.DeleteTestRun("<testRunId>");

Console.WriteLine(response.Status);
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteTestRunAsync (string testRunId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteTestRunAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.DeleteTestRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteTestRunAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.DeleteTestRunAsync (testRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Delete an existing load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call DeleteTestRunAsync.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.DeleteTestRunAsync("<testRunId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTestRunAsync with all parameters.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.DeleteTestRunAsync("<testRunId>");

Console.WriteLine(response.Status);
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetAppComponents">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetAppComponents (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetAppComponents(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetAppComponents(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAppComponents (testRunId As String, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetAppComponents : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetAppComponents : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetAppComponents (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetAppComponents (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAppComponents (testRunId As String, context As RequestContext) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get associated app component (collection of azure resources) for the given test
            run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetAppComponents(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call GetAppComponents and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetAppComponents("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").ToString());
]]></code>
This sample shows how to call GetAppComponents with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetAppComponents("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceGroup").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("subscriptionId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetAppComponents">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.TestRunAppComponents&gt; GetAppComponents (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestRunAppComponents&gt; GetAppComponents(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetAppComponents(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAppComponents (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of TestRunAppComponents)" />
      <MemberSignature Language="F#" Value="abstract member GetAppComponents : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestRunAppComponents&gt;&#xA;override this.GetAppComponents : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestRunAppComponents&gt;" Usage="loadTestRunClient.GetAppComponents (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.TestRunAppComponents&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Get associated app component (collection of azure resources) for the given test
            run.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetAppComponentsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetAppComponentsAsync (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetAppComponentsAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetAppComponentsAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAppComponentsAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetAppComponentsAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetAppComponentsAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetAppComponentsAsync (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetAppComponentsAsync (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAppComponentsAsync (testRunId As String, context As RequestContext) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get associated app component (collection of azure resources) for the given test
            run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetAppComponentsAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRunAppComponents</c>:
<code>{
  components: Dictionary&lt;string, AppComponent&gt;, # Required. Azure resource collection { resource id (fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}) : resource object } 
  testRunId: string, # Optional. Test run identifier
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call GetAppComponentsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetAppComponentsAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").ToString());
]]></code>
This sample shows how to call GetAppComponentsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetAppComponentsAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("resourceGroup").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("subscriptionId").ToString());
Console.WriteLine(result.GetProperty("components").GetProperty("<key>").GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetAppComponentsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunAppComponents&gt;&gt; GetAppComponentsAsync (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestRunAppComponents&gt;&gt; GetAppComponentsAsync(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetAppComponentsAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAppComponentsAsync (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of TestRunAppComponents))" />
      <MemberSignature Language="F#" Value="abstract member GetAppComponentsAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunAppComponents&gt;&gt;&#xA;override this.GetAppComponentsAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunAppComponents&gt;&gt;" Usage="loadTestRunClient.GetAppComponentsAsync (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunAppComponents&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Get associated app component (collection of azure resources) for the given test
            run.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDefinitions">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetMetricDefinitions (string testRunId, string metricNamespace, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetMetricDefinitions(string testRunId, string metricNamespace, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDefinitions(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDefinitions (testRunId As String, metricNamespace As String, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDefinitions : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetMetricDefinitions : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetMetricDefinitions (testRunId, metricNamespace, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetMetricDefinitions (string testRunId, string metricNamespace, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDefinitions (testRunId As String, metricNamespace As String, context As RequestContext) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the metric definitions for a load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDefinitions(System.String,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>MetricDefinitionCollection</c>:
<code>{
  value: [
    {
      dimensions: [
        {
          description: string, # Optional. The description
          name: string, # Optional. The name
        }
      ], # Optional. List of dimensions
      description: string, # Optional. The metric description
      name: string, # Optional. The metric name
      namespace: string, # Optional. The namespace the metric belongs to.
      primaryAggregationType: "Average" | "Count" | "None" | "Total" | "Percentile90" | "Percentile95" | "Percentile99", # Optional. The primary aggregation type value defining how to use the values for display.
      supportedAggregationTypes: [string], # Optional. The collection of what all aggregation types are supported.
      unit: "NotSpecified" | "Percent" | "Count" | "Seconds" | "Milliseconds" | "Bytes" | "BytesPerSecond" | "CountPerSecond", # Optional. The unit of the metric.
      metricAvailabilities: [
        {
          timeGrain: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H", # Optional. The time grain specifies the aggregation interval for the metric. Expressed as a duration 'PT1M', 'PT1H', etc.
        }
      ], # Optional. Metric availability specifies the time grain (aggregation interval or frequency).
    }
  ], # Required. the values for the metric definitions.
}
</code></remarks>
        <example>
This sample shows how to call GetMetricDefinitions and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetMetricDefinitions("<testRunId>", "<metricNamespace>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].ToString());
]]></code>
This sample shows how to call GetMetricDefinitions with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetMetricDefinitions("<testRunId>", "<metricNamespace>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("namespace").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("primaryAggregationType").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("supportedAggregationTypes")[0].ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("metricAvailabilities")[0].GetProperty("timeGrain").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="metricNamespace" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDefinitions">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.MetricDefinitions&gt; GetMetricDefinitions (string testRunId, string metricNamespace, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.MetricDefinitions&gt; GetMetricDefinitions(string testRunId, string metricNamespace, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDefinitions(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDefinitions (testRunId As String, metricNamespace As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of MetricDefinitions)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDefinitions : string * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.MetricDefinitions&gt;&#xA;override this.GetMetricDefinitions : string * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.MetricDefinitions&gt;" Usage="loadTestRunClient.GetMetricDefinitions (testRunId, metricNamespace, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.MetricDefinitions&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricNamespace" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List the metric definitions for a load test run. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="metricNamespace" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDefinitionsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetMetricDefinitionsAsync (string testRunId, string metricNamespace, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetMetricDefinitionsAsync(string testRunId, string metricNamespace, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDefinitionsAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDefinitionsAsync (testRunId As String, metricNamespace As String, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDefinitionsAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetMetricDefinitionsAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetMetricDefinitionsAsync (testRunId, metricNamespace, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetMetricDefinitionsAsync (string testRunId, string metricNamespace, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDefinitionsAsync (testRunId As String, metricNamespace As String, context As RequestContext) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the metric definitions for a load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDefinitionsAsync(System.String,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>MetricDefinitionCollection</c>:
<code>{
  value: [
    {
      dimensions: [
        {
          description: string, # Optional. The description
          name: string, # Optional. The name
        }
      ], # Optional. List of dimensions
      description: string, # Optional. The metric description
      name: string, # Optional. The metric name
      namespace: string, # Optional. The namespace the metric belongs to.
      primaryAggregationType: "Average" | "Count" | "None" | "Total" | "Percentile90" | "Percentile95" | "Percentile99", # Optional. The primary aggregation type value defining how to use the values for display.
      supportedAggregationTypes: [string], # Optional. The collection of what all aggregation types are supported.
      unit: "NotSpecified" | "Percent" | "Count" | "Seconds" | "Milliseconds" | "Bytes" | "BytesPerSecond" | "CountPerSecond", # Optional. The unit of the metric.
      metricAvailabilities: [
        {
          timeGrain: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H", # Optional. The time grain specifies the aggregation interval for the metric. Expressed as a duration 'PT1M', 'PT1H', etc.
        }
      ], # Optional. Metric availability specifies the time grain (aggregation interval or frequency).
    }
  ], # Required. the values for the metric definitions.
}
</code></remarks>
        <example>
This sample shows how to call GetMetricDefinitionsAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetMetricDefinitionsAsync("<testRunId>", "<metricNamespace>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].ToString());
]]></code>
This sample shows how to call GetMetricDefinitionsAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetMetricDefinitionsAsync("<testRunId>", "<metricNamespace>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("namespace").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("primaryAggregationType").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("supportedAggregationTypes")[0].ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("metricAvailabilities")[0].GetProperty("timeGrain").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="metricNamespace" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDefinitionsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.MetricDefinitions&gt;&gt; GetMetricDefinitionsAsync (string testRunId, string metricNamespace, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.MetricDefinitions&gt;&gt; GetMetricDefinitionsAsync(string testRunId, string metricNamespace, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDefinitionsAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDefinitionsAsync (testRunId As String, metricNamespace As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of MetricDefinitions))" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDefinitionsAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.MetricDefinitions&gt;&gt;&#xA;override this.GetMetricDefinitionsAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.MetricDefinitions&gt;&gt;" Usage="loadTestRunClient.GetMetricDefinitionsAsync (testRunId, metricNamespace, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.MetricDefinitions&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricNamespace" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List the metric definitions for a load test run. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="metricNamespace" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDimensionValues">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;string&gt; GetMetricDimensionValues (string testRunId, string name, string metricname, string metricNamespace, string timespan, Azure.Developer.LoadTesting.TimeGrain? interval = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;string&gt; GetMetricDimensionValues(string testRunId, string name, string metricname, string metricNamespace, string timespan, valuetype System.Nullable`1&lt;valuetype Azure.Developer.LoadTesting.TimeGrain&gt; interval, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDimensionValues(System.String,System.String,System.String,System.String,System.String,System.Nullable{Azure.Developer.LoadTesting.TimeGrain},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDimensionValues (testRunId As String, name As String, metricname As String, metricNamespace As String, timespan As String, Optional interval As Nullable(Of TimeGrain) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of String)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDimensionValues : string * string * string * string * string * Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;string&gt;&#xA;override this.GetMetricDimensionValues : string * string * string * string * string * Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;string&gt;" Usage="loadTestRunClient.GetMetricDimensionValues (testRunId, name, metricname, metricNamespace, timespan, interval, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricname" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricNamespace" Type="System.String" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="timespan" Type="System.String" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="interval" Type="System.Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt;" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="6" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="name"> Dimension name. </param>
        <param name="metricname"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List the dimension values for the given metric dimension name. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="name" />, <paramref name="metricname" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDimensionValues">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetMetricDimensionValues (string testRunId, string name, string metricName, string metricNamespace, string timeInterval, string interval = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetMetricDimensionValues(string testRunId, string name, string metricName, string metricNamespace, string timeInterval, string interval, class Azure.RequestContext context) cil managed" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDimensionValues(System.String,System.String,System.String,System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDimensionValues (testRunId As String, name As String, metricName As String, metricNamespace As String, timeInterval As String, Optional interval As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDimensionValues : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetMetricDimensionValues : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetricDimensionValues (testRunId, name, metricName, metricNamespace, timeInterval, interval, context)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetMetricDimensionValues (string testRunId, string name, string metricname, string metricNamespace, string timespan, string interval, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetMetricDimensionValues(string testRunId, string name, string metricname, string metricNamespace, string timespan, string interval, class Azure.RequestContext context) cil managed" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDimensionValues (testRunId As String, name As String, metricname As String, metricNamespace As String, timespan As String, interval As String, context As RequestContext) As Pageable(Of BinaryData)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDimensionValues : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetMetricDimensionValues : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetricDimensionValues (testRunId, name, metricname, metricNamespace, timespan, interval, context)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" />
        <Parameter Name="name" Type="System.String" Index="1" />
        <Parameter Name="metricName" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet" />
        <Parameter Name="metricname" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricNamespace" Type="System.String" Index="3" />
        <Parameter Name="timeInterval" Type="System.String" Index="4" FrameworkAlternate="azure-dotnet" />
        <Parameter Name="timespan" Type="System.String" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="interval" Type="System.String" Index="5" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="6" />
      </Parameters>
      <Docs>
        <param name="metricName"> Metric name. </param>
        <param name="timeInterval"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="name"> Dimension name. </param>
        <param name="metricname"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the dimension values for the given metric dimension name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDimensionValues(System.String,System.String,System.String,System.String,System.String,System.Nullable{Azure.Developer.LoadTesting.TimeGrain},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetMetricDimensionValues and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

foreach (BinaryData item in client.GetMetricDimensionValues("<testRunId>", "<name>", "<metricName>", "<metricNamespace>", "<timeInterval>"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetMetricDimensionValues with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

foreach (BinaryData item in client.GetMetricDimensionValues("<testRunId>", "<name>", "<metricName>", "<metricNamespace>", "<timeInterval>", interval: "PT5S"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="name" />, <paramref name="metricname" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDimensionValuesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;string&gt; GetMetricDimensionValuesAsync (string testRunId, string name, string metricname, string metricNamespace, string timespan, Azure.Developer.LoadTesting.TimeGrain? interval = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;string&gt; GetMetricDimensionValuesAsync(string testRunId, string name, string metricname, string metricNamespace, string timespan, valuetype System.Nullable`1&lt;valuetype Azure.Developer.LoadTesting.TimeGrain&gt; interval, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDimensionValuesAsync(System.String,System.String,System.String,System.String,System.String,System.Nullable{Azure.Developer.LoadTesting.TimeGrain},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDimensionValuesAsync (testRunId As String, name As String, metricname As String, metricNamespace As String, timespan As String, Optional interval As Nullable(Of TimeGrain) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of String)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDimensionValuesAsync : string * string * string * string * string * Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;string&gt;&#xA;override this.GetMetricDimensionValuesAsync : string * string * string * string * string * Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;string&gt;" Usage="loadTestRunClient.GetMetricDimensionValuesAsync (testRunId, name, metricname, metricNamespace, timespan, interval, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricname" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricNamespace" Type="System.String" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="timespan" Type="System.String" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="interval" Type="System.Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt;" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="6" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="name"> Dimension name. </param>
        <param name="metricname"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List the dimension values for the given metric dimension name. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="name" />, <paramref name="metricname" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricDimensionValuesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetMetricDimensionValuesAsync (string testRunId, string name, string metricName, string metricNamespace, string timeInterval, string interval = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetMetricDimensionValuesAsync(string testRunId, string name, string metricName, string metricNamespace, string timeInterval, string interval, class Azure.RequestContext context) cil managed" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDimensionValuesAsync(System.String,System.String,System.String,System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDimensionValuesAsync (testRunId As String, name As String, metricName As String, metricNamespace As String, timeInterval As String, Optional interval As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDimensionValuesAsync : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetMetricDimensionValuesAsync : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetricDimensionValuesAsync (testRunId, name, metricName, metricNamespace, timeInterval, interval, context)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetMetricDimensionValuesAsync (string testRunId, string name, string metricname, string metricNamespace, string timespan, string interval, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetMetricDimensionValuesAsync(string testRunId, string name, string metricname, string metricNamespace, string timespan, string interval, class Azure.RequestContext context) cil managed" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricDimensionValuesAsync (testRunId As String, name As String, metricname As String, metricNamespace As String, timespan As String, interval As String, context As RequestContext) As AsyncPageable(Of BinaryData)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="F#" Value="abstract member GetMetricDimensionValuesAsync : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetMetricDimensionValuesAsync : string * string * string * string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetricDimensionValuesAsync (testRunId, name, metricname, metricNamespace, timespan, interval, context)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" />
        <Parameter Name="name" Type="System.String" Index="1" />
        <Parameter Name="metricName" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet" />
        <Parameter Name="metricname" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricNamespace" Type="System.String" Index="3" />
        <Parameter Name="timeInterval" Type="System.String" Index="4" FrameworkAlternate="azure-dotnet" />
        <Parameter Name="timespan" Type="System.String" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="interval" Type="System.String" Index="5" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="6" />
      </Parameters>
      <Docs>
        <param name="metricName"> Metric name. </param>
        <param name="timeInterval"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="name"> Dimension name. </param>
        <param name="metricname"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the dimension values for the given metric dimension name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricDimensionValuesAsync(System.String,System.String,System.String,System.String,System.String,System.Nullable{Azure.Developer.LoadTesting.TimeGrain},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <example>
This sample shows how to call GetMetricDimensionValuesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

await foreach (BinaryData item in client.GetMetricDimensionValuesAsync("<testRunId>", "<name>", "<metricName>", "<metricNamespace>", "<timeInterval>"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetMetricDimensionValuesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

await foreach (BinaryData item in client.GetMetricDimensionValuesAsync("<testRunId>", "<name>", "<metricName>", "<metricNamespace>", "<timeInterval>", interval: "PT5S"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="name" />, <paramref name="metricname" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="name" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricNamespaces">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetMetricNamespaces (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetMetricNamespaces(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricNamespaces(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricNamespaces (testRunId As String, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetMetricNamespaces : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetMetricNamespaces : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetMetricNamespaces (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetMetricNamespaces (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricNamespaces (testRunId As String, context As RequestContext) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the metric namespaces for a load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricNamespaces(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>MetricNamespaceCollection</c>:
<code>{
  value: [
    {
      description: string, # Optional. The namespace description.
      name: string, # Optional. The metric namespace name.
    }
  ], # Required. The values for the metric namespaces.
}
</code></remarks>
        <example>
This sample shows how to call GetMetricNamespaces and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetMetricNamespaces("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].ToString());
]]></code>
This sample shows how to call GetMetricNamespaces with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetMetricNamespaces("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricNamespaces">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.MetricNamespaces&gt; GetMetricNamespaces (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.MetricNamespaces&gt; GetMetricNamespaces(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricNamespaces(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricNamespaces (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of MetricNamespaces)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricNamespaces : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.MetricNamespaces&gt;&#xA;override this.GetMetricNamespaces : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.MetricNamespaces&gt;" Usage="loadTestRunClient.GetMetricNamespaces (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.MetricNamespaces&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List the metric namespaces for a load test run. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricNamespacesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetMetricNamespacesAsync (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetMetricNamespacesAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricNamespacesAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricNamespacesAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetMetricNamespacesAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetMetricNamespacesAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetMetricNamespacesAsync (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetMetricNamespacesAsync (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricNamespacesAsync (testRunId As String, context As RequestContext) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List the metric namespaces for a load test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricNamespacesAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>MetricNamespaceCollection</c>:
<code>{
  value: [
    {
      description: string, # Optional. The namespace description.
      name: string, # Optional. The metric namespace name.
    }
  ], # Required. The values for the metric namespaces.
}
</code></remarks>
        <example>
This sample shows how to call GetMetricNamespacesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetMetricNamespacesAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].ToString());
]]></code>
This sample shows how to call GetMetricNamespacesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetMetricNamespacesAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricNamespacesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.MetricNamespaces&gt;&gt; GetMetricNamespacesAsync (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.MetricNamespaces&gt;&gt; GetMetricNamespacesAsync(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricNamespacesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricNamespacesAsync (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of MetricNamespaces))" />
      <MemberSignature Language="F#" Value="abstract member GetMetricNamespacesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.MetricNamespaces&gt;&gt;&#xA;override this.GetMetricNamespacesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.MetricNamespaces&gt;&gt;" Usage="loadTestRunClient.GetMetricNamespacesAsync (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.MetricNamespaces&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List the metric namespaces for a load test run. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetrics">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetMetrics (string testRunId, string metricName, string metricNamespace, string timespan, Azure.Core.RequestContent content = default, string aggregation = default, string interval = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetMetrics(string testRunId, string metricName, string metricNamespace, string timespan, class Azure.Core.RequestContent content, string aggregation, string interval, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetrics(System.String,System.String,System.String,System.String,Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetrics (testRunId As String, metricName As String, metricNamespace As String, timespan As String, Optional content As RequestContent = Nothing, Optional aggregation As String = Nothing, Optional interval As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetMetrics : string * string * string * string * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetMetrics : string * string * string * string * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetrics (testRunId, metricName, metricNamespace, timespan, content, aggregation, interval, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetMetrics (string testRunId, string metricName, string metricNamespace, string timespan, Azure.Core.RequestContent content, string aggregation, string interval, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetrics (testRunId As String, metricName As String, metricNamespace As String, timespan As String, content As RequestContent, aggregation As String, interval As String, context As RequestContext) As Pageable(Of BinaryData)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="metricName" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="timespan" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="aggregation" Type="System.String" />
        <Parameter Name="interval" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="metricName"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="aggregation"> The aggregation. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> List the metric values for a load test run. </summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>
Below is the JSON schema for the request payload and one item in the pageable response.

Request Body:

Schema for <c>MetricRequestPayload</c>:
<code>{
  filters: [
    {
      name: string, # Optional. The dimension name
      values: [string], # Optional. The dimension values. Maximum values can be 20.
    }
  ], # Optional. Get metrics for specific dimension values. Example: Metric contains dimension like SamplerName, Error. To retrieve all the time series data where SamplerName is equals to HTTPRequest1 or HTTPRequest2, the DimensionFilter value will be {"SamplerName", ["HTTPRequest1", "HTTPRequest2"}
}
</code>

Response Body:

Schema for <c>MetricsValue</c>:
<code>{
  data: [
    {
      timestamp: string, # Optional. The timestamp for the metric value in ISO 8601 format.
      value: number, # Optional. The metric value.
    }
  ], # Optional. An array of data points representing the metric values.
  dimensionValues: [
    {
      name: string, # Optional. The name of the dimension.
      value: string, # Optional. The value of the dimension.
    }
  ], # Optional. The dimension values 
}
</code></remarks>
        <example>
This sample shows how to call GetMetrics with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {};

foreach (var data in client.GetMetrics("<testRunId>", "<metricname>", "<metricNamespace>", "<timespan>", RequestContent.Create(data)))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetMetrics with all parameters and request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {
    filters = new[] {
        new {
            name = "<name>",
            values = new[] {
                "<String>"
            },
        }
    },
};

foreach (var data in client.GetMetrics("<testRunId>", "<metricname>", "<metricNamespace>", "<timespan>", RequestContent.Create(data), "<aggregation>", "<interval>"))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("data")[0].GetProperty("timestamp").ToString());
    Console.WriteLine(result.GetProperty("data")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("dimensionValues")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("dimensionValues")[0].GetProperty("value").ToString());
}
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="metricName" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetrics">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Developer.LoadTesting.TimeSeriesElement&gt; GetMetrics (string testRunId, string metricname, string metricNamespace, string timespan, Azure.Developer.LoadTesting.MetricsFilters body = default, string aggregation = default, Azure.Developer.LoadTesting.TimeGrain? interval = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Developer.LoadTesting.TimeSeriesElement&gt; GetMetrics(string testRunId, string metricname, string metricNamespace, string timespan, class Azure.Developer.LoadTesting.MetricsFilters body, string aggregation, valuetype System.Nullable`1&lt;valuetype Azure.Developer.LoadTesting.TimeGrain&gt; interval, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetrics(System.String,System.String,System.String,System.String,Azure.Developer.LoadTesting.MetricsFilters,System.String,System.Nullable{Azure.Developer.LoadTesting.TimeGrain},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetrics (testRunId As String, metricname As String, metricNamespace As String, timespan As String, Optional body As MetricsFilters = Nothing, Optional aggregation As String = Nothing, Optional interval As Nullable(Of TimeGrain) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of TimeSeriesElement)" />
      <MemberSignature Language="F#" Value="abstract member GetMetrics : string * string * string * string * Azure.Developer.LoadTesting.MetricsFilters * string * Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Developer.LoadTesting.TimeSeriesElement&gt;&#xA;override this.GetMetrics : string * string * string * string * Azure.Developer.LoadTesting.MetricsFilters * string * Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Developer.LoadTesting.TimeSeriesElement&gt;" Usage="loadTestRunClient.GetMetrics (testRunId, metricname, metricNamespace, timespan, body, aggregation, interval, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Developer.LoadTesting.TimeSeriesElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricname" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricNamespace" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="timespan" Type="System.String" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="body" Type="Azure.Developer.LoadTesting.MetricsFilters" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="aggregation" Type="System.String" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="interval" Type="System.Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt;" Index="6" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="7" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="metricname"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="body"> Metric dimension filter. </param>
        <param name="aggregation"> The aggregation. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List the metric values for a load test run. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="metricname" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetMetricsAsync (string testRunId, string metricName, string metricNamespace, string timespan, Azure.Core.RequestContent content = default, string aggregation = default, string interval = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetMetricsAsync(string testRunId, string metricName, string metricNamespace, string timespan, class Azure.Core.RequestContent content, string aggregation, string interval, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricsAsync(System.String,System.String,System.String,System.String,Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricsAsync (testRunId As String, metricName As String, metricNamespace As String, timespan As String, Optional content As RequestContent = Nothing, Optional aggregation As String = Nothing, Optional interval As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetMetricsAsync : string * string * string * string * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetMetricsAsync : string * string * string * string * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetMetricsAsync (testRunId, metricName, metricNamespace, timespan, content, aggregation, interval, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetMetricsAsync (string testRunId, string metricName, string metricNamespace, string timespan, Azure.Core.RequestContent content, string aggregation, string interval, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricsAsync (testRunId As String, metricName As String, metricNamespace As String, timespan As String, content As RequestContent, aggregation As String, interval As String, context As RequestContext) As AsyncPageable(Of BinaryData)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="metricName" Type="System.String" />
        <Parameter Name="metricNamespace" Type="System.String" />
        <Parameter Name="timespan" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="aggregation" Type="System.String" />
        <Parameter Name="interval" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="metricName"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        <param name="aggregation"> The aggregation. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: "PT5S" | "PT10S" | "PT1M" | "PT5M" | "PT1H". </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> List the metric values for a load test run. </summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>
Below is the JSON schema for the request payload and one item in the pageable response.

Request Body:

Schema for <c>MetricRequestPayload</c>:
<code>{
  filters: [
    {
      name: string, # Optional. The dimension name
      values: [string], # Optional. The dimension values. Maximum values can be 20.
    }
  ], # Optional. Get metrics for specific dimension values. Example: Metric contains dimension like SamplerName, Error. To retrieve all the time series data where SamplerName is equals to HTTPRequest1 or HTTPRequest2, the DimensionFilter value will be {"SamplerName", ["HTTPRequest1", "HTTPRequest2"}
}
</code>

Response Body:

Schema for <c>MetricsValue</c>:
<code>{
  data: [
    {
      timestamp: string, # Optional. The timestamp for the metric value in ISO 8601 format.
      value: number, # Optional. The metric value.
    }
  ], # Optional. An array of data points representing the metric values.
  dimensionValues: [
    {
      name: string, # Optional. The name of the dimension.
      value: string, # Optional. The value of the dimension.
    }
  ], # Optional. The dimension values 
}
</code></remarks>
        <example>
This sample shows how to call GetMetricsAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {};

await foreach (var data in client.GetMetricsAsync("<testRunId>", "<metricname>", "<metricNamespace>", "<timespan>", RequestContent.Create(data)))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetMetricsAsync with all parameters and request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new LoadTestRunClient(endpoint, credential);

var data = new {
    filters = new[] {
        new {
            name = "<name>",
            values = new[] {
                "<String>"
            },
        }
    },
};

await foreach (var data in client.GetMetricsAsync("<testRunId>", "<metricname>", "<metricNamespace>", "<timespan>", RequestContent.Create(data), "<aggregation>", "<interval>"))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("data")[0].GetProperty("timestamp").ToString());
    Console.WriteLine(result.GetProperty("data")[0].GetProperty("value").ToString());
    Console.WriteLine(result.GetProperty("dimensionValues")[0].GetProperty("name").ToString());
    Console.WriteLine(result.GetProperty("dimensionValues")[0].GetProperty("value").ToString());
}
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="metricName" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetricsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.TimeSeriesElement&gt; GetMetricsAsync (string testRunId, string metricname, string metricNamespace, string timespan, Azure.Developer.LoadTesting.MetricsFilters body = default, string aggregation = default, Azure.Developer.LoadTesting.TimeGrain? interval = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Developer.LoadTesting.TimeSeriesElement&gt; GetMetricsAsync(string testRunId, string metricname, string metricNamespace, string timespan, class Azure.Developer.LoadTesting.MetricsFilters body, string aggregation, valuetype System.Nullable`1&lt;valuetype Azure.Developer.LoadTesting.TimeGrain&gt; interval, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetMetricsAsync(System.String,System.String,System.String,System.String,Azure.Developer.LoadTesting.MetricsFilters,System.String,System.Nullable{Azure.Developer.LoadTesting.TimeGrain},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetricsAsync (testRunId As String, metricname As String, metricNamespace As String, timespan As String, Optional body As MetricsFilters = Nothing, Optional aggregation As String = Nothing, Optional interval As Nullable(Of TimeGrain) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of TimeSeriesElement)" />
      <MemberSignature Language="F#" Value="abstract member GetMetricsAsync : string * string * string * string * Azure.Developer.LoadTesting.MetricsFilters * string * Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.TimeSeriesElement&gt;&#xA;override this.GetMetricsAsync : string * string * string * string * Azure.Developer.LoadTesting.MetricsFilters * string * Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.TimeSeriesElement&gt;" Usage="loadTestRunClient.GetMetricsAsync (testRunId, metricname, metricNamespace, timespan, body, aggregation, interval, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.TimeSeriesElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricname" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="metricNamespace" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="timespan" Type="System.String" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="body" Type="Azure.Developer.LoadTesting.MetricsFilters" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="aggregation" Type="System.String" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="interval" Type="System.Nullable&lt;Azure.Developer.LoadTesting.TimeGrain&gt;" Index="6" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="7" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="metricname"> Metric name. </param>
        <param name="metricNamespace"> Metric namespace to query metric definitions for. </param>
        <param name="timespan"> The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'. </param>
        <param name="body"> Metric dimension filter. </param>
        <param name="aggregation"> The aggregation. </param>
        <param name="interval"> The interval (i.e. timegrain) of the query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List the metric values for a load test run. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" />, <paramref name="metricname" />, <paramref name="metricNamespace" /> or <paramref name="timespan" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetServerMetricsConfig">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetServerMetricsConfig (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetServerMetricsConfig(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetServerMetricsConfig(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServerMetricsConfig (testRunId As String, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetServerMetricsConfig : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetServerMetricsConfig : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetServerMetricsConfig (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetServerMetricsConfig (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServerMetricsConfig (testRunId As String, context As RequestContext) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get associated server metrics configuration for the given test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetServerMetricsConfig(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call GetServerMetricsConfig and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetServerMetricsConfig("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetServerMetricsConfig with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetServerMetricsConfig("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("metricNamespace").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("displayDescription").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("aggregation").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetServerMetricsConfig">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt; GetServerMetricsConfig (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt; GetServerMetricsConfig(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetServerMetricsConfig(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServerMetricsConfig (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of TestRunServerMetricsConfiguration)" />
      <MemberSignature Language="F#" Value="abstract member GetServerMetricsConfig : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt;&#xA;override this.GetServerMetricsConfig : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt;" Usage="loadTestRunClient.GetServerMetricsConfig (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get associated server metrics configuration for the given test run. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetServerMetricsConfigAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetServerMetricsConfigAsync (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetServerMetricsConfigAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetServerMetricsConfigAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServerMetricsConfigAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetServerMetricsConfigAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetServerMetricsConfigAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetServerMetricsConfigAsync (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetServerMetricsConfigAsync (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServerMetricsConfigAsync (testRunId As String, context As RequestContext) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get associated server metrics configuration for the given test run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetServerMetricsConfigAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRunServerMetricConfig</c>:
<code>{
  testRunId: string, # Optional. Test run identifier
  metrics: Dictionary&lt;string, ResourceMetric&gt;, # Optional. Azure resource metrics collection {metric id : metrics object} (Refer : https://docs.microsoft.com/en-us/rest/api/monitor/metric-definitions/list#metricdefinition for metric id).
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call GetServerMetricsConfigAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetServerMetricsConfigAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetServerMetricsConfigAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetServerMetricsConfigAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceId").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("metricNamespace").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("displayDescription").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("aggregation").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("unit").ToString());
Console.WriteLine(result.GetProperty("metrics").GetProperty("<key>").GetProperty("resourceType").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetServerMetricsConfigAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt;&gt; GetServerMetricsConfigAsync (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt;&gt; GetServerMetricsConfigAsync(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetServerMetricsConfigAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetServerMetricsConfigAsync (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of TestRunServerMetricsConfiguration))" />
      <MemberSignature Language="F#" Value="abstract member GetServerMetricsConfigAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt;&gt;&#xA;override this.GetServerMetricsConfigAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt;&gt;" Usage="loadTestRunClient.GetServerMetricsConfigAsync (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunServerMetricsConfiguration&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId">
            Unique name for the load test run, must contain only lower-case alphabetic,
            numeric, underscore or hyphen characters.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get associated server metrics configuration for the given test run. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestProfileRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTestProfileRun (string testProfileRunId, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTestProfileRun(string testProfileRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestProfileRun (testProfileRunId As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTestProfileRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTestProfileRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetTestProfileRun (testProfileRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test profile run details.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRun(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestProfileRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt; GetTestProfileRun (string testProfileRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestProfileRun&gt; GetTestProfileRun(string testProfileRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRun(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestProfileRun (testProfileRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of TestProfileRun)" />
      <MemberSignature Language="F#" Value="abstract member GetTestProfileRun : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&#xA;override this.GetTestProfileRun : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;" Usage="loadTestRunClient.GetTestProfileRun (testProfileRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get test profile run details. </summary>
        <returns>To be added.</returns>
        <remarks> Get test profile run details by test profile run Id. </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestProfileRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTestProfileRunAsync (string testProfileRunId, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTestProfileRunAsync(string testProfileRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestProfileRunAsync (testProfileRunId As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTestProfileRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTestProfileRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetTestProfileRunAsync (testProfileRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test profile run details.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRunAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestProfileRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&gt; GetTestProfileRunAsync (string testProfileRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestProfileRun&gt;&gt; GetTestProfileRunAsync(string testProfileRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRunAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestProfileRunAsync (testProfileRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of TestProfileRun))" />
      <MemberSignature Language="F#" Value="abstract member GetTestProfileRunAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&gt;&#xA;override this.GetTestProfileRunAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&gt;" Usage="loadTestRunClient.GetTestProfileRunAsync (testProfileRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get test profile run details. </summary>
        <returns>To be added.</returns>
        <remarks> Get test profile run details by test profile run Id. </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestProfileRuns">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetTestProfileRuns (DateTimeOffset? minStartDateTime, DateTimeOffset? maxStartDateTime, DateTimeOffset? minEndDateTime, DateTimeOffset? maxEndDateTime, DateTimeOffset? createdDateStartTime, DateTimeOffset? createdDateEndTime, System.Collections.Generic.IEnumerable&lt;string&gt; testProfileRunIds, System.Collections.Generic.IEnumerable&lt;string&gt; testProfileIds, System.Collections.Generic.IEnumerable&lt;string&gt; statuses, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetTestProfileRuns(valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; minStartDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; maxStartDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; minEndDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; maxEndDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; createdDateStartTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; createdDateEndTime, class System.Collections.Generic.IEnumerable`1&lt;string&gt; testProfileRunIds, class System.Collections.Generic.IEnumerable`1&lt;string&gt; testProfileIds, class System.Collections.Generic.IEnumerable`1&lt;string&gt; statuses, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRuns(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestProfileRuns (minStartDateTime As Nullable(Of DateTimeOffset), maxStartDateTime As Nullable(Of DateTimeOffset), minEndDateTime As Nullable(Of DateTimeOffset), maxEndDateTime As Nullable(Of DateTimeOffset), createdDateStartTime As Nullable(Of DateTimeOffset), createdDateEndTime As Nullable(Of DateTimeOffset), testProfileRunIds As IEnumerable(Of String), testProfileIds As IEnumerable(Of String), statuses As IEnumerable(Of String), context As RequestContext) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTestProfileRuns : Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetTestProfileRuns : Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetTestProfileRuns (minStartDateTime, maxStartDateTime, minEndDateTime, maxEndDateTime, createdDateStartTime, createdDateEndTime, testProfileRunIds, testProfileIds, statuses, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minStartDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="maxStartDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="minEndDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="maxEndDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="createdDateStartTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="createdDateEndTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileRunIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="6" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="7" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="statuses" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="8" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="9" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="minStartDateTime"> Minimum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="maxStartDateTime"> Maximum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="minEndDateTime"> Minimum End DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="maxEndDateTime"> Maximum End DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="createdDateStartTime"> Start DateTime(RFC 3339 literal format) of the created time range to filter test profile runs. </param>
        <param name="createdDateEndTime"> End DateTime(RFC 3339 literal format) of the created time range to filter test profile runs. </param>
        <param name="testProfileRunIds"> Comma separated list of IDs of the test profile runs to filter. </param>
        <param name="testProfileIds"> Comma separated IDs of the test profiles which should be associated with the test profile runs to fetch. </param>
        <param name="statuses"> Comma separated list of Statuses of the test profile runs to filter. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List test profile runs.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRuns(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestProfileRuns">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Developer.LoadTesting.TestProfileRun&gt; GetTestProfileRuns (DateTimeOffset? minStartDateTime = default, DateTimeOffset? maxStartDateTime = default, DateTimeOffset? minEndDateTime = default, DateTimeOffset? maxEndDateTime = default, DateTimeOffset? createdDateStartTime = default, DateTimeOffset? createdDateEndTime = default, System.Collections.Generic.IEnumerable&lt;string&gt; testProfileRunIds = default, System.Collections.Generic.IEnumerable&lt;string&gt; testProfileIds = default, System.Collections.Generic.IEnumerable&lt;string&gt; statuses = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Developer.LoadTesting.TestProfileRun&gt; GetTestProfileRuns(valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; minStartDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; maxStartDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; minEndDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; maxEndDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; createdDateStartTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; createdDateEndTime, class System.Collections.Generic.IEnumerable`1&lt;string&gt; testProfileRunIds, class System.Collections.Generic.IEnumerable`1&lt;string&gt; testProfileIds, class System.Collections.Generic.IEnumerable`1&lt;string&gt; statuses, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRuns(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestProfileRuns (Optional minStartDateTime As Nullable(Of DateTimeOffset) = Nothing, Optional maxStartDateTime As Nullable(Of DateTimeOffset) = Nothing, Optional minEndDateTime As Nullable(Of DateTimeOffset) = Nothing, Optional maxEndDateTime As Nullable(Of DateTimeOffset) = Nothing, Optional createdDateStartTime As Nullable(Of DateTimeOffset) = Nothing, Optional createdDateEndTime As Nullable(Of DateTimeOffset) = Nothing, Optional testProfileRunIds As IEnumerable(Of String) = Nothing, Optional testProfileIds As IEnumerable(Of String) = Nothing, Optional statuses As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of TestProfileRun)" />
      <MemberSignature Language="F#" Value="abstract member GetTestProfileRuns : Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&#xA;override this.GetTestProfileRuns : Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;" Usage="loadTestRunClient.GetTestProfileRuns (minStartDateTime, maxStartDateTime, minEndDateTime, maxEndDateTime, createdDateStartTime, createdDateEndTime, testProfileRunIds, testProfileIds, statuses, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minStartDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="maxStartDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="minEndDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="maxEndDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="createdDateStartTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="createdDateEndTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileRunIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="6" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="7" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="statuses" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="8" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="9" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="minStartDateTime"> Minimum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="maxStartDateTime"> Maximum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="minEndDateTime"> Minimum End DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="maxEndDateTime"> Maximum End DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="createdDateStartTime"> Start DateTime(RFC 3339 literal format) of the created time range to filter test profile runs. </param>
        <param name="createdDateEndTime"> End DateTime(RFC 3339 literal format) of the created time range to filter test profile runs. </param>
        <param name="testProfileRunIds"> Comma separated list of IDs of the test profile runs to filter. </param>
        <param name="testProfileIds"> Comma separated IDs of the test profiles which should be associated with the test profile runs to fetch. </param>
        <param name="statuses"> Comma separated list of Statuses of the test profile runs to filter. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List test profile runs. </summary>
        <returns>To be added.</returns>
        <remarks> Get all test profile runs for the given filters. </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTestProfileRunsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetTestProfileRunsAsync (DateTimeOffset? minStartDateTime, DateTimeOffset? maxStartDateTime, DateTimeOffset? minEndDateTime, DateTimeOffset? maxEndDateTime, DateTimeOffset? createdDateStartTime, DateTimeOffset? createdDateEndTime, System.Collections.Generic.IEnumerable&lt;string&gt; testProfileRunIds, System.Collections.Generic.IEnumerable&lt;string&gt; testProfileIds, System.Collections.Generic.IEnumerable&lt;string&gt; statuses, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetTestProfileRunsAsync(valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; minStartDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; maxStartDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; minEndDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; maxEndDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; createdDateStartTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; createdDateEndTime, class System.Collections.Generic.IEnumerable`1&lt;string&gt; testProfileRunIds, class System.Collections.Generic.IEnumerable`1&lt;string&gt; testProfileIds, class System.Collections.Generic.IEnumerable`1&lt;string&gt; statuses, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRunsAsync(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestProfileRunsAsync (minStartDateTime As Nullable(Of DateTimeOffset), maxStartDateTime As Nullable(Of DateTimeOffset), minEndDateTime As Nullable(Of DateTimeOffset), maxEndDateTime As Nullable(Of DateTimeOffset), createdDateStartTime As Nullable(Of DateTimeOffset), createdDateEndTime As Nullable(Of DateTimeOffset), testProfileRunIds As IEnumerable(Of String), testProfileIds As IEnumerable(Of String), statuses As IEnumerable(Of String), context As RequestContext) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetTestProfileRunsAsync : Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetTestProfileRunsAsync : Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * seq&lt;string&gt; * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetTestProfileRunsAsync (minStartDateTime, maxStartDateTime, minEndDateTime, maxEndDateTime, createdDateStartTime, createdDateEndTime, testProfileRunIds, testProfileIds, statuses, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minStartDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="maxStartDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="minEndDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="maxEndDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="createdDateStartTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="createdDateEndTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileRunIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="6" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="7" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="statuses" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="8" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="9" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="minStartDateTime"> Minimum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="maxStartDateTime"> Maximum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="minEndDateTime"> Minimum End DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="maxEndDateTime"> Maximum End DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="createdDateStartTime"> Start DateTime(RFC 3339 literal format) of the created time range to filter test profile runs. </param>
        <param name="createdDateEndTime"> End DateTime(RFC 3339 literal format) of the created time range to filter test profile runs. </param>
        <param name="testProfileRunIds"> Comma separated list of IDs of the test profile runs to filter. </param>
        <param name="testProfileIds"> Comma separated IDs of the test profiles which should be associated with the test profile runs to fetch. </param>
        <param name="statuses"> Comma separated list of Statuses of the test profile runs to filter. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] List test profile runs.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRunsAsync(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestProfileRunsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.TestProfileRun&gt; GetTestProfileRunsAsync (DateTimeOffset? minStartDateTime = default, DateTimeOffset? maxStartDateTime = default, DateTimeOffset? minEndDateTime = default, DateTimeOffset? maxEndDateTime = default, DateTimeOffset? createdDateStartTime = default, DateTimeOffset? createdDateEndTime = default, System.Collections.Generic.IEnumerable&lt;string&gt; testProfileRunIds = default, System.Collections.Generic.IEnumerable&lt;string&gt; testProfileIds = default, System.Collections.Generic.IEnumerable&lt;string&gt; statuses = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Developer.LoadTesting.TestProfileRun&gt; GetTestProfileRunsAsync(valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; minStartDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; maxStartDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; minEndDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; maxEndDateTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; createdDateStartTime, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; createdDateEndTime, class System.Collections.Generic.IEnumerable`1&lt;string&gt; testProfileRunIds, class System.Collections.Generic.IEnumerable`1&lt;string&gt; testProfileIds, class System.Collections.Generic.IEnumerable`1&lt;string&gt; statuses, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestProfileRunsAsync(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestProfileRunsAsync (Optional minStartDateTime As Nullable(Of DateTimeOffset) = Nothing, Optional maxStartDateTime As Nullable(Of DateTimeOffset) = Nothing, Optional minEndDateTime As Nullable(Of DateTimeOffset) = Nothing, Optional maxEndDateTime As Nullable(Of DateTimeOffset) = Nothing, Optional createdDateStartTime As Nullable(Of DateTimeOffset) = Nothing, Optional createdDateEndTime As Nullable(Of DateTimeOffset) = Nothing, Optional testProfileRunIds As IEnumerable(Of String) = Nothing, Optional testProfileIds As IEnumerable(Of String) = Nothing, Optional statuses As IEnumerable(Of String) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of TestProfileRun)" />
      <MemberSignature Language="F#" Value="abstract member GetTestProfileRunsAsync : Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&#xA;override this.GetTestProfileRunsAsync : Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * seq&lt;string&gt; * seq&lt;string&gt; * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;" Usage="loadTestRunClient.GetTestProfileRunsAsync (minStartDateTime, maxStartDateTime, minEndDateTime, maxEndDateTime, createdDateStartTime, createdDateEndTime, testProfileRunIds, testProfileIds, statuses, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minStartDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="maxStartDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="minEndDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="maxEndDateTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="createdDateStartTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="createdDateEndTime" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileRunIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="6" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testProfileIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="7" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="statuses" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="8" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="9" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="minStartDateTime"> Minimum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="maxStartDateTime"> Maximum Start DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="minEndDateTime"> Minimum End DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="maxEndDateTime"> Maximum End DateTime(RFC 3339 literal format) of the test profile runs to filter on. </param>
        <param name="createdDateStartTime"> Start DateTime(RFC 3339 literal format) of the created time range to filter test profile runs. </param>
        <param name="createdDateEndTime"> End DateTime(RFC 3339 literal format) of the created time range to filter test profile runs. </param>
        <param name="testProfileRunIds"> Comma separated list of IDs of the test profile runs to filter. </param>
        <param name="testProfileIds"> Comma separated IDs of the test profiles which should be associated with the test profile runs to fetch. </param>
        <param name="statuses"> Comma separated list of Statuses of the test profile runs to filter. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> List test profile runs. </summary>
        <returns>To be added.</returns>
        <remarks> Get all test profile runs for the given filters. </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTestRun (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTestRun(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRun (testRunId As String, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetTestRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTestRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetTestRun (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTestRun (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRun (testRunId As String, context As RequestContext) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test run details by test run Id.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRun(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call GetTestRun and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetTestRun("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTestRun with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetTestRun("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt; GetTestRun (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.LoadTestRun&gt; GetTestRun(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRun(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRun (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of LoadTestRun)" />
      <MemberSignature Language="F#" Value="abstract member GetTestRun : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&#xA;override this.GetTestRun : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;" Usage="loadTestRunClient.GetTestRun (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get test run details by test run Id. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTestRunAsync (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTestRunAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetTestRunAsync (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTestRunAsync (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunAsync (testRunId As String, context As RequestContext) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test run details by test run Id.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call GetTestRunAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetTestRunAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTestRunAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetTestRunAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&gt; GetTestRunAsync (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.LoadTestRun&gt;&gt; GetTestRunAsync(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunAsync (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of LoadTestRun))" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&gt;&#xA;override this.GetTestRunAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&gt;" Usage="loadTestRunClient.GetTestRunAsync (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get test run details by test run Id. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTestRunFile (string testRunId, string fileName, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTestRunFile(string testRunId, string fileName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunFile(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunFile (testRunId As String, fileName As String, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunFile : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTestRunFile : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.GetTestRunFile (testRunId, fileName, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTestRunFile (string testRunId, string fileName, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunFile (testRunId As String, fileName As String, context As RequestContext) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="fileName"> Name of the file. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test run file by file name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunFile(System.String,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>FileInfo</c>:
<code>{
  url: string, # Optional. File URL.
  fileName: string, # Optional. Name of the file.
  fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
  expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
  validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
  validationFailureDetails: string, # Optional. Validation failure error details
}
</code></remarks>
        <example>
This sample shows how to call GetTestRunFile and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetTestRunFile("<testRunId>", "<fileName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTestRunFile with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.GetTestRunFile("<testRunId>", "<fileName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("validationFailureDetails").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunFile">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.TestRunFileInfo&gt; GetTestRunFile (string testRunId, string fileName, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestRunFileInfo&gt; GetTestRunFile(string testRunId, string fileName, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunFile(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunFile (testRunId As String, fileName As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of TestRunFileInfo)" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunFile : string * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestRunFileInfo&gt;&#xA;override this.GetTestRunFile : string * string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestRunFileInfo&gt;" Usage="loadTestRunClient.GetTestRunFile (testRunId, fileName, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.TestRunFileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="fileName" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="fileName"> Name of the file. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get test run file by file name. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTestRunFileAsync (string testRunId, string fileName, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTestRunFileAsync(string testRunId, string fileName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunFileAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunFileAsync (testRunId As String, fileName As String, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunFileAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTestRunFileAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.GetTestRunFileAsync (testRunId, fileName, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTestRunFileAsync (string testRunId, string fileName, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunFileAsync (testRunId As String, fileName As String, context As RequestContext) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="fileName"> Name of the file. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Get test run file by file name.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunFileAsync(System.String,System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>FileInfo</c>:
<code>{
  url: string, # Optional. File URL.
  fileName: string, # Optional. Name of the file.
  fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
  expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
  validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
  validationFailureDetails: string, # Optional. Validation failure error details
}
</code></remarks>
        <example>
This sample shows how to call GetTestRunFileAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetTestRunFileAsync("<testRunId>", "<fileName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetTestRunFileAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.GetTestRunFileAsync("<testRunId>", "<fileName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("validationFailureDetails").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunFileAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunFileInfo&gt;&gt; GetTestRunFileAsync (string testRunId, string fileName, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestRunFileInfo&gt;&gt; GetTestRunFileAsync(string testRunId, string fileName, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunFileAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunFileAsync (testRunId As String, fileName As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of TestRunFileInfo))" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunFileAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunFileInfo&gt;&gt;&#xA;override this.GetTestRunFileAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunFileInfo&gt;&gt;" Usage="loadTestRunClient.GetTestRunFileAsync (testRunId, fileName, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestRunFileInfo&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="fileName" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="fileName"> Name of the file. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get test run file by file name. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> or <paramref name="fileName" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRuns">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetTestRuns (string orderby = default, string search = default, string testId = default, DateTimeOffset? executionFrom = default, DateTimeOffset? executionTo = default, string status = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetTestRuns(string orderby, string search, string testId, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionFrom, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionTo, string status, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRuns(System.String,System.String,System.String,System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRuns (Optional orderby As String = Nothing, Optional search As String = Nothing, Optional testId As String = Nothing, Optional executionFrom As Nullable(Of DateTimeOffset) = Nothing, Optional executionTo As Nullable(Of DateTimeOffset) = Nothing, Optional status As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetTestRuns : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetTestRuns : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetTestRuns (orderby, search, testId, executionFrom, executionTo, status, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetTestRuns (string orderby, string search, string testId, DateTimeOffset? executionFrom, DateTimeOffset? executionTo, string status, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRuns (orderby As String, search As String, testId As String, executionFrom As Nullable(Of DateTimeOffset), executionTo As Nullable(Of DateTimeOffset), status As String, context As RequestContext) As Pageable(Of BinaryData)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orderby" Type="System.String" />
        <Parameter Name="search" Type="System.String" />
        <Parameter Name="testId" Type="System.String" />
        <Parameter Name="executionFrom" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="executionTo" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="status" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="orderby"> Sort on the supported fields in (field asc/desc) format. eg: executedDateTime asc. Supported fields - executedDateTime. </param>
        <param name="search"> Prefix based, case sensitive search on searchable fields - description, executedUser. For example, to search for a test run, with description 500 VUs, the search parameter can be 500. </param>
        <param name="testId"> Unique name of an existing load test. </param>
        <param name="executionFrom"> Start DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        <param name="executionTo"> End DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        <param name="status"> Comma separated list of test run status. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Get all test runs with given filters. </summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRuns">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;Azure.Developer.LoadTesting.LoadTestRun&gt; GetTestRuns (string orderby = default, string search = default, string testId = default, DateTimeOffset? executionFrom = default, DateTimeOffset? executionTo = default, string status = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class Azure.Developer.LoadTesting.LoadTestRun&gt; GetTestRuns(string orderby, string search, string testId, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionFrom, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionTo, string status, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRuns(System.String,System.String,System.String,System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRuns (Optional orderby As String = Nothing, Optional search As String = Nothing, Optional testId As String = Nothing, Optional executionFrom As Nullable(Of DateTimeOffset) = Nothing, Optional executionTo As Nullable(Of DateTimeOffset) = Nothing, Optional status As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Pageable(Of LoadTestRun)" />
      <MemberSignature Language="F#" Value="abstract member GetTestRuns : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&#xA;override this.GetTestRuns : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * System.Threading.CancellationToken -&gt; Azure.Pageable&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;" Usage="loadTestRunClient.GetTestRuns (orderby, search, testId, executionFrom, executionTo, status, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orderby" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="search" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="executionFrom" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="executionTo" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="status" Type="System.String" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="6" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="orderby">
            Sort on the supported fields in (field asc/desc) format. eg: executedDateTime
            asc. Supported fields - executedDateTime
            </param>
        <param name="search">
            Prefix based, case sensitive search on searchable fields - description,
            executedUser. For example, to search for a test run, with description 500 VUs,
            the search parameter can be 500.
            </param>
        <param name="testId"> Unique name of an existing load test. </param>
        <param name="executionFrom"> Start DateTime(RFC 3339 literal format) of test-run execution time filter range. </param>
        <param name="executionTo"> End DateTime(RFC 3339 literal format) of test-run execution time filter range. </param>
        <param name="status"> Comma separated list of test run status. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get all test runs for the given filters. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetTestRunsAsync (string orderby = default, string search = default, string testId = default, DateTimeOffset? executionFrom = default, DateTimeOffset? executionTo = default, string status = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetTestRunsAsync(string orderby, string search, string testId, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionFrom, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionTo, string status, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunsAsync(System.String,System.String,System.String,System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunsAsync (Optional orderby As String = Nothing, Optional search As String = Nothing, Optional testId As String = Nothing, Optional executionFrom As Nullable(Of DateTimeOffset) = Nothing, Optional executionTo As Nullable(Of DateTimeOffset) = Nothing, Optional status As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunsAsync : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetTestRunsAsync : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="loadTestRunClient.GetTestRunsAsync (orderby, search, testId, executionFrom, executionTo, status, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetTestRunsAsync (string orderby, string search, string testId, DateTimeOffset? executionFrom, DateTimeOffset? executionTo, string status, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunsAsync (orderby As String, search As String, testId As String, executionFrom As Nullable(Of DateTimeOffset), executionTo As Nullable(Of DateTimeOffset), status As String, context As RequestContext) As AsyncPageable(Of BinaryData)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orderby" Type="System.String" />
        <Parameter Name="search" Type="System.String" />
        <Parameter Name="testId" Type="System.String" />
        <Parameter Name="executionFrom" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="executionTo" Type="System.Nullable&lt;System.DateTimeOffset&gt;" />
        <Parameter Name="status" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="orderby"> Sort on the supported fields in (field asc/desc) format. eg: executedDateTime asc. Supported fields - executedDateTime. </param>
        <param name="search"> Prefix based, case sensitive search on searchable fields - description, executedUser. For example, to search for a test run, with description 500 VUs, the search parameter can be 500. </param>
        <param name="testId"> Unique name of an existing load test. </param>
        <param name="executionFrom"> Start DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        <param name="executionTo"> End DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        <param name="status"> Comma separated list of test run status. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary> Get all test runs with given filters. </summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTestRunsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.LoadTestRun&gt; GetTestRunsAsync (string orderby = default, string search = default, string testId = default, DateTimeOffset? executionFrom = default, DateTimeOffset? executionTo = default, string status = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class Azure.Developer.LoadTesting.LoadTestRun&gt; GetTestRunsAsync(string orderby, string search, string testId, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionFrom, valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; executionTo, string status, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.GetTestRunsAsync(System.String,System.String,System.String,System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTestRunsAsync (Optional orderby As String = Nothing, Optional search As String = Nothing, Optional testId As String = Nothing, Optional executionFrom As Nullable(Of DateTimeOffset) = Nothing, Optional executionTo As Nullable(Of DateTimeOffset) = Nothing, Optional status As String = Nothing, Optional cancellationToken As CancellationToken = Nothing) As AsyncPageable(Of LoadTestRun)" />
      <MemberSignature Language="F#" Value="abstract member GetTestRunsAsync : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&#xA;override this.GetTestRunsAsync : string * string * string * Nullable&lt;DateTimeOffset&gt; * Nullable&lt;DateTimeOffset&gt; * string * System.Threading.CancellationToken -&gt; Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;" Usage="loadTestRunClient.GetTestRunsAsync (orderby, search, testId, executionFrom, executionTo, status, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orderby" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="search" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="testId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="executionFrom" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="executionTo" Type="System.Nullable&lt;System.DateTimeOffset&gt;" Index="4" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="status" Type="System.String" Index="5" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="6" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="orderby">
            Sort on the supported fields in (field asc/desc) format. eg: executedDateTime
            asc. Supported fields - executedDateTime
            </param>
        <param name="search">
            Prefix based, case sensitive search on searchable fields - description,
            executedUser. For example, to search for a test run, with description 500 VUs,
            the search parameter can be 500.
            </param>
        <param name="testId"> Unique name of an existing load test. </param>
        <param name="executionFrom"> Start DateTime(RFC 3339 literal format) of test-run execution time filter range. </param>
        <param name="executionTo"> End DateTime(RFC 3339 literal format) of test-run execution time filter range. </param>
        <param name="status"> Comma separated list of test run status. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Get all test runs for the given filters. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Developer.LoadTesting.LoadTestRunClient.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Developer.LoadTesting.LoadTestRunClient.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopTestProfileRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response StopTestProfileRun (string testProfileRunId, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response StopTestProfileRun(string testProfileRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestProfileRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestProfileRun (testProfileRunId As String, context As RequestContext) As Response" />
      <MemberSignature Language="F#" Value="abstract member StopTestProfileRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.StopTestProfileRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.StopTestProfileRun (testProfileRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Stop test profile run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestProfileRun(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="StopTestProfileRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt; StopTestProfileRun (string testProfileRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestProfileRun&gt; StopTestProfileRun(string testProfileRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestProfileRun(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestProfileRun (testProfileRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of TestProfileRun)" />
      <MemberSignature Language="F#" Value="abstract member StopTestProfileRun : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&#xA;override this.StopTestProfileRun : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;" Usage="loadTestRunClient.StopTestProfileRun (testProfileRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Stop test profile run. </summary>
        <returns>To be added.</returns>
        <remarks> Stop test profile run for the given test profile run Id. </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="StopTestProfileRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; StopTestProfileRunAsync (string testProfileRunId, Azure.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; StopTestProfileRunAsync(string testProfileRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestProfileRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestProfileRunAsync (testProfileRunId As String, context As RequestContext) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member StopTestProfileRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.StopTestProfileRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.StopTestProfileRunAsync (testProfileRunId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Stop test profile run.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestProfileRunAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="StopTestProfileRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&gt; StopTestProfileRunAsync (string testProfileRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.TestProfileRun&gt;&gt; StopTestProfileRunAsync(string testProfileRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestProfileRunAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestProfileRunAsync (testProfileRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of TestProfileRun))" />
      <MemberSignature Language="F#" Value="abstract member StopTestProfileRunAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&gt;&#xA;override this.StopTestProfileRunAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&gt;" Usage="loadTestRunClient.StopTestProfileRunAsync (testProfileRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.TestProfileRun&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testProfileRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testProfileRunId"> Unique identifier for the test profile run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Stop test profile run. </summary>
        <returns>To be added.</returns>
        <remarks> Stop test profile run for the given test profile run Id. </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testProfileRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testProfileRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="StopTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response StopTestRun (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response StopTestRun(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestRun(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestRun (testRunId As String, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member StopTestRun : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.StopTestRun : string * Azure.RequestContext -&gt; Azure.Response" Usage="loadTestRunClient.StopTestRun (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Response StopTestRun (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestRun (testRunId As String, context As RequestContext) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Stop test run by test run Id.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestRun(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call StopTestRun and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.StopTestRun("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call StopTestRun with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = client.StopTestRun("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="StopTestRun">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt; StopTestRun (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Developer.LoadTesting.LoadTestRun&gt; StopTestRun(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestRun(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestRun (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Response(Of LoadTestRun)" />
      <MemberSignature Language="F#" Value="abstract member StopTestRun : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&#xA;override this.StopTestRun : string * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;" Usage="loadTestRunClient.StopTestRun (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Stop test run by test run Id. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="StopTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; StopTestRunAsync (string testRunId, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; StopTestRunAsync(string testRunId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestRunAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestRunAsync (testRunId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member StopTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.StopTestRunAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="loadTestRunClient.StopTestRunAsync (testRunId, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; StopTestRunAsync (string testRunId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestRunAsync (testRunId As String, context As RequestContext) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.0.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Stop test run by test run Id.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item><item><description>
            Please try the simpler <see cref="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestRunAsync(System.String,System.Threading.CancellationToken)" /> convenience overload with strongly typed models first.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TestRun</c>:
<code>{
  passFailCriteria: {
    passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
  }, # Optional. Pass fail criteria for a test.
  secrets: Dictionary&lt;string, Secret&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
  certificate: {
    value: string, # Optional. The value of the certificate for respective type
    type: "AKV_CERT_URI", # Optional. Type of certificate
    name: string, # Optional. Name of the certificate.
  }, # Optional. Certificates metadata
  environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
  errorDetails: [
    {
      message: string, # Optional. Error details in case test run was not successfully run.
    }
  ], # Optional. Error details if there is any failure in load test run
  testRunStatistics: Dictionary&lt;string, TestRunStatistics&gt;, # Optional. Test run statistics.
  loadTestConfiguration: {
    engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
    splitAllCSVs: boolean, # Optional. If false, Azure Load Testing copies and processes your input files unmodified across all test engine instances. If true, Azure Load Testing splits the CSV input data evenly across all engine instances. If you provide multiple CSV files, each file will be split evenly.
    quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
    optionalLoadTestConfig: {
      endpointUrl: string, # Optional. Test URL. Provide the complete HTTP URL. For example, http://contoso-app.azurewebsites.net/login
      virtualUsers: number, # Optional. No of concurrent virtual users
      rampUpTime: number, # Optional. Ramp up time
      duration: number, # Optional. Test run duration
    }, # Optional. Optional load test config
  }, # Optional. The load test configuration.
  testArtifacts: {
    inputArtifacts: {
      configFileInfo: {
        url: string, # Optional. File URL.
        fileName: string, # Optional. Name of the file.
        fileType: "JMX_FILE" | "USER_PROPERTIES" | "ADDITIONAL_ARTIFACTS", # Optional. File type
        expireDateTime: string (ISO 8601 Format), # Optional. Expiry time of the file (ISO 8601 literal format)
        validationStatus: "NOT_VALIDATED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE" | "VALIDATION_INITIATED" | "VALIDATION_NOT_REQUIRED", # Optional. Validation status of the file
        validationFailureDetails: string, # Optional. Validation failure error details
      }, # Optional. File info
      testScriptFileInfo: FileInfo, # Optional. File info
      userPropFileInfo: FileInfo, # Optional. File info
      inputArtifactsZipFileInfo: FileInfo, # Optional. File info
      additionalFileInfo: [FileInfo], # Optional. Additional supported files for the test run
    }, # Optional. The input artifacts for the test run.
    outputArtifacts: {
      resultFileInfo: FileInfo, # Optional. File info
      logsFileInfo: FileInfo, # Optional. File info
    }, # Optional. The output artifacts for the test run.
  }, # Optional. Collection of test run artifacts
  testResult: "PASSED" | "NOT_APPLICABLE" | "FAILED", # Optional. Test result for pass/Fail criteria used during the test run.
  virtualUsers: number, # Optional. Number of virtual users, for which test has been run.
  testRunId: string, # Optional. Unique test run name as identifier
  displayName: string, # Optional. Display name of a testRun.
  testId: string, # Optional. Associated test Id.
  description: string, # Optional. The test run description.
  status: "ACCEPTED" | "NOTSTARTED" | "PROVISIONING" | "PROVISIONED" | "CONFIGURING" | "CONFIGURED" | "EXECUTING" | "EXECUTED" | "DEPROVISIONING" | "DEPROVISIONED" | "DONE" | "CANCELLING" | "CANCELLED" | "FAILED" | "VALIDATION_SUCCESS" | "VALIDATION_FAILURE", # Optional. The test run status.
  startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
  endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
  executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
  portalUrl: string, # Optional. Portal url.
  duration: number, # Optional. Test run duration in milliseconds.
  subnetId: string, # Optional. Subnet ID on which the load test instances should run.
  createdDateTime: string (ISO 8601 Format), # Optional. The creation datetime(ISO 8601 literal format).
  createdBy: string, # Optional. The user that created.
  lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified datetime(ISO 8601 literal format).
  lastModifiedBy: string, # Optional. The user that last modified.
}
</code></remarks>
        <example>
This sample shows how to call StopTestRunAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.StopTestRunAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call StopTestRunAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
LoadTestRunClient client = new LoadTestRunClient(endpoint, credential);

Response response = await client.StopTestRunAsync("<testRunId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("clientMetric").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("aggregate").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("condition").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("requestName").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("action").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("actualValue").ToString());
Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<key>").GetProperty("result").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("secrets").GetProperty("<key>").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("transaction").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sampleCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorCount").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("errorPct").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("meanResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("medianResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("maxResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("minResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct1ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct2ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("pct3ResTime").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("throughput").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("receivedKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<key>").GetProperty("sentKBytesPerSec").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("engineInstances").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("splitAllCSVs").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("quickStartTest").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
Console.WriteLine(result.GetProperty("loadTestConfiguration").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalFileInfo")[0].GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("url").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileName").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("fileType").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("expireDateTime").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationStatus").ToString());
Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsFileInfo").GetProperty("validationFailureDetails").ToString());
Console.WriteLine(result.GetProperty("testResult").ToString());
Console.WriteLine(result.GetProperty("virtualUsers").ToString());
Console.WriteLine(result.GetProperty("testRunId").ToString());
Console.WriteLine(result.GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("testId").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
Console.WriteLine(result.GetProperty("startDateTime").ToString());
Console.WriteLine(result.GetProperty("endDateTime").ToString());
Console.WriteLine(result.GetProperty("executedDateTime").ToString());
Console.WriteLine(result.GetProperty("portalUrl").ToString());
Console.WriteLine(result.GetProperty("duration").ToString());
Console.WriteLine(result.GetProperty("subnetId").ToString());
Console.WriteLine(result.GetProperty("createdDateTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="StopTestRunAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&gt; StopTestRunAsync (string testRunId, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Developer.LoadTesting.LoadTestRun&gt;&gt; StopTestRunAsync(string testRunId, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Developer.LoadTesting.LoadTestRunClient.StopTestRunAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StopTestRunAsync (testRunId As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of LoadTestRun))" />
      <MemberSignature Language="F#" Value="abstract member StopTestRunAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&gt;&#xA;override this.StopTestRunAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&gt;" Usage="loadTestRunClient.StopTestRunAsync (testRunId, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Developer.LoadTesting</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Developer.LoadTesting.LoadTestRun&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testRunId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="testRunId"> Unique test run identifier for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary> Stop test run by test run Id. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="testRunId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="testRunId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
  </Members>
</Type>
