<Type Name="AuthenticationResult" FullName="Microsoft.Identity.Client.AuthenticationResult">
  <TypeSignature Language="C#" Value="public class AuthenticationResult" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AuthenticationResult extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Identity.Client.AuthenticationResult" />
  <TypeSignature Language="VB.NET" Value="Public Class AuthenticationResult" />
  <TypeSignature Language="F#" Value="type AuthenticationResult = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Identity.Client</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.5.0.0</AssemblyVersion>
    <AssemblyVersion>2.6.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Contains the results of one token acquisition operation in <see cref="T:Microsoft.Identity.Client.PublicClientApplication" />
            or <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication" />. For details see https://aka.ms/msal-net-authenticationresult
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AuthenticationResult (string accessToken, bool isExtendedLifeTimeToken, string uniqueId, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string tenantId, Microsoft.Identity.Client.IAccount account, string idToken, System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string accessToken, bool isExtendedLifeTimeToken, string uniqueId, valuetype System.DateTimeOffset expiresOn, valuetype System.DateTimeOffset extendedExpiresOn, string tenantId, class Microsoft.Identity.Client.IAccount account, string idToken, class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.AuthenticationResult.#ctor(System.String,System.Boolean,System.String,System.DateTimeOffset,System.DateTimeOffset,System.String,Microsoft.Identity.Client.IAccount,System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (accessToken As String, isExtendedLifeTimeToken As Boolean, uniqueId As String, expiresOn As DateTimeOffset, extendedExpiresOn As DateTimeOffset, tenantId As String, account As IAccount, idToken As String, scopes As IEnumerable(Of String))" />
      <MemberSignature Language="F#" Value="new Microsoft.Identity.Client.AuthenticationResult : string * bool * string * DateTimeOffset * DateTimeOffset * string * Microsoft.Identity.Client.IAccount * string * seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AuthenticationResult" Usage="new Microsoft.Identity.Client.AuthenticationResult (accessToken, isExtendedLifeTimeToken, uniqueId, expiresOn, extendedExpiresOn, tenantId, account, idToken, scopes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="accessToken" Type="System.String" />
        <Parameter Name="isExtendedLifeTimeToken" Type="System.Boolean" />
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="expiresOn" Type="System.DateTimeOffset" />
        <Parameter Name="extendedExpiresOn" Type="System.DateTimeOffset" />
        <Parameter Name="tenantId" Type="System.String" />
        <Parameter Name="account" Type="Microsoft.Identity.Client.IAccount" />
        <Parameter Name="idToken" Type="System.String" />
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="accessToken">To be added.</param>
        <param name="isExtendedLifeTimeToken">To be added.</param>
        <param name="uniqueId">To be added.</param>
        <param name="expiresOn">To be added.</param>
        <param name="extendedExpiresOn">To be added.</param>
        <param name="tenantId">To be added.</param>
        <param name="account">To be added.</param>
        <param name="idToken">To be added.</param>
        <param name="scopes">To be added.</param>
        <summary>
            Constructor meant to help application developers test their apps. Allows mocking of authentication flows. 
            App developers should never new-up <see cref="T:Microsoft.Identity.Client.AuthenticationResult" /> in product code.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessToken">
      <MemberSignature Language="C#" Value="public virtual string AccessToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.AccessToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AccessToken As String" />
      <MemberSignature Language="F#" Value="member this.AccessToken : string" Usage="Microsoft.Identity.Client.AuthenticationResult.AccessToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the Access Token to use as a bearer token to access the protected web API
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Account">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Identity.Client.IAccount Account { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Identity.Client.IAccount Account" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.Account" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Account As IAccount" />
      <MemberSignature Language="F#" Value="member this.Account : Microsoft.Identity.Client.IAccount" Usage="Microsoft.Identity.Client.AuthenticationResult.Account" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.IAccount</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the account information. Some elements in <see cref="T:Microsoft.Identity.Client.IAccount" /> might be null if not returned by the
            service. The account can be passed back in some API overloads to identify which account should be used such 
            as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilentAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" /> or
            <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.RemoveAsync(Microsoft.Identity.Client.IAccount)" /> for instance
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAuthorizationHeader">
      <MemberSignature Language="C#" Value="public virtual string CreateAuthorizationHeader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateAuthorizationHeader() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.AuthenticationResult.CreateAuthorizationHeader" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateAuthorizationHeader () As String" />
      <MemberSignature Language="F#" Value="abstract member CreateAuthorizationHeader : unit -&gt; string&#xA;override this.CreateAuthorizationHeader : unit -&gt; string" Usage="authenticationResult.CreateAuthorizationHeader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates the content for an HTTP authorization header from this authentication result, so
            that you can call a protected API
            </summary>
        <returns>Created authorization header of the form "Bearer {AccessToken}"</returns>
        <remarks>To be added.</remarks>
        <example>
            Here is how you can call a protected API from this authentication result (in the <c>result</c>
            variable):
            <code>
            HttpClient client = new HttpClient();
            client.DefaultRequestHeaders.Add("Authorization", result.CreateAuthorizationHeader());
            HttpResponseMessage r = await client.GetAsync(urlOfTheProtectedApi);
            </code></example>
      </Docs>
    </Member>
    <Member MemberName="ExpiresOn">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ExpiresOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTimeOffset ExpiresOn" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.ExpiresOn" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExpiresOn As DateTimeOffset" />
      <MemberSignature Language="F#" Value="member this.ExpiresOn : DateTimeOffset" Usage="Microsoft.Identity.Client.AuthenticationResult.ExpiresOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the point in time in which the Access Token returned in the <see cref="P:Microsoft.Identity.Client.AuthenticationResult.AccessToken" /> property ceases to be valid.
            This value is calculated based on current UTC time measured locally and the value expiresIn received from the
            service.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedExpiresOn">
      <MemberSignature Language="C#" Value="public DateTimeOffset ExtendedExpiresOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTimeOffset ExtendedExpiresOn" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.ExtendedExpiresOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedExpiresOn As DateTimeOffset" />
      <MemberSignature Language="F#" Value="member this.ExtendedExpiresOn : DateTimeOffset" Usage="Microsoft.Identity.Client.AuthenticationResult.ExtendedExpiresOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the point in time in which the Access Token returned in the AccessToken property ceases to be valid in MSAL's extended LifeTime.
            This value is calculated based on current UTC time measured locally and the value ext_expiresIn received from the service.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IdToken">
      <MemberSignature Language="C#" Value="public virtual string IdToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.IdToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IdToken As String" />
      <MemberSignature Language="F#" Value="member this.IdToken : string" Usage="Microsoft.Identity.Client.AuthenticationResult.IdToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the  Id Token if returned by the service or null if no Id Token is returned.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExtendedLifeTimeToken">
      <MemberSignature Language="C#" Value="public bool IsExtendedLifeTimeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExtendedLifeTimeToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.IsExtendedLifeTimeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExtendedLifeTimeToken As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsExtendedLifeTimeToken : bool" Usage="Microsoft.Identity.Client.AuthenticationResult.IsExtendedLifeTimeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            In case when Azure AD has an outage, to be more resilient, it can return tokens with
            an expiration time, and also with an extended expiration time.
            The tokens are then automatically refreshed by MSAL when the time is more than the
            expiration time, except when ExtendedLifeTimeEnabled is true and the time is less
            than the extended expiration time. This goes in pair with Web APIs middleware which,
            when this extended life time is enabled, can accept slightly expired tokens.
            Client applications accept extended life time tokens only if
            the ExtendedLifeTimeEnabled Boolean is set to true on ClientApplicationBase.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scopes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; Scopes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; Scopes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.Scopes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Scopes As IEnumerable(Of String)" />
      <MemberSignature Language="F#" Value="member this.Scopes : seq&lt;string&gt;" Usage="Microsoft.Identity.Client.AuthenticationResult.Scopes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the granted scope values returned by the service.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TenantId">
      <MemberSignature Language="C#" Value="public virtual string TenantId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TenantId" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.TenantId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TenantId As String" />
      <MemberSignature Language="F#" Value="member this.TenantId : string" Usage="Microsoft.Identity.Client.AuthenticationResult.TenantId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets an identifier for the Azure AD tenant from which the token was acquired. This property will be null if tenant information is
            not returned by the service.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public virtual string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueId As String" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="Microsoft.Identity.Client.AuthenticationResult.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the Unique Id of the account. It can be null. When the <see cref="P:Microsoft.Identity.Client.AuthenticationResult.IdToken" /> is not <c>null</c>, this is its ID, that
            is its ObjectId claim, or if that claim is <c>null</c>, the Subject claim.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.IUser User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Identity.Client.IUser User" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.AuthenticationResult.User" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property User As IUser" />
      <MemberSignature Language="F#" Value="member this.User : Microsoft.Identity.Client.IUser" Usage="Microsoft.Identity.Client.AuthenticationResult.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use Account instead (See https://aka.ms/msal-net-2-released)", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.IUser</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            In MSAL.NET 1.x, returned the user who signed in to get the authentication result. From MSAL 2.x
            rather use <see cref="P:Microsoft.Identity.Client.AuthenticationResult.Account" /> instead. See https://aka.ms/msal-net-2-released for more details.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>