<Type Name="MsalError" FullName="Microsoft.Identity.Client.MsalError">
  <TypeSignature Language="C#" Value="public static class MsalError" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MsalError extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Identity.Client.MsalError" />
  <TypeSignature Language="VB.NET" Value="Public Class MsalError" />
  <TypeSignature Language="F#" Value="type MsalError = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Identity.Client</AssemblyName>
    <AssemblyVersion>2.5.0.0</AssemblyVersion>
    <AssemblyVersion>2.6.0.0</AssemblyVersion>
    <AssemblyVersion>2.6.1.0</AssemblyVersion>
    <AssemblyVersion>2.6.2.0</AssemblyVersion>
    <AssemblyVersion>2.7.0.0</AssemblyVersion>
    <AssemblyVersion>2.7.1.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Error code returned as a property in MsalException
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AccessDenied">
      <MemberSignature Language="C#" Value="public const string AccessDenied;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AccessDenied" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.AccessDenied" />
      <MemberSignature Language="VB.NET" Value="Public Const AccessDenied As String " />
      <MemberSignature Language="F#" Value="val mutable AccessDenied : string" Usage="Microsoft.Identity.Client.MsalError.AccessDenied" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Access denied.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessingWsMetadataExchangeFailed">
      <MemberSignature Language="C#" Value="public const string AccessingWsMetadataExchangeFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AccessingWsMetadataExchangeFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.AccessingWsMetadataExchangeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const AccessingWsMetadataExchangeFailed As String " />
      <MemberSignature Language="F#" Value="val mutable AccessingWsMetadataExchangeFailed : string" Usage="Microsoft.Identity.Client.MsalError.AccessingWsMetadataExchangeFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Accessing WS Metadata Exchange Failed.
            <para>What happens?</para>
            You tried to use <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)" />
            and the account is a federated account.
            <para>Mitigation</para>
            None. The WS metadata was not found or does not correspond to what was expected.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivityRequired">
      <MemberSignature Language="C#" Value="public const string ActivityRequired;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string ActivityRequired" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.ActivityRequired" />
      <MemberSignature Language="VB.NET" Value="Public Const ActivityRequired As String " />
      <MemberSignature Language="F#" Value="val mutable ActivityRequired : string" Usage="Microsoft.Identity.Client.MsalError.ActivityRequired" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            TODO: UPDATE DOCUMENTATION!
            On Android, you need to call <c>AcquireTokenInteractiveParameterBuilder.WithParentActivityOrWindow(object)</c> passing
            the activity. See https://aka.ms/msal-interactive-android
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationCanceledError">
      <MemberSignature Language="C#" Value="public const string AuthenticationCanceledError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AuthenticationCanceledError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.AuthenticationCanceledError" />
      <MemberSignature Language="VB.NET" Value="Public Const AuthenticationCanceledError As String " />
      <MemberSignature Language="F#" Value="val mutable AuthenticationCanceledError : string" Usage="Microsoft.Identity.Client.MsalError.AuthenticationCanceledError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Authentication canceled.
            <para>What happens?</para>The user had canceled the authentication, for instance by closing the authentication dialog
            <para>Mitigation</para>None, you cannot get a token to call the protected API. You might want to inform the user
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationFailed">
      <MemberSignature Language="C#" Value="public const string AuthenticationFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AuthenticationFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.AuthenticationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const AuthenticationFailed As String " />
      <MemberSignature Language="F#" Value="val mutable AuthenticationFailed : string" Usage="Microsoft.Identity.Client.MsalError.AuthenticationFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Authentication failed.
            <para>What happens?</para>
            The authentication failed. For instance the user did not enter the right password
            <para>Mitigation</para>
            Inform the user to retry.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationUiFailed">
      <MemberSignature Language="C#" Value="public const string AuthenticationUiFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AuthenticationUiFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.AuthenticationUiFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const AuthenticationUiFailed As String " />
      <MemberSignature Language="F#" Value="val mutable AuthenticationUiFailed : string" Usage="Microsoft.Identity.Client.MsalError.AuthenticationUiFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The request could not be preformed because of an unknown failure in the UI flow.*
            <para>Mitigation</para>
            Inform the user.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationUiFailedError">
      <MemberSignature Language="C#" Value="public const string AuthenticationUiFailedError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AuthenticationUiFailedError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.AuthenticationUiFailedError" />
      <MemberSignature Language="VB.NET" Value="Public Const AuthenticationUiFailedError As String " />
      <MemberSignature Language="F#" Value="val mutable AuthenticationUiFailedError : string" Usage="Microsoft.Identity.Client.MsalError.AuthenticationUiFailedError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The request could not be performed because of a failure in the UI flow.
            <para>What happens?</para>The library failed to invoke the Web View required to perform interactive authentication.
            The exception might include the reason
            <para>Mitigation</para>If the exception includes the reason, you could inform the user. This might be, for instance, a browser
            implementing chrome tabs is missing on the Android phone (that's only an example: this exception can apply to other
            platforms as well)
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthorityValidationFailed">
      <MemberSignature Language="C#" Value="public const string AuthorityValidationFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AuthorityValidationFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.AuthorityValidationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const AuthorityValidationFailed As String " />
      <MemberSignature Language="F#" Value="val mutable AuthorityValidationFailed : string" Usage="Microsoft.Identity.Client.MsalError.AuthorityValidationFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Authority validation failed.
            <para>What happens?</para>
            The validation of the authority failed. This might be because the authority is not
            compliant with the OIDC standard, or there might be a security issue
            <para>Mitigation</para>
            Use a different authority. If you are absolutely sure that you can trust the authority
            you can use the <see cref="M:Microsoft.Identity.Client.AbstractApplicationBuilder`1.WithAuthority(Microsoft.Identity.Client.AadAuthorityAudience,System.Boolean)" /> passing
            the <c>validateAuthority</c> parameter to <c>false</c> (not recommended)
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="B2CAuthorityHostMismatch">
      <MemberSignature Language="C#" Value="public const string B2CAuthorityHostMismatch;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string B2CAuthorityHostMismatch" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.B2CAuthorityHostMismatch" />
      <MemberSignature Language="VB.NET" Value="Public Const B2CAuthorityHostMismatch As String " />
      <MemberSignature Language="F#" Value="val mutable B2CAuthorityHostMismatch : string" Usage="Microsoft.Identity.Client.MsalError.B2CAuthorityHostMismatch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The B2C authority host is not the same as the one used when creating the client application.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BrokerResponseHashMismatch">
      <MemberSignature Language="C#" Value="public const string BrokerResponseHashMismatch;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string BrokerResponseHashMismatch" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.BrokerResponseHashMismatch" />
      <MemberSignature Language="VB.NET" Value="Public Const BrokerResponseHashMismatch As String " />
      <MemberSignature Language="F#" Value="val mutable BrokerResponseHashMismatch : string" Usage="Microsoft.Identity.Client.MsalError.BrokerResponseHashMismatch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Broker response hash did not match
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BrokerResponseReturnedError">
      <MemberSignature Language="C#" Value="public const string BrokerResponseReturnedError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string BrokerResponseReturnedError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.BrokerResponseReturnedError" />
      <MemberSignature Language="VB.NET" Value="Public Const BrokerResponseReturnedError As String " />
      <MemberSignature Language="F#" Value="val mutable BrokerResponseReturnedError : string" Usage="Microsoft.Identity.Client.MsalError.BrokerResponseReturnedError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Broker response returned an error
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CannotAccessUserInformationOrUserNotDomainJoined">
      <MemberSignature Language="C#" Value="public const string CannotAccessUserInformationOrUserNotDomainJoined;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string CannotAccessUserInformationOrUserNotDomainJoined" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.CannotAccessUserInformationOrUserNotDomainJoined" />
      <MemberSignature Language="VB.NET" Value="Public Const CannotAccessUserInformationOrUserNotDomainJoined As String " />
      <MemberSignature Language="F#" Value="val mutable CannotAccessUserInformationOrUserNotDomainJoined : string" Usage="Microsoft.Identity.Client.MsalError.CannotAccessUserInformationOrUserNotDomainJoined" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Cannot Access User Information or the user is not a user domain.
            <para>What happens?</para>
            You tried to use <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})" />
            but the user is not a domain user (the machine is not domain or AAD joined)
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CannotInvokeBroker">
      <MemberSignature Language="C#" Value="public const string CannotInvokeBroker;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string CannotInvokeBroker" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.CannotInvokeBroker" />
      <MemberSignature Language="VB.NET" Value="Public Const CannotInvokeBroker As String " />
      <MemberSignature Language="F#" Value="val mutable CannotInvokeBroker : string" Usage="Microsoft.Identity.Client.MsalError.CannotInvokeBroker" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            MSAL is not able to invoke the broker. Possible reasons are the broker is not installed on the user's device, 
            or there were issues with the UiParent or CallerViewController being null. See https://aka.ms/msal-brokers
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeExpired">
      <MemberSignature Language="C#" Value="public const string CodeExpired;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string CodeExpired" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.CodeExpired" />
      <MemberSignature Language="VB.NET" Value="Public Const CodeExpired As String " />
      <MemberSignature Language="F#" Value="val mutable CodeExpired : string" Usage="Microsoft.Identity.Client.MsalError.CodeExpired" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>What happens?</para>
            In the context of Device code flow (See https://aka.ms/msal-net-device-code-flow),
            this error happens when the device code expired before the user signed-in on another device (this is usually after 15 mins).
            <para>Mitigation</para>
            None. Inform the user that they took too long to sign-in at the provided URL and enter the provided code.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomWebUiRedirectUriMismatch">
      <MemberSignature Language="C#" Value="public const string CustomWebUiRedirectUriMismatch;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string CustomWebUiRedirectUriMismatch" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.CustomWebUiRedirectUriMismatch" />
      <MemberSignature Language="VB.NET" Value="Public Const CustomWebUiRedirectUriMismatch As String " />
      <MemberSignature Language="F#" Value="val mutable CustomWebUiRedirectUriMismatch : string" Usage="Microsoft.Identity.Client.MsalError.CustomWebUiRedirectUriMismatch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Error code used when the CustomWebUI has returned an uri, but it does not match the Authroity and AbsolutePath of 
            the configured redirect uri.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomWebUiReturnedInvalidUri">
      <MemberSignature Language="C#" Value="public const string CustomWebUiReturnedInvalidUri;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string CustomWebUiReturnedInvalidUri" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.CustomWebUiReturnedInvalidUri" />
      <MemberSignature Language="VB.NET" Value="Public Const CustomWebUiReturnedInvalidUri As String " />
      <MemberSignature Language="F#" Value="val mutable CustomWebUiReturnedInvalidUri : string" Usage="Microsoft.Identity.Client.MsalError.CustomWebUiReturnedInvalidUri" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Error code used when the <see cref="T:Microsoft.Identity.Client.Extensibility.ICustomWebUi" /> has returned an uri, but it is invalid - it is either null or has no code.
            Consider throwing an exception if you are unable to intercept the uri containing the code. 
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultRedirectUriIsInvalid">
      <MemberSignature Language="C#" Value="public const string DefaultRedirectUriIsInvalid;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultRedirectUriIsInvalid" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.DefaultRedirectUriIsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultRedirectUriIsInvalid As String " />
      <MemberSignature Language="F#" Value="val mutable DefaultRedirectUriIsInvalid : string" Usage="Microsoft.Identity.Client.MsalError.DefaultRedirectUriIsInvalid" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            RedirectUri validation failed.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateQueryParameterError">
      <MemberSignature Language="C#" Value="public const string DuplicateQueryParameterError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DuplicateQueryParameterError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.DuplicateQueryParameterError" />
      <MemberSignature Language="VB.NET" Value="Public Const DuplicateQueryParameterError As String " />
      <MemberSignature Language="F#" Value="val mutable DuplicateQueryParameterError : string" Usage="Microsoft.Identity.Client.MsalError.DuplicateQueryParameterError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Duplicate query parameter was found in extraQueryParameters.
            <para>What happens?</para> You have used <c>extraQueryParameter</c> of overrides
            of token acquisition operations in public client and confidential client application and are passing a parameter which is already present in the
            URL (either because you had it in another way, or the library added it).
            <para>Mitigation [App Development]</para> RemoveAccount the duplicate parameter from the token acquisition override.
            </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.GetAuthorizationRequestUrlAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EncodedTokenTooLong">
      <MemberSignature Language="C#" Value="public const string EncodedTokenTooLong;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string EncodedTokenTooLong" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.EncodedTokenTooLong" />
      <MemberSignature Language="VB.NET" Value="Public Const EncodedTokenTooLong As String " />
      <MemberSignature Language="F#" Value="val mutable EncodedTokenTooLong : string" Usage="Microsoft.Identity.Client.MsalError.EncodedTokenTooLong" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Encoded token too long.
            <para>What happens</para>
            In a confidential client application call, the client assertion built by MSAL is longer than
            the max possible length for a JWT token.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FailedToAcquireTokenSilentlyFromBroker">
      <MemberSignature Language="C#" Value="public const string FailedToAcquireTokenSilentlyFromBroker;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string FailedToAcquireTokenSilentlyFromBroker" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.FailedToAcquireTokenSilentlyFromBroker" />
      <MemberSignature Language="VB.NET" Value="Public Const FailedToAcquireTokenSilentlyFromBroker As String " />
      <MemberSignature Language="F#" Value="val mutable FailedToAcquireTokenSilentlyFromBroker : string" Usage="Microsoft.Identity.Client.MsalError.FailedToAcquireTokenSilentlyFromBroker" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Failed to acquire token silently. Used in broker scenarios.
            <para>What happens</para>
            you called <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" />
            or <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},System.String)" /> and your
            mobile (Xamarin) application leverages the broker (Microsoft Authenticator or Microsoft Company Portal), but the broker
            was not able to acquire the token silently.
            <para>Mitigation</para>
            Call <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FailedToRefreshToken">
      <MemberSignature Language="C#" Value="public const string FailedToRefreshToken;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string FailedToRefreshToken" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.FailedToRefreshToken" />
      <MemberSignature Language="VB.NET" Value="Public Const FailedToRefreshToken As String " />
      <MemberSignature Language="F#" Value="val mutable FailedToRefreshToken : string" Usage="Microsoft.Identity.Client.MsalError.FailedToRefreshToken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Failed to refresh token.
            <para>What happens?</para>
            The token could not be refreshed. This can be because the user has not used the application for a long time.
            and therefore the refresh token maintained in the token cache has expired
            <para>Mitigation</para>
            If you are in a public client application, that supports interactivity, send an interactive request
            <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})" />. Otherwise,
            use a different method to acquire tokens.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FederatedServiceReturnedError">
      <MemberSignature Language="C#" Value="public const string FederatedServiceReturnedError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string FederatedServiceReturnedError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.FederatedServiceReturnedError" />
      <MemberSignature Language="VB.NET" Value="Public Const FederatedServiceReturnedError As String " />
      <MemberSignature Language="F#" Value="val mutable FederatedServiceReturnedError : string" Usage="Microsoft.Identity.Client.MsalError.FederatedServiceReturnedError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Federated service returned error.
            <para>Mitigation</para>
            None. The federated service returned an error. You can try to look at the
            Body of the exception for a better understanding of the error and choose
            the mitigation
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUserNameFailed">
      <MemberSignature Language="C#" Value="public const string GetUserNameFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string GetUserNameFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.GetUserNameFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const GetUserNameFailed As String " />
      <MemberSignature Language="F#" Value="val mutable GetUserNameFailed : string" Usage="Microsoft.Identity.Client.MsalError.GetUserNameFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Failed to get user name.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpStatusCodeNotOk">
      <MemberSignature Language="C#" Value="public const string HttpStatusCodeNotOk;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string HttpStatusCodeNotOk" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.HttpStatusCodeNotOk" />
      <MemberSignature Language="VB.NET" Value="Public Const HttpStatusCodeNotOk As String " />
      <MemberSignature Language="F#" Value="val mutable HttpStatusCodeNotOk : string" Usage="Microsoft.Identity.Client.MsalError.HttpStatusCodeNotOk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            ErrorCode used when the http response returns something different from 200 (OK)
            </summary>
        <remarks>
            HttpStatusCode.NotFound have a specific error code. <see cref="F:Microsoft.Identity.Client.MsalError.HttpStatusNotFound" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpStatusNotFound">
      <MemberSignature Language="C#" Value="public const string HttpStatusNotFound;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string HttpStatusNotFound" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.HttpStatusNotFound" />
      <MemberSignature Language="VB.NET" Value="Public Const HttpStatusNotFound As String " />
      <MemberSignature Language="F#" Value="val mutable HttpStatusNotFound : string" Usage="Microsoft.Identity.Client.MsalError.HttpStatusNotFound" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Error code used when the http response returns HttpStatusCode.NotFound
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IntegratedWindowsAuthNotSupportedForManagedUser">
      <MemberSignature Language="C#" Value="public const string IntegratedWindowsAuthNotSupportedForManagedUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string IntegratedWindowsAuthNotSupportedForManagedUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.IntegratedWindowsAuthNotSupportedForManagedUser" />
      <MemberSignature Language="VB.NET" Value="Public Const IntegratedWindowsAuthNotSupportedForManagedUser As String " />
      <MemberSignature Language="F#" Value="val mutable IntegratedWindowsAuthNotSupportedForManagedUser : string" Usage="Microsoft.Identity.Client.MsalError.IntegratedWindowsAuthNotSupportedForManagedUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Integrated Windows Auth is only supported for "federated" users
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalError">
      <MemberSignature Language="C#" Value="public const string InternalError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string InternalError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.InternalError" />
      <MemberSignature Language="VB.NET" Value="Public Const InternalError As String " />
      <MemberSignature Language="F#" Value="val mutable InternalError : string" Usage="Microsoft.Identity.Client.MsalError.InternalError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Internal error
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidAuthority">
      <MemberSignature Language="C#" Value="public const string InvalidAuthority;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string InvalidAuthority" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.InvalidAuthority" />
      <MemberSignature Language="VB.NET" Value="Public Const InvalidAuthority As String " />
      <MemberSignature Language="F#" Value="val mutable InvalidAuthority : string" Usage="Microsoft.Identity.Client.MsalError.InvalidAuthority" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Invalid authority
            <para>What happens</para> When the library attempts to discover the authority and get the endpoints it needs to
            acquire a token, it got an un-authorize HTTP code or an unexpected response
            <para>remediation</para> Check that the authority configured for the application, or passed on some overrides of token acquisition tokens
            supporting authority override is correct
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidAuthorityType">
      <MemberSignature Language="C#" Value="public const string InvalidAuthorityType;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string InvalidAuthorityType" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.InvalidAuthorityType" />
      <MemberSignature Language="VB.NET" Value="Public Const InvalidAuthorityType As String " />
      <MemberSignature Language="F#" Value="val mutable InvalidAuthorityType : string" Usage="Microsoft.Identity.Client.MsalError.InvalidAuthorityType" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Invalid authority type.
            MSAL.NET does not know how to interact with the authority specified when the application was built.
            <para>Mitigation</para>
            Use a different authority
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidGrantError">
      <MemberSignature Language="C#" Value="public const string InvalidGrantError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string InvalidGrantError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.InvalidGrantError" />
      <MemberSignature Language="VB.NET" Value="Public Const InvalidGrantError As String " />
      <MemberSignature Language="F#" Value="val mutable InvalidGrantError : string" Usage="Microsoft.Identity.Client.MsalError.InvalidGrantError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Standard OAuth2 protocol error code. It indicates that the application needs to expose the UI to the user  
            so that the user does an interactive action in order to get a new token.
            <para>Mitigation:</para> If your application is a <see cref="T:IPublicClientApplication" /> call <c>AcquireTokenInteractive</c>
            perform an interactive authentication. If your application is a <see cref="T:ConfidentialClientApplication" /> chances are that the Claims member
            of the exception is not empty. See <see cref="P:MsalServiceException.Claims" /> for the right mitigation
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidJwtError">
      <MemberSignature Language="C#" Value="public const string InvalidJwtError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string InvalidJwtError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.InvalidJwtError" />
      <MemberSignature Language="VB.NET" Value="Public Const InvalidJwtError As String " />
      <MemberSignature Language="F#" Value="val mutable InvalidJwtError : string" Usage="Microsoft.Identity.Client.MsalError.InvalidJwtError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            JWT was invalid.
            <para>What happens?</para>The library expected a JWT (for instance a token from the cache, or received from the STS), but
            the format is invalid
            <para>Mitigation</para>Make sure that the token cache was not tampered
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidOwnerWindowType">
      <MemberSignature Language="C#" Value="public const string InvalidOwnerWindowType;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string InvalidOwnerWindowType" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.InvalidOwnerWindowType" />
      <MemberSignature Language="VB.NET" Value="Public Const InvalidOwnerWindowType As String " />
      <MemberSignature Language="F#" Value="val mutable InvalidOwnerWindowType : string" Usage="Microsoft.Identity.Client.MsalError.InvalidOwnerWindowType" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Invalid owner window type.
            <para>What happens?</para>
            You used <c>"AcquireTokenInteractiveParameterBuilder.WithParentActivityOrWindow(object)</c>
            but the parameter you passed is invalid.
            <para>Remediation</para>
            On .NET Standard, the expected object is an <c>Activity</c> on Android, a <c>UIViewController</c> on iOS,
            a <c>NSWindow</c> on MAC, and a <c>IWin32Window</c> or <c>IntPr</c> on Windows.
            If you are in a WPF application, you can use <c>WindowInteropHelper(wpfControl).Handle</c> to get the window
            handle associated with a WPF control
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidRequest">
      <MemberSignature Language="C#" Value="public const string InvalidRequest;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string InvalidRequest" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.InvalidRequest" />
      <MemberSignature Language="VB.NET" Value="Public Const InvalidRequest As String " />
      <MemberSignature Language="F#" Value="val mutable InvalidRequest : string" Usage="Microsoft.Identity.Client.MsalError.InvalidRequest" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Request is invalid.
            <para>What happens?</para>
            This can happen because you are using a token acquisition method which is not compatible with the authority. For instance:
            you called <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)" />
            but you used an authority ending with '/common' or '/consumers' as this requires a tenanted authority or '/organizations'.
            <para>Mitigation</para>
            Adjust the authority to the AcquireTokenXX method you use (don't use 'common' or 'consumers' with <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)" /><see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidServiceUrl">
      <MemberSignature Language="C#" Value="public const string InvalidServiceUrl;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string InvalidServiceUrl" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.InvalidServiceUrl" />
      <MemberSignature Language="VB.NET" Value="Public Const InvalidServiceUrl As String " />
      <MemberSignature Language="F#" Value="val mutable InvalidServiceUrl : string" Usage="Microsoft.Identity.Client.MsalError.InvalidServiceUrl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Invalid service URL.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="JsonParseError">
      <MemberSignature Language="C#" Value="public const string JsonParseError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string JsonParseError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.JsonParseError" />
      <MemberSignature Language="VB.NET" Value="Public Const JsonParseError As String " />
      <MemberSignature Language="F#" Value="val mutable JsonParseError : string" Usage="Microsoft.Identity.Client.MsalError.JsonParseError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            JSON parsing failed.
            <para>What happens?</para>A Json blob read from the token cache or received from the STS was not parseable. 
            This can happen when reading the token cache, or receiving an IDToken from the STS.
            <para>Mitigation</para>Make sure that the token cache was not tampered
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MissingFederationMetadataUrl">
      <MemberSignature Language="C#" Value="public const string MissingFederationMetadataUrl;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string MissingFederationMetadataUrl" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.MissingFederationMetadataUrl" />
      <MemberSignature Language="VB.NET" Value="Public Const MissingFederationMetadataUrl As String " />
      <MemberSignature Language="F#" Value="val mutable MissingFederationMetadataUrl : string" Usage="Microsoft.Identity.Client.MsalError.MissingFederationMetadataUrl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Federation Metadata Url is missing for federated user.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MissingPassiveAuthEndpoint">
      <MemberSignature Language="C#" Value="public const string MissingPassiveAuthEndpoint;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string MissingPassiveAuthEndpoint" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.MissingPassiveAuthEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public Const MissingPassiveAuthEndpoint As String " />
      <MemberSignature Language="F#" Value="val mutable MissingPassiveAuthEndpoint : string" Usage="Microsoft.Identity.Client.MsalError.MissingPassiveAuthEndpoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            No passive auth endpoint was found in the OIDC configuration of the authority
            <para>What happens?</para> When the libraries go to the authority and get its open id connect configuration
            it expects to find a Passive Auth Endpoint entry, and could not find it.
            <para>remediation</para> Check that the authority configured for the application, or passed on some overrides of token acquisition tokens
            supporting authority override is correct
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultipleAccountsForLoginHint">
      <MemberSignature Language="C#" Value="public const string MultipleAccountsForLoginHint;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string MultipleAccountsForLoginHint" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.MultipleAccountsForLoginHint" />
      <MemberSignature Language="VB.NET" Value="Public Const MultipleAccountsForLoginHint As String " />
      <MemberSignature Language="F#" Value="val mutable MultipleAccountsForLoginHint : string" Usage="Microsoft.Identity.Client.MsalError.MultipleAccountsForLoginHint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This error code denotes that multiple accounts were found having the same login hint and MSAL 
            cannot chose one. Please use <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithAccount(Microsoft.Identity.Client.IAccount)" /> to specify the account
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultipleTokensMatchedError">
      <MemberSignature Language="C#" Value="public const string MultipleTokensMatchedError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string MultipleTokensMatchedError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.MultipleTokensMatchedError" />
      <MemberSignature Language="VB.NET" Value="Public Const MultipleTokensMatchedError As String " />
      <MemberSignature Language="F#" Value="val mutable MultipleTokensMatchedError : string" Usage="Microsoft.Identity.Client.MsalError.MultipleTokensMatchedError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Multiple Tokens were matched. 
            <para>What happens?</para>This exception happens in the case of applications managing several identitities, 
            when calling <see cref="M:Microsoft.Identity.Client.ClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" />
            or one of its overrides and the user token cache contains multiple tokens for this client application and the the specified Account, but from different authorities.
            <para>Mitigation [App Development]</para>specify the authority to use in the acquire token operation
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NetworkNotAvailableError">
      <MemberSignature Language="C#" Value="public const string NetworkNotAvailableError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string NetworkNotAvailableError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.NetworkNotAvailableError" />
      <MemberSignature Language="VB.NET" Value="Public Const NetworkNotAvailableError As String " />
      <MemberSignature Language="F#" Value="val mutable NetworkNotAvailableError : string" Usage="Microsoft.Identity.Client.MsalError.NetworkNotAvailableError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The request could not be preformed because the network is down.
            <para>Mitigation [App development]</para> In the application you could either inform the user that there are network issues
            or retry later
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NoAccountForLoginHint">
      <MemberSignature Language="C#" Value="public const string NoAccountForLoginHint;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string NoAccountForLoginHint" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.NoAccountForLoginHint" />
      <MemberSignature Language="VB.NET" Value="Public Const NoAccountForLoginHint As String " />
      <MemberSignature Language="F#" Value="val mutable NoAccountForLoginHint : string" Usage="Microsoft.Identity.Client.MsalError.NoAccountForLoginHint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This error code denotes that no account was found having the given login hint.
            <para>What happens?</para><see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},System.String)" />
            or <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithLoginHint(System.String)" />
            was called with a <c>loginHint</c> parameter which does not match any account in <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.GetAccountsAsync" /><para>Mitigation</para>
            If you are certain about the loginHint, call <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NoDataFromSts">
      <MemberSignature Language="C#" Value="public const string NoDataFromSts;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string NoDataFromSts" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.NoDataFromSts" />
      <MemberSignature Language="VB.NET" Value="Public Const NoDataFromSts As String " />
      <MemberSignature Language="F#" Value="val mutable NoDataFromSts : string" Usage="Microsoft.Identity.Client.MsalError.NoDataFromSts" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            No data from STS.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NonHttpsRedirectNotSupported">
      <MemberSignature Language="C#" Value="public const string NonHttpsRedirectNotSupported;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string NonHttpsRedirectNotSupported" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.NonHttpsRedirectNotSupported" />
      <MemberSignature Language="VB.NET" Value="Public Const NonHttpsRedirectNotSupported As String " />
      <MemberSignature Language="F#" Value="val mutable NonHttpsRedirectNotSupported : string" Usage="Microsoft.Identity.Client.MsalError.NonHttpsRedirectNotSupported" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Non HTTPS redirects are not supported
            <para>What happens?</para>This error happens when you have registered a non-https redirect URI for the 
            public client application other than <c>urn:ietf:wg:oauth:2.0:oob</c><para>Mitigation [App registration and development]</para>Register in the application a Reply URL starting with "https://"
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NonParsableOAuthError">
      <MemberSignature Language="C#" Value="public const string NonParsableOAuthError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string NonParsableOAuthError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.NonParsableOAuthError" />
      <MemberSignature Language="VB.NET" Value="Public Const NonParsableOAuthError As String " />
      <MemberSignature Language="F#" Value="val mutable NonParsableOAuthError : string" Usage="Microsoft.Identity.Client.MsalError.NonParsableOAuthError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            An error response was returned by the OAuth2 server and it could not be parsed
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NoPromptFailedError">
      <MemberSignature Language="C#" Value="public const string NoPromptFailedError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string NoPromptFailedError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.NoPromptFailedError" />
      <MemberSignature Language="VB.NET" Value="Public Const NoPromptFailedError As String " />
      <MemberSignature Language="F#" Value="val mutable NoPromptFailedError : string" Usage="Microsoft.Identity.Client.MsalError.NoPromptFailedError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            One of two conditions was encountered:
            <list type="bullet"><item><description>The <c>Prompt.NoPrompt</c> was passed in an interactive token call, but the constraint could not be honored because user interaction is required,
            for instance because the user needs to re-sign-in, give consent for more scopes, or perform multiple factor authentication.
            </description></item><item><description>
            An error occurred during a silent web authentication that prevented the authentication flow from completing in a short enough time frame.
            </description></item></list><para>Remediation:</para>call <c>AcquireTokenInteractive</c> so that the user of your application signs-in and accepts consent. 
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NoRedirectUri">
      <MemberSignature Language="C#" Value="public const string NoRedirectUri;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string NoRedirectUri" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.NoRedirectUri" />
      <MemberSignature Language="VB.NET" Value="Public Const NoRedirectUri As String " />
      <MemberSignature Language="F#" Value="val mutable NoRedirectUri : string" Usage="Microsoft.Identity.Client.MsalError.NoRedirectUri" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            No Redirect URI.
            <para>What happens?</para>
            You need to provide a Reply URI / Redirect URI, but have not called <see cref="M:Microsoft.Identity.Client.AbstractApplicationBuilder`1.WithRedirectUri(System.String)" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NoTokensFoundError">
      <MemberSignature Language="C#" Value="public const string NoTokensFoundError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string NoTokensFoundError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.NoTokensFoundError" />
      <MemberSignature Language="VB.NET" Value="Public Const NoTokensFoundError As String " />
      <MemberSignature Language="F#" Value="val mutable NoTokensFoundError : string" Usage="Microsoft.Identity.Client.MsalError.NoTokensFoundError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            No token was found in the token cache.
            <para>Mitigation:</para> If your application is a <see cref="T:Microsoft.Identity.Client.IPublicClientApplication" /> call <c>AcquireTokenInteractive</c> so
            that the user of your application signs-in and accepts consent. If your application is a <see cref="T:ConfidentialClientApplication" />.:
            <list type="bullet"><item>
            If it's a Web App you should have previously called <see cref="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenByAuthorizationCode(System.Collections.Generic.IEnumerable{System.String},System.String)" />
            as described in https://aka.ms/msal-net-authorization-code. You need to make sure that you have requested the right scopes. For details
            See https://github.com/Azure-Samples/ms-identity-aspnetcore-webapp-tutorial
            </item><item>This error should not happen in Web APIs</item></list></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParsingWsMetadataExchangeFailed">
      <MemberSignature Language="C#" Value="public const string ParsingWsMetadataExchangeFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string ParsingWsMetadataExchangeFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.ParsingWsMetadataExchangeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const ParsingWsMetadataExchangeFailed As String " />
      <MemberSignature Language="F#" Value="val mutable ParsingWsMetadataExchangeFailed : string" Usage="Microsoft.Identity.Client.MsalError.ParsingWsMetadataExchangeFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Parsing WS Metadata Exchange Failed.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParsingWsTrustResponseFailed">
      <MemberSignature Language="C#" Value="public const string ParsingWsTrustResponseFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string ParsingWsTrustResponseFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.ParsingWsTrustResponseFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const ParsingWsTrustResponseFailed As String " />
      <MemberSignature Language="F#" Value="val mutable ParsingWsTrustResponseFailed : string" Usage="Microsoft.Identity.Client.MsalError.ParsingWsTrustResponseFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            You can get this error when using <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)" />
            In the case of a Federated user (that is owned by a federated IdP, as opposed to a managed user owned in an Azure AD tenant) 
            ID3242: The security token could not be authenticated or authorized.
            The user does not exist or has entered the wrong password
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PasswordRequiredForManagedUserError">
      <MemberSignature Language="C#" Value="public const string PasswordRequiredForManagedUserError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string PasswordRequiredForManagedUserError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.PasswordRequiredForManagedUserError" />
      <MemberSignature Language="VB.NET" Value="Public Const PasswordRequiredForManagedUserError As String " />
      <MemberSignature Language="F#" Value="val mutable PasswordRequiredForManagedUserError : string" Usage="Microsoft.Identity.Client.MsalError.PasswordRequiredForManagedUserError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Password is required for managed user.
            <para>What happens?</para>
            If can got this error when using <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)" />
            and you (or the user) did not provide a password.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PlatformNotSupported">
      <MemberSignature Language="C#" Value="public const string PlatformNotSupported;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string PlatformNotSupported" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.PlatformNotSupported" />
      <MemberSignature Language="VB.NET" Value="Public Const PlatformNotSupported As String " />
      <MemberSignature Language="F#" Value="val mutable PlatformNotSupported : string" Usage="Microsoft.Identity.Client.MsalError.PlatformNotSupported" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The library is loaded on a platform which is not supported.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RedirectUriValidationFailed">
      <MemberSignature Language="C#" Value="public const string RedirectUriValidationFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string RedirectUriValidationFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.RedirectUriValidationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const RedirectUriValidationFailed As String " />
      <MemberSignature Language="F#" Value="val mutable RedirectUriValidationFailed : string" Usage="Microsoft.Identity.Client.MsalError.RedirectUriValidationFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            RedirectUri validation failed.
            <para>What happens?</para>
            The redirect URI / reply URI is invalid
            <para>How to fix</para>
            Pass a valid redirect URI.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestTimeout">
      <MemberSignature Language="C#" Value="public const string RequestTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string RequestTimeout" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.RequestTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const RequestTimeout As String " />
      <MemberSignature Language="F#" Value="val mutable RequestTimeout : string" Usage="Microsoft.Identity.Client.MsalError.RequestTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The Http Request to the STS timed out.
            <para>Mitigation</para> you can retry after a delay.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceNotAvailable">
      <MemberSignature Language="C#" Value="public const string ServiceNotAvailable;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string ServiceNotAvailable" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.ServiceNotAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Const ServiceNotAvailable As String " />
      <MemberSignature Language="F#" Value="val mutable ServiceNotAvailable : string" Usage="Microsoft.Identity.Client.MsalError.ServiceNotAvailable" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Service is unavailable and returned HTTP error code within the range of 500-599
            <para>Mitigation</para> you can retry after a delay.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateMismatchError">
      <MemberSignature Language="C#" Value="public const string StateMismatchError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string StateMismatchError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.StateMismatchError" />
      <MemberSignature Language="VB.NET" Value="Public Const StateMismatchError As String " />
      <MemberSignature Language="F#" Value="val mutable StateMismatchError : string" Usage="Microsoft.Identity.Client.MsalError.StateMismatchError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            State returned from the STS was different from the one sent by the library
            <para>What happens?</para>The library sends to the STS a state associated to a request, and expects the reply to be consistent. 
            This errors indicates that the reply is not associated with the request. This could indicate an attempt to replay a response
            <para>Mitigation</para> None
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TenantDiscoveryFailedError">
      <MemberSignature Language="C#" Value="public const string TenantDiscoveryFailedError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string TenantDiscoveryFailedError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.TenantDiscoveryFailedError" />
      <MemberSignature Language="VB.NET" Value="Public Const TenantDiscoveryFailedError As String " />
      <MemberSignature Language="F#" Value="val mutable TenantDiscoveryFailedError : string" Usage="Microsoft.Identity.Client.MsalError.TenantDiscoveryFailedError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Tenant discovery failed.
            <para>What happens?</para>While reading the openid configuration associated with the authority, the Authorize endpoint,
            or Token endpoint, or the Issuer was not found
            <para>Mitigation</para>This indicates and authority which is not Open ID Connect compliant. Specify a different authority
            in the constructor of the application, or the token acquisition override
            /// </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenCacheNullError">
      <MemberSignature Language="C#" Value="public const string TokenCacheNullError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string TokenCacheNullError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.TokenCacheNullError" />
      <MemberSignature Language="VB.NET" Value="Public Const TokenCacheNullError As String " />
      <MemberSignature Language="F#" Value="val mutable TokenCacheNullError : string" Usage="Microsoft.Identity.Client.MsalError.TokenCacheNullError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This error code comes back from <see cref="M:Microsoft.Identity.Client.ClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" /> calls when 
            the user cache had not been set in the application constructor. This should never happen in MSAL.NET 3.x as the cache is created by the applicaiton
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UapCannotFindDomainUser">
      <MemberSignature Language="C#" Value="public const string UapCannotFindDomainUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UapCannotFindDomainUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UapCannotFindDomainUser" />
      <MemberSignature Language="VB.NET" Value="Public Const UapCannotFindDomainUser As String " />
      <MemberSignature Language="F#" Value="val mutable UapCannotFindDomainUser : string" Usage="Microsoft.Identity.Client.MsalError.UapCannotFindDomainUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Cannot access the user from the OS (UWP)
             <para>What happens</para>
             You called <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})" />, but the domain user
             name could not be found.
            <para>Mitigation</para>
             This might be because you need to add more capabilities to your UWP application in the Package.appxmanifest.
             See https://aka.ms/msal-net-uwp 
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UapCannotFindUpn">
      <MemberSignature Language="C#" Value="public const string UapCannotFindUpn;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UapCannotFindUpn" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UapCannotFindUpn" />
      <MemberSignature Language="VB.NET" Value="Public Const UapCannotFindUpn As String " />
      <MemberSignature Language="F#" Value="val mutable UapCannotFindUpn : string" Usage="Microsoft.Identity.Client.MsalError.UapCannotFindUpn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Cannot get the user from the OS (UWP)
             <para>What happens</para>
             You called <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})" />, but the domain user
             name could not be found.
            <para>Mitigation</para>
             This might be because you need to add more capabilities to your UWP application in the Package.appxmanifest.
             See https://aka.ms/msal-net-uwp 
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnknownError">
      <MemberSignature Language="C#" Value="public const string UnknownError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UnknownError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UnknownError" />
      <MemberSignature Language="VB.NET" Value="Public Const UnknownError As String " />
      <MemberSignature Language="F#" Value="val mutable UnknownError : string" Usage="Microsoft.Identity.Client.MsalError.UnknownError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Unknown Error occured.
            <para>Mitigation</para> None. You might want to inform the end user.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnknownUser">
      <MemberSignature Language="C#" Value="public const string UnknownUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UnknownUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UnknownUser" />
      <MemberSignature Language="VB.NET" Value="Public Const UnknownUser As String " />
      <MemberSignature Language="F#" Value="val mutable UnknownUser : string" Usage="Microsoft.Identity.Client.MsalError.UnknownUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>What happens</para>
            You can get this error when using <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)" />
            The user is not known by the IdP
            <para>Mitigation</para>
            Inform the user. The login that the user provided might be incorrect (for instance empty)
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnknownUserType">
      <MemberSignature Language="C#" Value="public const string UnknownUserType;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UnknownUserType" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UnknownUserType" />
      <MemberSignature Language="VB.NET" Value="Public Const UnknownUserType As String " />
      <MemberSignature Language="F#" Value="val mutable UnknownUserType : string" Usage="Microsoft.Identity.Client.MsalError.UnknownUserType" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>What happens</para>
            You can get this error when using <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)" />
            The user is not recognized as a managed user, or a federated user. Azure AD was not
            able to identify the IdP that needs to process the user
            <para>Mitigation</para>
            Inform the user. the login that the user provided might be incorrect.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpnRequired">
      <MemberSignature Language="C#" Value="public const string UpnRequired;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UpnRequired" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UpnRequired" />
      <MemberSignature Language="VB.NET" Value="Public Const UpnRequired As String " />
      <MemberSignature Language="F#" Value="val mutable UpnRequired : string" Usage="Microsoft.Identity.Client.MsalError.UpnRequired" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            loginHint should be a Upn
            <para>What happens?</para> An override of a token acquisition operation was called in <see cref="T:IPublicClientApplication" /> which
            takes a <c>loginHint</c> as a parameters, but this login hint was not using the UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c> 
            expected by the service
            <para>Remediation</para> Make sure in your code that you enforce <c>loginHint</c> to be a UPN
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserMismatch">
      <MemberSignature Language="C#" Value="public const string UserMismatch;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UserMismatch" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UserMismatch" />
      <MemberSignature Language="VB.NET" Value="Public Const UserMismatch As String " />
      <MemberSignature Language="F#" Value="val mutable UserMismatch : string" Usage="Microsoft.Identity.Client.MsalError.UserMismatch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            User Mismatch.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserNullError">
      <MemberSignature Language="C#" Value="public const string UserNullError;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UserNullError" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UserNullError" />
      <MemberSignature Language="VB.NET" Value="Public Const UserNullError As String " />
      <MemberSignature Language="F#" Value="val mutable UserNullError : string" Usage="Microsoft.Identity.Client.MsalError.UserNullError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This error code comes back from <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" /> calls when a null user is 
            passed as the <c>account</c> parameter. This can be because you have called AcquireTokenSilent with an <c>account</c> parameter
            set to <c>accounts.FirstOrDefault()</c> but <c>accounts</c> is empty.
            <para>Mitigation</para>
            Pass a different account, or otherwise call <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserRealmDiscoveryFailed">
      <MemberSignature Language="C#" Value="public const string UserRealmDiscoveryFailed;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string UserRealmDiscoveryFailed" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.UserRealmDiscoveryFailed" />
      <MemberSignature Language="VB.NET" Value="Public Const UserRealmDiscoveryFailed As String " />
      <MemberSignature Language="F#" Value="val mutable UserRealmDiscoveryFailed : string" Usage="Microsoft.Identity.Client.MsalError.UserRealmDiscoveryFailed" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            User Realm Discovery Failed.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WsTrustEndpointNotFoundInMetadataDocument">
      <MemberSignature Language="C#" Value="public const string WsTrustEndpointNotFoundInMetadataDocument;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string WsTrustEndpointNotFoundInMetadataDocument" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.MsalError.WsTrustEndpointNotFoundInMetadataDocument" />
      <MemberSignature Language="VB.NET" Value="Public Const WsTrustEndpointNotFoundInMetadataDocument As String " />
      <MemberSignature Language="F#" Value="val mutable WsTrustEndpointNotFoundInMetadataDocument : string" Usage="Microsoft.Identity.Client.MsalError.WsTrustEndpointNotFoundInMetadataDocument" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>2.5.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.6.1.0</AssemblyVersion>
        <AssemblyVersion>2.6.2.0</AssemblyVersion>
        <AssemblyVersion>2.7.0.0</AssemblyVersion>
        <AssemblyVersion>2.7.1.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            WS-Trust Endpoint Not Found in Metadata Document.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>