<Type Name="AcquireTokenForClientParameterBuilder" FullName="Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder">
  <TypeSignature Language="C#" Value="public sealed class AcquireTokenForClientParameterBuilder : Microsoft.Identity.Client.AbstractConfidentialClientAcquireTokenParameterBuilder&lt;Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AcquireTokenForClientParameterBuilder extends Microsoft.Identity.Client.AbstractConfidentialClientAcquireTokenParameterBuilder`1&lt;class Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AcquireTokenForClientParameterBuilder&#xA;Inherits AbstractConfidentialClientAcquireTokenParameterBuilder(Of AcquireTokenForClientParameterBuilder)" />
  <TypeSignature Language="F#" Value="type AcquireTokenForClientParameterBuilder = class&#xA;    inherit AbstractConfidentialClientAcquireTokenParameterBuilder&lt;AcquireTokenForClientParameterBuilder&gt;" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Identity.Client</AssemblyName>
    <AssemblyVersion>4.24.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.Identity.Client.AbstractConfidentialClientAcquireTokenParameterBuilder&lt;Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Builder for AcquireTokenForClient (used in client credential flows, in daemon applications).
            See https://aka.ms/msal-net-client-credentials
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="WithAzureRegion">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder WithAzureRegion (bool autoDetectRegion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder WithAzureRegion(bool autoDetectRegion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder.WithAzureRegion(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithAzureRegion (autoDetectRegion As Boolean) As AcquireTokenForClientParameterBuilder" />
      <MemberSignature Language="F#" Value="member this.WithAzureRegion : bool -&gt; Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder" Usage="acquireTokenForClientParameterBuilder.WithAzureRegion autoDetectRegion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.24.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="autoDetectRegion" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="autoDetectRegion">
          <c>true</c> if the token request should be sent to regional ESTS. Otherwise <c>false</c>.
            The default is <c>false</c></param>
        <summary>
            Specifies if the token request should be sent to regional ESTS.
            If set, MSAL tries to auto-detect and use a regional Azure authority. This helps keep the authentication traffic inside the Azure region. 
            If the region cannot be determined (e.g. not running on Azure), MSALClientException is thrown with error code region_discovery_failed.
            This feature requires configuration at tenant level.
            By default the value for this variable is false.
            See https://aka.ms/msal-net-region-discovery for more details.
            </summary>
        <returns>The builder to chain the .With methods</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithForceRefresh">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder WithForceRefresh (bool forceRefresh);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder WithForceRefresh(bool forceRefresh) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder.WithForceRefresh(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithForceRefresh (forceRefresh As Boolean) As AcquireTokenForClientParameterBuilder" />
      <MemberSignature Language="F#" Value="member this.WithForceRefresh : bool -&gt; Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder" Usage="acquireTokenForClientParameterBuilder.WithForceRefresh forceRefresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.24.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceRefresh" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceRefresh">If <c>true</c>, the request will ignore the token cache. The default is <c>false</c></param>
        <summary>
            Specifies if the token request will ignore the access token in the application token cache
            and will attempt to acquire a new access token using client credentials.
            By default the token is taken from the application token cache (forceRefresh=false)
            </summary>
        <returns>The builder to chain the .With methods</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithSendX5C">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder WithSendX5C (bool withSendX5C);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder WithSendX5C(bool withSendX5C) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder.WithSendX5C(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithSendX5C (withSendX5C As Boolean) As AcquireTokenForClientParameterBuilder" />
      <MemberSignature Language="F#" Value="member this.WithSendX5C : bool -&gt; Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder" Usage="acquireTokenForClientParameterBuilder.WithSendX5C withSendX5C" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.24.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withSendX5C" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="withSendX5C">
          <c>true</c> if the x5c should be sent. Otherwise <c>false</c>.
            The default is <c>false</c></param>
        <summary>
            Specifies if the x5c claim (public key of the certificate) should be sent to the STS.
            Sending the x5c enables application developers to achieve easy certificate roll-over in Azure AD:
            this method will send the public certificate to Azure AD along with the token request,
            so that Azure AD can use it to validate the subject name based on a trusted issuer policy.
            This saves the application admin from the need to explicitly manage the certificate rollover
            (either via portal or PowerShell/CLI operation). For details see https://aka.ms/msal-net-sni
            </summary>
        <returns>The builder to chain the .With methods</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
