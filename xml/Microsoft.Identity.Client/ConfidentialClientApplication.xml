<Type Name="ConfidentialClientApplication" FullName="Microsoft.Identity.Client.ConfidentialClientApplication">
  <TypeSignature Language="C#" Value="public sealed class ConfidentialClientApplication : Microsoft.Identity.Client.ClientApplicationBase, Microsoft.Identity.Client.IByRefreshToken, Microsoft.Identity.Client.IConfidentialClientApplication, Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate, Microsoft.Identity.Client.ILongRunningWebApi" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConfidentialClientApplication extends Microsoft.Identity.Client.ClientApplicationBase implements class Microsoft.Identity.Client.IByRefreshToken, class Microsoft.Identity.Client.IClientApplicationBase, class Microsoft.Identity.Client.IConfidentialClientApplication, class Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate, class Microsoft.Identity.Client.ILongRunningWebApi" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Identity.Client.ConfidentialClientApplication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConfidentialClientApplication&#xA;Inherits ClientApplicationBase&#xA;Implements IByRefreshToken, IConfidentialClientApplication, IConfidentialClientApplicationWithCertificate, ILongRunningWebApi" />
  <TypeSignature Language="F#" Value="type ConfidentialClientApplication = class&#xA;    inherit ClientApplicationBase&#xA;    interface IConfidentialClientApplication&#xA;    interface IClientApplicationBase&#xA;    interface IConfidentialClientApplicationWithCertificate&#xA;    interface IByRefreshToken&#xA;    interface ILongRunningWebApi" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Identity.Client</AssemblyName>
    <AssemblyVersion>4.30.0.0</AssemblyVersion>
    <AssemblyVersion>4.30.1.0</AssemblyVersion>
    <AssemblyVersion>4.31.0.0</AssemblyVersion>
    <AssemblyVersion>4.32.0.0</AssemblyVersion>
    <AssemblyVersion>4.32.1.0</AssemblyVersion>
    <AssemblyVersion>4.33.0.0</AssemblyVersion>
    <AssemblyVersion>4.34.0.0</AssemblyVersion>
    <AssemblyVersion>4.35.0.0</AssemblyVersion>
    <AssemblyVersion>4.35.1.0</AssemblyVersion>
    <AssemblyVersion>4.36.0.0</AssemblyVersion>
    <AssemblyVersion>4.36.1.0</AssemblyVersion>
    <AssemblyVersion>4.36.2.0</AssemblyVersion>
    <AssemblyVersion>4.37.0.0</AssemblyVersion>
    <AssemblyVersion>4.38.0.0</AssemblyVersion>
    <AssemblyVersion>4.39.0.0</AssemblyVersion>
    <AssemblyVersion>4.40.0.0</AssemblyVersion>
    <AssemblyVersion>4.41.0.0</AssemblyVersion>
    <AssemblyVersion>4.42.0.0</AssemblyVersion>
    <AssemblyVersion>4.42.1.0</AssemblyVersion>
    <AssemblyVersion>4.43.0.0</AssemblyVersion>
    <AssemblyVersion>4.43.1.0</AssemblyVersion>
    <AssemblyVersion>4.43.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.Identity.Client.ClientApplicationBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IByRefreshToken</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IClientApplicationBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IConfidentialClientApplication</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.ILongRunningWebApi</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            Class to be used for confidential client applications (web apps, web APIs, and daemon applications).
            </summary>
    <remarks>
            Confidential client applications are typically applications which run on servers (web apps, web API, or even service/daemon applications).
            They are considered difficult to access, and therefore capable of keeping an application secret (hold configuration
            time secrets as these values would be difficult for end users to extract).
            A web app is the most common confidential client. The clientId is exposed through the web browser, but the secret is passed only in the back channel
            and never directly exposed. For details see https://aka.ms/msal-net-client-applications
            </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConfidentialClientApplication (string clientId, string redirectUri, Microsoft.Identity.Client.ClientCredential clientCredential, Microsoft.Identity.Client.TokenCache userTokenCache, Microsoft.Identity.Client.TokenCache appTokenCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string clientId, string redirectUri, class Microsoft.Identity.Client.ClientCredential clientCredential, class Microsoft.Identity.Client.TokenCache userTokenCache, class Microsoft.Identity.Client.TokenCache appTokenCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.#ctor(System.String,System.String,Microsoft.Identity.Client.ClientCredential,Microsoft.Identity.Client.TokenCache,Microsoft.Identity.Client.TokenCache)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (clientId As String, redirectUri As String, clientCredential As ClientCredential, userTokenCache As TokenCache, appTokenCache As TokenCache)" />
      <MemberSignature Language="F#" Value="new Microsoft.Identity.Client.ConfidentialClientApplication : string * string * Microsoft.Identity.Client.ClientCredential * Microsoft.Identity.Client.TokenCache * Microsoft.Identity.Client.TokenCache -&gt; Microsoft.Identity.Client.ConfidentialClientApplication" Usage="new Microsoft.Identity.Client.ConfidentialClientApplication (clientId, redirectUri, clientCredential, userTokenCache, appTokenCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use ConfidentialClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use ConfidentialClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="clientId" Type="System.String" />
        <Parameter Name="redirectUri" Type="System.String" />
        <Parameter Name="clientCredential" Type="Microsoft.Identity.Client.ClientCredential" />
        <Parameter Name="userTokenCache" Type="Microsoft.Identity.Client.TokenCache" />
        <Parameter Name="appTokenCache" Type="Microsoft.Identity.Client.TokenCache" />
      </Parameters>
      <Docs>
        <param name="clientId">Client ID (also known as App ID) of the application as registered in the
             application registration portal (https://aka.ms/msal-net-register-app)/. REQUIRED</param>
        <param name="redirectUri">URL where the STS will call back the application with the security token. REQUIRED</param>
        <param name="clientCredential">Credential, previously shared with Azure AD during the application registration and proving the identity
             of the application. An instance of ClientCredential can be created either from an application secret, or a certificate. REQUIRED.</param>
        <param name="userTokenCache">Token cache for saving user tokens. Can be set to null if the confidential client
             application only uses the Client Credentials grants (that is requests token in its own name and not in the name of users).
             Otherwise should be provided. REQUIRED</param>
        <param name="appTokenCache">Token cache for saving application (that is client token). Can be set to <c>null</c> except if the application
             uses the client credentials grants</param>
        <summary>
             [V2 API] Constructor for a confidential client application requesting tokens with the default authority (<see cref="F:Microsoft.Identity.Client.ClientApplicationBase.DefaultAuthority" />)
             </summary>
        <remarks>
             See https://aka.ms/msal-net-client-applications for a description of confidential client applications (and public client applications)
             Client credential grants are overrides of <see cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClientAsync(System.Collections.Generic.IEnumerable{System.String})" />
            
             See also <see cref="T:ConfidentialClientApplicationBuilder" /> for the V3 API way of building a confidential client application
             with a builder pattern. It offers building the application from configuration options, and a more fluid way of providing parameters.
             </remarks>
        <altmember cref="T:Microsoft.Identity.Client.ConfidentialClientApplication" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConfidentialClientApplication (string clientId, string authority, string redirectUri, Microsoft.Identity.Client.ClientCredential clientCredential, Microsoft.Identity.Client.TokenCache userTokenCache, Microsoft.Identity.Client.TokenCache appTokenCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string clientId, string authority, string redirectUri, class Microsoft.Identity.Client.ClientCredential clientCredential, class Microsoft.Identity.Client.TokenCache userTokenCache, class Microsoft.Identity.Client.TokenCache appTokenCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.#ctor(System.String,System.String,System.String,Microsoft.Identity.Client.ClientCredential,Microsoft.Identity.Client.TokenCache,Microsoft.Identity.Client.TokenCache)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (clientId As String, authority As String, redirectUri As String, clientCredential As ClientCredential, userTokenCache As TokenCache, appTokenCache As TokenCache)" />
      <MemberSignature Language="F#" Value="new Microsoft.Identity.Client.ConfidentialClientApplication : string * string * string * Microsoft.Identity.Client.ClientCredential * Microsoft.Identity.Client.TokenCache * Microsoft.Identity.Client.TokenCache -&gt; Microsoft.Identity.Client.ConfidentialClientApplication" Usage="new Microsoft.Identity.Client.ConfidentialClientApplication (clientId, authority, redirectUri, clientCredential, userTokenCache, appTokenCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use ConfidentialClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use ConfidentialClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="clientId" Type="System.String" />
        <Parameter Name="authority" Type="System.String" />
        <Parameter Name="redirectUri" Type="System.String" />
        <Parameter Name="clientCredential" Type="Microsoft.Identity.Client.ClientCredential" />
        <Parameter Name="userTokenCache" Type="Microsoft.Identity.Client.TokenCache" />
        <Parameter Name="appTokenCache" Type="Microsoft.Identity.Client.TokenCache" />
      </Parameters>
      <Docs>
        <param name="clientId">Client ID (also named Application ID) of the application as registered in the
             application registration portal (https://aka.ms/msal-net-register-app)/. REQUIRED</param>
        <param name="authority">Authority of the security token service (STS) from which MSAL.NET will acquire the tokens.
             Usual authorities are:
             <list type="bullet"><item><description><c>https://login.microsoftonline.com/tenant/</c>, where <c>tenant</c> is the tenant ID of the Azure AD tenant
             or a domain associated with this Azure AD tenant, in order to sign-in users of a specific organization only</description></item><item><description><c>https://login.microsoftonline.com/common/</c> to sign-in users with any work and school accounts or Microsoft personal accounts</description></item><item><description><c>https://login.microsoftonline.com/organizations/</c> to sign-in users with any work and school accounts</description></item><item><description><c>https://login.microsoftonline.com/consumers/</c> to sign-in users with only personal Microsoft accounts(live)</description></item></list>
             Note that this setting needs to be consistent with what is declared in the application registration portal
             </param>
        <param name="redirectUri">URL where the STS will call back the application with the security token. REQUIRED</param>
        <param name="clientCredential">Credential, previously shared with Azure AD during the application registration and proving the identity
             of the application. An instance of <see cref="T:Microsoft.Identity.Client.ClientCredential" /> can be created either from an application secret, or a certificate. REQUIRED.</param>
        <param name="userTokenCache">Token cache for saving user tokens. Can be set to null if the confidential client
             application only uses the Client Credentials grants (that is requests token in its own name and not in the name of users).
             Otherwise should be provided. REQUIRED</param>
        <param name="appTokenCache">Token cache for saving application (that is client token). Can be set to <c>null</c> except if the application
             uses the client credentials grants</param>
        <summary>
             [V2 API] Constructor for a confidential client application requesting tokens with a specified authority
             </summary>
        <remarks>
             See https://aka.ms/msal-net-client-applications for a description of confidential client applications (and public client applications)
             Client credential grants are overrides of <see cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClientAsync(System.Collections.Generic.IEnumerable{System.String})" />
            
             See also <see cref="T:ConfidentialClientApplicationBuilder" /> for the V3 API way of building a confidential client application
             with a builder pattern. It offers building the application from configuration options, and a more fluid way of providing parameters.
             </remarks>
        <altmember cref="T:Microsoft.Identity.Client.ConfidentialClientApplication" />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenByAuthorizationCode">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string authorizationCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string authorizationCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenByAuthorizationCode(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenByAuthorizationCode (scopes As IEnumerable(Of String), authorizationCode As String) As AcquireTokenByAuthorizationCodeParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenByAuthorizationCode : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder&#xA;override this.AcquireTokenByAuthorizationCode : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder" Usage="confidentialClientApplication.AcquireTokenByAuthorizationCode (scopes, authorizationCode)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenByAuthorizationCode(System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="authorizationCode" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="authorizationCode">The authorization code received from the service authorization endpoint.</param>
        <summary>
            Acquires a security token from the authority configured in the app using the authorization code
            previously received from the STS.
            It uses the OAuth 2.0 authorization code flow (See https://aka.ms/msal-net-authorization-code).
            It's usually used in web apps (for instance ASP.NET / ASP.NET Core web apps) which sign-in users,
            and can request an authorization code.
            This method does not lookup the token cache, but stores the result in it, so it can be looked up
            using other methods such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" />.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>You can set optional parameters by chaining the builder with other .With methods.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenByAuthorizationCodeAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenByAuthorizationCodeAsync (string authorizationCode, System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenByAuthorizationCodeAsync(string authorizationCode, class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenByAuthorizationCodeAsync(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenByAuthorizationCodeAsync (authorizationCode As String, scopes As IEnumerable(Of String)) As Task(Of AuthenticationResult)" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenByAuthorizationCodeAsync : string * seq&lt;string&gt; -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.AcquireTokenByAuthorizationCodeAsync : string * seq&lt;string&gt; -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.AcquireTokenByAuthorizationCodeAsync (authorizationCode, scopes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenByAuthorizationCodeAsync(System.String,System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenByAuthorizationCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenByAuthorizationCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="authorizationCode" Type="System.String" />
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="authorizationCode">The authorization code received from service authorization endpoint.</param>
        <param name="scopes">Scopes requested to access a protected API</param>
        <summary>
            [V2 API] Acquires a security token from the authority configured in the app using the authorization code previously received from the STS. It uses
            the OAuth 2.0 authorization code flow (See https://aka.ms/msal-net-authorization-code).
            It's usually used in web apps (for instance ASP.NET / ASP.NET Core web apps) which sign-in users, and therefore receive an authorization code.
            This method does not lookup the token cache, but stores the result in it, so it can be looked up using other methods
            such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilentAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" />.
            </summary>
        <returns>Authentication result containing token of the user for the requested scopes</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenByAuthorizationCode(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenForClient">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder AcquireTokenForClient (System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder AcquireTokenForClient(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenForClient (scopes As IEnumerable(Of String)) As AcquireTokenForClientParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenForClient : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder&#xA;override this.AcquireTokenForClient : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder" Usage="confidentialClientApplication.AcquireTokenForClient scopes" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">scopes requested to access a protected API. For this flow (client credentials), the scopes
            should be of the form "{ResourceIdUri/.default}" for instance <c>https://management.azure.net/.default</c> or, for Microsoft
            Graph, <c>https://graph.microsoft.com/.default</c> as the requested scopes are defined statically with the application registration
            in the portal, and cannot be overridden in the application.</param>
        <summary>
            Acquires a token from the authority configured in the app, for the confidential client itself (in the name of no user)
            using the client credentials flow. See https://aka.ms/msal-net-client-credentials.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>You can also chain the following optional parameters:
            <see cref="M:Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder.WithForceRefresh(System.Boolean)" /><see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenForClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenForClientAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenForClientAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClientAsync(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenForClientAsync (scopes As IEnumerable(Of String)) As Task(Of AuthenticationResult)" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenForClientAsync : seq&lt;string&gt; -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.AcquireTokenForClientAsync : seq&lt;string&gt; -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.AcquireTokenForClientAsync scopes" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClientAsync(System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">scopes requested to access a protected API. For this flow (client credentials), the scopes
            should be of the form "{ResourceIdUri/.default}" for instance <c>https://management.azure.net/.default</c> or, for Microsoft
            Graph, <c>https://graph.microsoft.com/.default</c> as the requested scopes are really defined statically at application registration
            in the portal, and cannot be overridden in the application. See also </param>
        <summary>
            [V3 API] Acquires a token from the authority configured in the app, for the confidential client itself (in the name of no user)
            using the client credentials flow. (See https://aka.ms/msal-net-client-credentials)
            </summary>
        <returns>Authentication result containing the token of the user for the requested scopes</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenForClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenForClientAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, bool forceRefresh);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenForClientAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, bool forceRefresh) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClientAsync(System.Collections.Generic.IEnumerable{System.String},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenForClientAsync (scopes As IEnumerable(Of String), forceRefresh As Boolean) As Task(Of AuthenticationResult)" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenForClientAsync : seq&lt;string&gt; * bool -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.AcquireTokenForClientAsync : seq&lt;string&gt; * bool -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.AcquireTokenForClientAsync (scopes, forceRefresh)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClientAsync(System.Collections.Generic.IEnumerable{System.String},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="forceRefresh" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API. For this flow (client credentials), the scopes
            should be of the form "{ResourceIdUri/.default}" for instance <c>https://management.azure.net/.default</c> or, for Microsoft
            Graph, <c>https://graph.microsoft.com/.default</c> as the requested scopes are really defined statically at application registration
            in the portal, and cannot be overridden in the application</param>
        <param name="forceRefresh">If <c>true</c>, API will ignore the access token in the cache and attempt to acquire new access token using client credentials.
            This override can be used in case the application knows that conditional access policies changed</param>
        <summary>
            [V2 API] Acquires a token from the authority configured in the app, for the confidential client itself (in the name of no user)
            using the client credentials flow. (See https://aka.ms/msal-net-client-credentials)
            </summary>
        <returns>Authentication result containing token of the user for the requested scopes</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenInLongRunningProcess">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string longRunningProcessSessionKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string longRunningProcessSessionKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenInLongRunningProcess(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenInLongRunningProcess (scopes As IEnumerable(Of String), longRunningProcessSessionKey As String) As AcquireTokenOnBehalfOfParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenInLongRunningProcess : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder&#xA;override this.AcquireTokenInLongRunningProcess : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder" Usage="confidentialClientApplication.AcquireTokenInLongRunningProcess (scopes, longRunningProcessSessionKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.ILongRunningWebApi.AcquireTokenInLongRunningProcess(System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="longRunningProcessSessionKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">To be added.</param>
        <param name="longRunningProcessSessionKey">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenOnBehalfOf">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, Microsoft.Identity.Client.UserAssertion userAssertion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, class Microsoft.Identity.Client.UserAssertion userAssertion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenOnBehalfOf (scopes As IEnumerable(Of String), userAssertion As UserAssertion) As AcquireTokenOnBehalfOfParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenOnBehalfOf : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder&#xA;override this.AcquireTokenOnBehalfOf : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder" Usage="confidentialClientApplication.AcquireTokenOnBehalfOf (scopes, userAssertion)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="userAssertion" Type="Microsoft.Identity.Client.UserAssertion" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="userAssertion">Instance of <see cref="T:Microsoft.Identity.Client.UserAssertion" /> containing credential information about
            the user on behalf of whom to get a token.</param>
        <summary>
            Acquires an access token for this application (usually a Web API) from the authority configured in the application,
            in order to access another downstream protected web API on behalf of a user using the OAuth 2.0 On-Behalf-Of flow.
            See https://aka.ms/msal-net-on-behalf-of.
            This confidential client application was itself called with a token which will be provided in the
            <paramref name="userAssertion">userAssertion</paramref> parameter.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>You can also chain the following optional parameters:
            <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenOnBehalfOfAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenOnBehalfOfAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, Microsoft.Identity.Client.UserAssertion userAssertion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenOnBehalfOfAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, class Microsoft.Identity.Client.UserAssertion userAssertion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOfAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenOnBehalfOfAsync (scopes As IEnumerable(Of String), userAssertion As UserAssertion) As Task(Of AuthenticationResult)" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenOnBehalfOfAsync : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.AcquireTokenOnBehalfOfAsync : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.AcquireTokenOnBehalfOfAsync (scopes, userAssertion)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenOnBehalfOfAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="userAssertion" Type="Microsoft.Identity.Client.UserAssertion" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="userAssertion">Instance of <see cref="T:Microsoft.Identity.Client.UserAssertion" /> containing credential information about
            the user on behalf of whom to get a token.</param>
        <summary>
            [V2 API] Acquires an access token for this application (usually a web API) from the authority configured in the application, in order to access
            another downstream protected web API on behalf of a user using the OAuth 2.0 On-Behalf-Of flow. (See https://aka.ms/msal-net-on-behalf-of).
            This confidential client application was itself called with a token which will be provided in the
            <paramref name="userAssertion">userAssertion</paramref> parameter.
            </summary>
        <returns>Authentication result containing a token for the requested scopes and account</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOfAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion,System.String)" />
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenOnBehalfOfAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenOnBehalfOfAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, Microsoft.Identity.Client.UserAssertion userAssertion, string authority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; AcquireTokenOnBehalfOfAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, class Microsoft.Identity.Client.UserAssertion userAssertion, string authority) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOfAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenOnBehalfOfAsync (scopes As IEnumerable(Of String), userAssertion As UserAssertion, authority As String) As Task(Of AuthenticationResult)" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenOnBehalfOfAsync : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion * string -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.AcquireTokenOnBehalfOfAsync : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion * string -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.AcquireTokenOnBehalfOfAsync (scopes, userAssertion, authority)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenOnBehalfOfAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="userAssertion" Type="Microsoft.Identity.Client.UserAssertion" />
        <Parameter Name="authority" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="userAssertion">Instance of <see cref="T:Microsoft.Identity.Client.UserAssertion" /> containing credential information about
            the user on behalf of whom to get a token.</param>
        <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
        <summary>
            [V2 API] Acquires an access token for this application (usually a web API) from a specific authority, in order to access
            another downstream protected web API on behalf of a user (See https://aka.ms/msal-net-on-behalf-of).
            This confidential client application was itself called with a token which will be provided in the
            <paramref name="userAssertion">userAssertion</paramref> parameter.
            </summary>
        <returns>Authentication result containing a token for the requested scopes and account</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOfAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
      </Docs>
    </Member>
    <Member MemberName="AppTokenCache">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.ITokenCache AppTokenCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Identity.Client.ITokenCache AppTokenCache" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.ConfidentialClientApplication.AppTokenCache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppTokenCache As ITokenCache" />
      <MemberSignature Language="F#" Value="member this.AppTokenCache : Microsoft.Identity.Client.ITokenCache" Usage="Microsoft.Identity.Client.ConfidentialClientApplication.AppTokenCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.Identity.Client.IConfidentialClientApplication.AppTokenCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.ITokenCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Application token cache. This case holds access tokens for the application. It's maintained
            and updated silently if needed when calling <see cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})" /></summary>
        <value>To be added.</value>
        <remarks>On .NET Framework and .NET Core you can also customize the token cache serialization.
            See https://aka.ms/msal-net-token-cache-serialization. This is taken care of by MSAL.NET on other platforms
            </remarks>
        <Summary>
            Application token cache. This case holds access tokens and refresh tokens for the application. It's maintained
            and updated silently if needed when calling <see cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})" /></Summary>
      </Docs>
    </Member>
    <Member MemberName="AttemptRegionDiscovery">
      <MemberSignature Language="C#" Value="public const string AttemptRegionDiscovery;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AttemptRegionDiscovery" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.ConfidentialClientApplication.AttemptRegionDiscovery" />
      <MemberSignature Language="VB.NET" Value="Public Const AttemptRegionDiscovery As String " />
      <MemberSignature Language="F#" Value="val mutable AttemptRegionDiscovery : string" Usage="Microsoft.Identity.Client.ConfidentialClientApplication.AttemptRegionDiscovery" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Instructs MSAL to try to auto discover the Azure region.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Certificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.ConfidentialClientApplication.Certificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Certificate As X509Certificate2" />
      <MemberSignature Language="F#" Value="member this.Certificate : System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="Microsoft.Identity.Client.ConfidentialClientApplication.Certificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The certificate used to create this <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication" />, if any.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAuthorizationRequestUrl">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl (System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.GetAuthorizationRequestUrl(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAuthorizationRequestUrl (scopes As IEnumerable(Of String)) As GetAuthorizationRequestUrlParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member GetAuthorizationRequestUrl : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder&#xA;override this.GetAuthorizationRequestUrl : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder" Usage="confidentialClientApplication.GetAuthorizationRequestUrl scopes" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.GetAuthorizationRequestUrl(System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <summary>
            Computes the URL of the authorization request letting the user sign-in and consent to the application accessing specific scopes in
            the user's name. The URL targets the /authorize endpoint of the authority configured in the application.
            This override enables you to specify a login hint and extra query parameter.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request to get the
            URL of the STS authorization endpoint parametrized with the parameters</returns>
        <remarks>You can also chain the following optional parameters:
            <see cref="M:Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder.WithRedirectUri(System.String)" /><see cref="M:Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder.WithLoginHint(System.String)" /><see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /><see cref="M:Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder.WithExtraScopesToConsent(System.Collections.Generic.IEnumerable{System.String})" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAuthorizationRequestUrlAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Uri&gt; GetAuthorizationRequestUrlAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string loginHint, string extraQueryParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Uri&gt; GetAuthorizationRequestUrlAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string loginHint, string extraQueryParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.GetAuthorizationRequestUrlAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAuthorizationRequestUrlAsync (scopes As IEnumerable(Of String), loginHint As String, extraQueryParameters As String) As Task(Of Uri)" />
      <MemberSignature Language="F#" Value="abstract member GetAuthorizationRequestUrlAsync : seq&lt;string&gt; * string * string -&gt; System.Threading.Tasks.Task&lt;Uri&gt;&#xA;override this.GetAuthorizationRequestUrlAsync : seq&lt;string&gt; * string * string -&gt; System.Threading.Tasks.Task&lt;Uri&gt;" Usage="confidentialClientApplication.GetAuthorizationRequestUrlAsync (scopes, loginHint, extraQueryParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.GetAuthorizationRequestUrlAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Uri&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="loginHint" Type="System.String" />
        <Parameter Name="extraQueryParameters" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="loginHint">Identifier of the user. Generally a UPN. This can be empty</param>
        <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
        <summary>
            [V2 API] Computes the URL of the authorization request letting the user sign-in and consent to the application accessing specific scopes in
            the user's name. The URL targets the /authorize endpoint of the authority configured in the application.
            This override enables you to specify a login hint and extra query parameter.
            </summary>
        <returns>URL of the authorize endpoint including the query parameters.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.GetAuthorizationRequestUrl(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="GetAuthorizationRequestUrlAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Uri&gt; GetAuthorizationRequestUrlAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string redirectUri, string loginHint, string extraQueryParameters, System.Collections.Generic.IEnumerable&lt;string&gt; extraScopesToConsent, string authority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Uri&gt; GetAuthorizationRequestUrlAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string redirectUri, string loginHint, string extraQueryParameters, class System.Collections.Generic.IEnumerable`1&lt;string&gt; extraScopesToConsent, string authority) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.GetAuthorizationRequestUrlAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAuthorizationRequestUrlAsync (scopes As IEnumerable(Of String), redirectUri As String, loginHint As String, extraQueryParameters As String, extraScopesToConsent As IEnumerable(Of String), authority As String) As Task(Of Uri)" />
      <MemberSignature Language="F#" Value="abstract member GetAuthorizationRequestUrlAsync : seq&lt;string&gt; * string * string * string * seq&lt;string&gt; * string -&gt; System.Threading.Tasks.Task&lt;Uri&gt;&#xA;override this.GetAuthorizationRequestUrlAsync : seq&lt;string&gt; * string * string * string * seq&lt;string&gt; * string -&gt; System.Threading.Tasks.Task&lt;Uri&gt;" Usage="confidentialClientApplication.GetAuthorizationRequestUrlAsync (scopes, redirectUri, loginHint, extraQueryParameters, extraScopesToConsent, authority)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.GetAuthorizationRequestUrlAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Uri&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="redirectUri" Type="System.String" />
        <Parameter Name="loginHint" Type="System.String" />
        <Parameter Name="extraQueryParameters" Type="System.String" />
        <Parameter Name="extraScopesToConsent" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="authority" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API (a resource)</param>
        <param name="redirectUri">Address to return to upon receiving a response from the authority.</param>
        <param name="loginHint">Identifier of the user. Generally a UPN.</param>
        <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
        <param name="extraScopesToConsent">Scopes for additional resources (other than the resource for which <paramref name="scopes" /> are requested),
            which a developer can request the user to consent to upfront.</param>
        <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
        <summary>
            [V2 API] Computes the URL of the authorization request letting the user sign-in and consent to the application accessing specific scopes in
            the user's name. The URL targets the /authorize endpoint of the authority specified as the <paramref name="authority" /> parameter.
            This override enables you to specify a redirectUri, login hint extra query parameters, extra scope to consent (which are not for the
            same resource as the <paramref name="scopes" />), and an authority.
            </summary>
        <returns>URL of the authorize endpoint including the query parameters.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.GetAuthorizationRequestUrl(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="InitiateLongRunningProcessInWebApi">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string userToken, ref string longRunningProcessSessionKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string userToken, string&amp; longRunningProcessSessionKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.InitiateLongRunningProcessInWebApi(System.Collections.Generic.IEnumerable{System.String},System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InitiateLongRunningProcessInWebApi (scopes As IEnumerable(Of String), userToken As String, ByRef longRunningProcessSessionKey As String) As AcquireTokenOnBehalfOfParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member InitiateLongRunningProcessInWebApi : seq&lt;string&gt; * string * string -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder&#xA;override this.InitiateLongRunningProcessInWebApi : seq&lt;string&gt; * string * string -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder" Usage="confidentialClientApplication.InitiateLongRunningProcessInWebApi (scopes, userToken, longRunningProcessSessionKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.ILongRunningWebApi.InitiateLongRunningProcessInWebApi(System.Collections.Generic.IEnumerable{System.String},System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="userToken" Type="System.String" />
        <Parameter Name="longRunningProcessSessionKey" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="scopes">To be added.</param>
        <param name="userToken">To be added.</param>
        <param name="longRunningProcessSessionKey">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken">
      <MemberSignature Language="C#" Value="Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder IByRefreshToken.AcquireTokenByRefreshToken (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string refreshToken);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string refreshToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.Microsoft#Identity#Client#IByRefreshToken#AcquireTokenByRefreshToken(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenByRefreshToken (scopes As IEnumerable(Of String), refreshToken As String) As AcquireTokenByRefreshTokenParameterBuilder Implements IByRefreshToken.AcquireTokenByRefreshToken" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder&#xA;override this.Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder" Usage="confidentialClientApplication.Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken (scopes, refreshToken)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="refreshToken" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">To be added.</param>
        <param name="refreshToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; IByRefreshToken.AcquireTokenByRefreshTokenAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string refreshToken);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string refreshToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.Microsoft#Identity#Client#IByRefreshToken#AcquireTokenByRefreshTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenByRefreshTokenAsync (scopes As IEnumerable(Of String), refreshToken As String) As Task(Of AuthenticationResult) Implements IByRefreshToken.AcquireTokenByRefreshTokenAsync" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync : seq&lt;string&gt; * string -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync : seq&lt;string&gt; * string -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync (scopes, refreshToken)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="refreshToken" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">Scope to request from the token endpoint.
            Setting this to null or empty will request an access token, refresh token and ID token with default scopes</param>
        <param name="refreshToken">The refresh token (for example previously obtained from ADAL 2.x)</param>
        <summary>
            Acquires an access token from an existing refresh token and stores it and the refresh token into
            the application user token cache, where it will be available for further AcquireTokenSilentAsync calls.
            This method can be used in migration to MSAL from ADAL v2 and in various integration
            scenarios where you have a RefreshToken available.
            (see https://aka.ms/msal-net-migration-adal2-msal2)
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.Microsoft#Identity#Client#IConfidentialClientApplicationWithCertificate#AcquireTokenForClientWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenForClientWithCertificateAsync (scopes As IEnumerable(Of String)) As Task(Of AuthenticationResult) Implements IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync : seq&lt;string&gt; -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync : seq&lt;string&gt; -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync scopes" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <summary>
            [V2 API] Acquires token from the service for the confidential client using the client credentials flow. (See https://aka.ms/msal-net-client-credentials)
            This method enables application developers to achieve easy certificate roll-over
            in Azure AD: this method will send the public certificate to Azure AD
            along with the token request, so that Azure AD can use it to validate the subject name based on a trusted issuer policy.
            This saves the application admin from the need to explicitly manage the certificate rollover
            (either via portal or PowerShell/CLI operation)
            </summary>
        <returns>Authentication result containing application token for the requested scopes</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, bool forceRefresh);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, bool forceRefresh) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.Microsoft#Identity#Client#IConfidentialClientApplicationWithCertificate#AcquireTokenForClientWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenForClientWithCertificateAsync (scopes As IEnumerable(Of String), forceRefresh As Boolean) As Task(Of AuthenticationResult) Implements IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync : seq&lt;string&gt; * bool -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync : seq&lt;string&gt; * bool -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync (scopes, forceRefresh)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="forceRefresh" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="forceRefresh">If TRUE, API will ignore the access token in the cache and attempt to acquire new access token using client credentials</param>
        <summary>
            [V2 API] Acquires token from the service for the confidential client using the client credentials flow. (See https://aka.ms/msal-net-client-credentials)
            This method attempts to look up valid access token in the cache unless<paramref name="forceRefresh" /> is true
            This method enables application developers to achieve easy certificate roll-over
            in Azure AD: this method will send the public certificate to Azure AD
            along with the token request, so that Azure AD can use it to validate the subject name based on a trusted issuer policy.
            This saves the application admin from the need to explicitly manage the certificate rollover
            (either via portal or PowerShell/CLI operation)
            </summary>
        <returns>Authentication result containing application token for the requested scopes</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, Microsoft.Identity.Client.UserAssertion userAssertion);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, class Microsoft.Identity.Client.UserAssertion userAssertion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.Microsoft#Identity#Client#IConfidentialClientApplicationWithCertificate#AcquireTokenOnBehalfOfWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenOnBehalfOfWithCertificateAsync (scopes As IEnumerable(Of String), userAssertion As UserAssertion) As Task(Of AuthenticationResult) Implements IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync (scopes, userAssertion)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="userAssertion" Type="Microsoft.Identity.Client.UserAssertion" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="userAssertion">Instance of <see cref="T:Microsoft.Identity.Client.UserAssertion" /> containing credential information about
            the user on behalf of whom to get a token.</param>
        <summary>
            [V2 API] Acquires an access token for this application (usually a web API) from the authority configured in the application, in order to access
            another downstream protected web API on behalf of a user using the OAuth 2.0 On-Behalf-Of flow. (See https://aka.ms/msal-net-on-behalf-of).
            This confidential client application was itself called with a token which will be provided in the
            <paramref name="userAssertion">userAssertion</paramref> parameter.
            This override sends the certificate, which helps certificate rotation in Azure AD
            </summary>
        <returns>Authentication result containing a token for the requested scopes and account</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt; IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, Microsoft.Identity.Client.UserAssertion userAssertion, string authority);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.Identity.Client.AuthenticationResult&gt; Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, class Microsoft.Identity.Client.UserAssertion userAssertion, string authority) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.Microsoft#Identity#Client#IConfidentialClientApplicationWithCertificate#AcquireTokenOnBehalfOfWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion,System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenOnBehalfOfWithCertificateAsync (scopes As IEnumerable(Of String), userAssertion As UserAssertion, authority As String) As Task(Of AuthenticationResult) Implements IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion * string -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;&#xA;override this.Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion * string -&gt; System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;" Usage="confidentialClientApplication.Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync (scopes, userAssertion, authority)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.30.0.0</AssemblyVersion>
        <AssemblyVersion>4.30.1.0</AssemblyVersion>
        <AssemblyVersion>4.31.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.0.0</AssemblyVersion>
        <AssemblyVersion>4.32.1.0</AssemblyVersion>
        <AssemblyVersion>4.33.0.0</AssemblyVersion>
        <AssemblyVersion>4.34.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.0.0</AssemblyVersion>
        <AssemblyVersion>4.35.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.0.0</AssemblyVersion>
        <AssemblyVersion>4.36.1.0</AssemblyVersion>
        <AssemblyVersion>4.36.2.0</AssemblyVersion>
        <AssemblyVersion>4.37.0.0</AssemblyVersion>
        <AssemblyVersion>4.38.0.0</AssemblyVersion>
        <AssemblyVersion>4.39.0.0</AssemblyVersion>
        <AssemblyVersion>4.40.0.0</AssemblyVersion>
        <AssemblyVersion>4.41.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.0.0</AssemblyVersion>
        <AssemblyVersion>4.42.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.0.0</AssemblyVersion>
        <AssemblyVersion>4.43.1.0</AssemblyVersion>
        <AssemblyVersion>4.43.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.Identity.Client.AuthenticationResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="userAssertion" Type="Microsoft.Identity.Client.UserAssertion" />
        <Parameter Name="authority" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="userAssertion">Instance of <see cref="T:Microsoft.Identity.Client.UserAssertion" /> containing credential information about
            the user on behalf of whom to get a token.</param>
        <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
        <summary>
            [V2 API] Acquires an access token for this application (usually a web API) from a specific authority, in order to access
            another downstream protected web API on behalf of a user (See https://aka.ms/msal-net-on-behalf-of).
            This confidential client application was itself called with a token which will be provided in the
            This override sends the certificate, which helps certificate rotation in Azure AD
            <paramref name="userAssertion">userAssertion</paramref> parameter.
            </summary>
        <returns>Authentication result containing a token for the requested scopes and account</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
      </Docs>
    </Member>
  </Members>
</Type>
