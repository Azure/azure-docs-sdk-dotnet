<Type Name="ConfidentialLedgerClient" FullName="Azure.Security.ConfidentialLedger.ConfidentialLedgerClient">
  <TypeSignature Language="C#" Value="public class ConfidentialLedgerClient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ConfidentialLedgerClient extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient" />
  <TypeSignature Language="VB.NET" Value="Public Class ConfidentialLedgerClient" />
  <TypeSignature Language="F#" Value="type ConfidentialLedgerClient = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>1.1.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.3.0.0</AssemblyVersion>
    <AssemblyVersion>1.4.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The ConfidentialLedger service client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfidentialLedgerClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of ConfidentialLedgerClient for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConfidentialLedgerClient (Uri ledgerEndpoint, Azure.Core.TokenCredential credential);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri ledgerEndpoint, class Azure.Core.TokenCredential credential) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.#ctor(System.Uri,Azure.Core.TokenCredential)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ledgerEndpoint As Uri, credential As TokenCredential)" />
      <MemberSignature Language="F#" Value="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient : Uri * Azure.Core.TokenCredential -&gt; Azure.Security.ConfidentialLedger.ConfidentialLedgerClient" Usage="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient (ledgerEndpoint, credential)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ledgerEndpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
      </Parameters>
      <Docs>
        <param name="ledgerEndpoint"> The Confidential Ledger URL, for example https://contoso.confidentialledger.azure.com. </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <summary> Initializes a new instance of ConfidentialLedgerClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ledgerUri" /> or <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConfidentialLedgerClient (Uri ledgerEndpoint, System.Security.Cryptography.X509Certificates.X509Certificate2 clientCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri ledgerEndpoint, class System.Security.Cryptography.X509Certificates.X509Certificate2 clientCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.#ctor(System.Uri,System.Security.Cryptography.X509Certificates.X509Certificate2)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ledgerEndpoint As Uri, clientCertificate As X509Certificate2)" />
      <MemberSignature Language="F#" Value="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient : Uri * System.Security.Cryptography.X509Certificates.X509Certificate2 -&gt; Azure.Security.ConfidentialLedger.ConfidentialLedgerClient" Usage="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient (ledgerEndpoint, clientCertificate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ledgerEndpoint" Type="System.Uri" />
        <Parameter Name="clientCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" />
      </Parameters>
      <Docs>
        <param name="ledgerEndpoint"> The Confidential Ledger URL, for example https://contoso.confidentialledger.azure.com. </param>
        <param name="clientCertificate"> A <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> used to authenticate to an Azure Service. </param>
        <summary> Initializes a new instance of ConfidentialLedgerClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConfidentialLedgerClient (Uri ledgerEndpoint, Azure.Core.TokenCredential credential, Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri ledgerEndpoint, class Azure.Core.TokenCredential credential, class Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.#ctor(System.Uri,Azure.Core.TokenCredential,Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ledgerEndpoint As Uri, credential As TokenCredential, options As ConfidentialLedgerClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient : Uri * Azure.Core.TokenCredential * Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions -&gt; Azure.Security.ConfidentialLedger.ConfidentialLedgerClient" Usage="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient (ledgerEndpoint, credential, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ledgerEndpoint" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
        <Parameter Name="options" Type="Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions" />
      </Parameters>
      <Docs>
        <param name="ledgerEndpoint"> The Confidential Ledger URL, for example https://contoso.confidentialledger.azure.com. </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of ConfidentialLedgerClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConfidentialLedgerClient (Uri ledgerEndpoint, System.Security.Cryptography.X509Certificates.X509Certificate2 clientCertificate, Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri ledgerEndpoint, class System.Security.Cryptography.X509Certificates.X509Certificate2 clientCertificate, class Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.#ctor(System.Uri,System.Security.Cryptography.X509Certificates.X509Certificate2,Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ledgerEndpoint As Uri, clientCertificate As X509Certificate2, options As ConfidentialLedgerClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient : Uri * System.Security.Cryptography.X509Certificates.X509Certificate2 * Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions -&gt; Azure.Security.ConfidentialLedger.ConfidentialLedgerClient" Usage="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient (ledgerEndpoint, clientCertificate, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ledgerEndpoint" Type="System.Uri" />
        <Parameter Name="clientCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" />
        <Parameter Name="options" Type="Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions" />
      </Parameters>
      <Docs>
        <param name="ledgerEndpoint"> The Confidential Ledger URL, for example https://contoso.confidentialledger.azure.com. </param>
        <param name="clientCertificate"> A <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> used to authenticate to an Azure Service. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of ConfidentialLedgerClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateLedgerEntry (Azure.Core.RequestContent content, string collectionId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateLedgerEntry(class Azure.Core.RequestContent content, string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateLedgerEntry(Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateLedgerEntry (content As RequestContent, Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Response" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member CreateLedgerEntry : Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateLedgerEntry : Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.CreateLedgerEntry (content, collectionId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateLedgerEntry (Azure.Core.RequestContent content, string collectionId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateLedgerEntry (content As RequestContent, collectionId As String, context As RequestContext) As Response" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Writes a ledger entry.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A collection id may optionally be specified.

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>LedgerEntry</c>:
<code>{
  contents: string, # Required. Contents of the ledger entry.
  collectionId: string, # Optional.
  transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code>

Response Body:

Schema for <c>LedgerWriteResult</c>:
<code>{
  collectionId: string, # Required.
}
</code></remarks>
        <example>
This sample shows how to call CreateLedgerEntry and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    contents = "<contents>",
});
Response response = client.CreateLedgerEntry(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("collectionId").ToString());
]]></code>
This sample shows how to call CreateLedgerEntry with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    contents = "<contents>",
});
Response response = client.CreateLedgerEntry(content, collectionId: "<collectionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("collectionId").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateLedgerEntry (Azure.Core.RequestContent content, string collectionId = default, string tags = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateLedgerEntry(class Azure.Core.RequestContent content, string collectionId, string tags, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateLedgerEntry(Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateLedgerEntry (content As RequestContent, Optional collectionId As String = Nothing, Optional tags As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateLedgerEntry : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateLedgerEntry : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.CreateLedgerEntry (content, collectionId, tags, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="collectionId" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="tags" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="3" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="tags"> Comma separated tags. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Writes a ledger entry.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateLedgerEntry and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    contents = "<contents>",
});
Response response = client.CreateLedgerEntry(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("collectionId").ToString());
]]></code>
This sample shows how to call CreateLedgerEntry with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    contents = "<contents>",
    preHooks = new object[]
    {
        new
        {
            functionId = "<functionId>",
            properties = new
            {
                arguments = new object[]
                {
                    "<arguments>"
                },
                exportedFunctionName = "<exportedFunctionName>",
                runtimeOptions = new
                {
                    log_exception_details = true,
                    max_cached_interpreters = 1234L,
                    max_execution_time_ms = 1234L,
                    max_heap_bytes = 1234L,
                    max_stack_bytes = 1234L,
                    return_exception_details = true,
                },
            },
        }
    },
    postHooks = new object[]
    {
        null
    },
});
Response response = client.CreateLedgerEntry(content, collectionId: "<collectionId>", tags: "<tags>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("collectionId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateLedgerEntryAsync (Azure.Core.RequestContent content, string collectionId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateLedgerEntryAsync(class Azure.Core.RequestContent content, string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateLedgerEntryAsync(Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateLedgerEntryAsync (content As RequestContent, Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member CreateLedgerEntryAsync : Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateLedgerEntryAsync : Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.CreateLedgerEntryAsync (content, collectionId, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateLedgerEntryAsync (Azure.Core.RequestContent content, string collectionId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateLedgerEntryAsync (content As RequestContent, collectionId As String, context As RequestContext) As Task(Of Response)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Writes a ledger entry.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A collection id may optionally be specified.

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>LedgerEntry</c>:
<code>{
  contents: string, # Required. Contents of the ledger entry.
  collectionId: string, # Optional.
  transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code>

Response Body:

Schema for <c>LedgerWriteResult</c>:
<code>{
  collectionId: string, # Required.
}
</code></remarks>
        <example>
This sample shows how to call CreateLedgerEntryAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    contents = "<contents>",
});
Response response = await client.CreateLedgerEntryAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("collectionId").ToString());
]]></code>
This sample shows how to call CreateLedgerEntryAsync with all parameters and request content and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(endpoint, credential);

using RequestContent content = RequestContent.Create(new
{
    contents = "<contents>",
});
Response response = await client.CreateLedgerEntryAsync(content, collectionId: "<collectionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("collectionId").ToString());
]]></code></example>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateLedgerEntryAsync (Azure.Core.RequestContent content, string collectionId = default, string tags = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateLedgerEntryAsync(class Azure.Core.RequestContent content, string collectionId, string tags, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateLedgerEntryAsync(Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateLedgerEntryAsync (content As RequestContent, Optional collectionId As String = Nothing, Optional tags As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateLedgerEntryAsync : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateLedgerEntryAsync : Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.CreateLedgerEntryAsync (content, collectionId, tags, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="collectionId" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="tags" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="3" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="tags"> Comma separated tags. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Writes a ledger entry.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateLedgerEntryAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    contents = "<contents>",
});
Response response = await client.CreateLedgerEntryAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("collectionId").ToString());
]]></code>
This sample shows how to call CreateLedgerEntryAsync with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    contents = "<contents>",
    preHooks = new object[]
    {
        new
        {
            functionId = "<functionId>",
            properties = new
            {
                arguments = new object[]
                {
                    "<arguments>"
                },
                exportedFunctionName = "<exportedFunctionName>",
                runtimeOptions = new
                {
                    log_exception_details = true,
                    max_cached_interpreters = 1234L,
                    max_execution_time_ms = 1234L,
                    max_heap_bytes = 1234L,
                    max_stack_bytes = 1234L,
                    return_exception_details = true,
                },
            },
        }
    },
    postHooks = new object[]
    {
        null
    },
});
Response response = await client.CreateLedgerEntryAsync(content, collectionId: "<collectionId>", tags: "<tags>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("collectionId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateLedgerUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateLedgerUser (string userId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateLedgerUser(string userId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateOrUpdateLedgerUser(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateLedgerUser (userId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateLedgerUser : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateLedgerUser : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.CreateOrUpdateLedgerUser (userId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Adds a user or updates a user's fields.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateLedgerUser and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    assignedRoles = new object[]
    {
        "Administrator"
    },
});
Response response = client.CreateOrUpdateLedgerUser("<userId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
]]></code>
This sample shows how to call CreateOrUpdateLedgerUser with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    assignedRoles = new object[]
    {
        "Administrator"
    },
});
Response response = client.CreateOrUpdateLedgerUser("<userId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
Console.WriteLine(result.GetProperty("userId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateLedgerUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateLedgerUserAsync (string userId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateLedgerUserAsync(string userId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateOrUpdateLedgerUserAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateLedgerUserAsync (userId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateLedgerUserAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateLedgerUserAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.CreateOrUpdateLedgerUserAsync (userId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Adds a user or updates a user's fields.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateLedgerUserAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    assignedRoles = new object[]
    {
        "Administrator"
    },
});
Response response = await client.CreateOrUpdateLedgerUserAsync("<userId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
]]></code>
This sample shows how to call CreateOrUpdateLedgerUserAsync with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    assignedRoles = new object[]
    {
        "Administrator"
    },
});
Response response = await client.CreateOrUpdateLedgerUserAsync("<userId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
Console.WriteLine(result.GetProperty("userId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateUser (string userId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateUser(string userId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateOrUpdateUser(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateUser (userId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateUser : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateUser : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.CreateOrUpdateUser (userId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Adds a user or updates a user's fields.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A JSON merge patch is applied for existing users

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>LedgerUser</c>:
<code>{
  assignedRole: "Administrator" | "Contributor" | "Reader", # Required. Represents an assignable role.
  userId: string, # Optional. Identifier for the user. This must either be an AAD object id or a certificate fingerprint.
}
</code>

Response Body:

Schema for <c>LedgerUser</c>:
<code>{
  assignedRole: "Administrator" | "Contributor" | "Reader", # Required. Represents an assignable role.
  userId: string, # Optional. Identifier for the user. This must either be an AAD object id or a certificate fingerprint.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateUser and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    assignedRole = "Administrator",
});
Response response = client.CreateOrUpdateUser("<userId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRole").ToString());
]]></code>
This sample shows how to call CreateOrUpdateUser with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    assignedRole = "Administrator",
});
Response response = client.CreateOrUpdateUser("<userId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRole").ToString());
Console.WriteLine(result.GetProperty("userId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateUserAsync (string userId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateUserAsync(string userId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateOrUpdateUserAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateUserAsync (userId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateUserAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateUserAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.CreateOrUpdateUserAsync (userId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Adds a user or updates a user's fields.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A JSON merge patch is applied for existing users

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>LedgerUser</c>:
<code>{
  assignedRole: "Administrator" | "Contributor" | "Reader", # Required. Represents an assignable role.
  userId: string, # Optional. Identifier for the user. This must either be an AAD object id or a certificate fingerprint.
}
</code>

Response Body:

Schema for <c>LedgerUser</c>:
<code>{
  assignedRole: "Administrator" | "Contributor" | "Reader", # Required. Represents an assignable role.
  userId: string, # Optional. Identifier for the user. This must either be an AAD object id or a certificate fingerprint.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateOrUpdateUserAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    assignedRole = "Administrator",
});
Response response = await client.CreateOrUpdateUserAsync("<userId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRole").ToString());
]]></code>
This sample shows how to call CreateOrUpdateUserAsync with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    assignedRole = "Administrator",
});
Response response = await client.CreateOrUpdateUserAsync("<userId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRole").ToString());
Console.WriteLine(result.GetProperty("userId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateUserDefinedEndpoint">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateUserDefinedEndpoint (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateUserDefinedEndpoint(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateUserDefinedEndpoint(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUserDefinedEndpoint (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateUserDefinedEndpoint : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateUserDefinedEndpoint : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.CreateUserDefinedEndpoint (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a user defined endpoint.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateUserDefinedEndpoint.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    metadata = new
    {
        endpoints = new
        {
            key = new object(),
        },
    },
    modules = new object(),
});
Response response = client.CreateUserDefinedEndpoint(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateUserDefinedEndpoint with all request content.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    metadata = new
    {
        endpoints = new
        {
            key = new
            {
                get = new
                {
                    authn_policies = new object[]
                    {
                        new object()
                    },
                    forwarding_required = "sometimes",
                    interpreter_reuse = new
                    {
                        key = "<key>",
                    },
                    js_function = "<js_function>",
                    js_module = "<js_module>",
                    mode = "readwrite",
                    openapi = new object(),
                    openapi_hidden = true,
                    redirection_strategy = "none",
                },
            },
        },
    },
    modules = new object(),
});
Response response = client.CreateUserDefinedEndpoint(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateUserDefinedEndpointAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateUserDefinedEndpointAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateUserDefinedEndpointAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateUserDefinedEndpointAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUserDefinedEndpointAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateUserDefinedEndpointAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateUserDefinedEndpointAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.CreateUserDefinedEndpointAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a user defined endpoint.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateUserDefinedEndpointAsync.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    metadata = new
    {
        endpoints = new
        {
            key = new object(),
        },
    },
    modules = new object(),
});
Response response = await client.CreateUserDefinedEndpointAsync(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateUserDefinedEndpointAsync with all request content.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    metadata = new
    {
        endpoints = new
        {
            key = new
            {
                get = new
                {
                    authn_policies = new object[]
                    {
                        new object()
                    },
                    forwarding_required = "sometimes",
                    interpreter_reuse = new
                    {
                        key = "<key>",
                    },
                    js_function = "<js_function>",
                    js_module = "<js_module>",
                    mode = "readwrite",
                    openapi = new object(),
                    openapi_hidden = true,
                    redirection_strategy = "none",
                },
            },
        },
    },
    modules = new object(),
});
Response response = await client.CreateUserDefinedEndpointAsync(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateUserDefinedFunction">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateUserDefinedFunction (string functionId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateUserDefinedFunction(string functionId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateUserDefinedFunction(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUserDefinedFunction (functionId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateUserDefinedFunction : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateUserDefinedFunction : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.CreateUserDefinedFunction (functionId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="functionId"> Identifies a user defined function. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a user defined function.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateUserDefinedFunction and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    code = "<code>",
});
Response response = client.CreateUserDefinedFunction("<functionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("code").ToString());
]]></code>
This sample shows how to call CreateUserDefinedFunction with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    code = "<code>",
});
Response response = client.CreateUserDefinedFunction("<functionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateUserDefinedFunctionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateUserDefinedFunctionAsync (string functionId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateUserDefinedFunctionAsync(string functionId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateUserDefinedFunctionAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUserDefinedFunctionAsync (functionId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateUserDefinedFunctionAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateUserDefinedFunctionAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.CreateUserDefinedFunctionAsync (functionId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="functionId"> Identifies a user defined function. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates a user defined function.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateUserDefinedFunctionAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    code = "<code>",
});
Response response = await client.CreateUserDefinedFunctionAsync("<functionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("code").ToString());
]]></code>
This sample shows how to call CreateUserDefinedFunctionAsync with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    code = "<code>",
});
Response response = await client.CreateUserDefinedFunctionAsync("<functionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateUserDefinedRole">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateUserDefinedRole (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateUserDefinedRole(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateUserDefinedRole(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUserDefinedRole (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateUserDefinedRole : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateUserDefinedRole : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.CreateUserDefinedRole (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates new roles and their actions
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateUserDefinedRole.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = client.CreateUserDefinedRole(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateUserDefinedRole with all request content.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        roleName = "<roleName>",
        roleActions = new object[]
        {
            "<roleActions>"
        },
    }
});
Response response = client.CreateUserDefinedRole(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="CreateUserDefinedRoleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateUserDefinedRoleAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateUserDefinedRoleAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateUserDefinedRoleAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateUserDefinedRoleAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateUserDefinedRoleAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateUserDefinedRoleAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.CreateUserDefinedRoleAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Creates new roles and their actions
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call CreateUserDefinedRoleAsync.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = await client.CreateUserDefinedRoleAsync(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call CreateUserDefinedRoleAsync with all request content.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        roleName = "<roleName>",
        roleActions = new object[]
        {
            "<roleActions>"
        },
    }
});
Response response = await client.CreateUserDefinedRoleAsync(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteLedgerUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteLedgerUser (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteLedgerUser(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteLedgerUser(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteLedgerUser (userId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteLedgerUser : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteLedgerUser : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.DeleteLedgerUser (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a user with multiple roles from the Confidential Ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteLedgerUser.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.DeleteLedgerUser("<userId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteLedgerUser with all parameters.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.DeleteLedgerUser("<userId>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteLedgerUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteLedgerUserAsync (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteLedgerUserAsync(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteLedgerUserAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteLedgerUserAsync (userId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteLedgerUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteLedgerUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.DeleteLedgerUserAsync (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a user with multiple roles from the Confidential Ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteLedgerUserAsync.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.DeleteLedgerUserAsync("<userId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteLedgerUserAsync with all parameters.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.DeleteLedgerUserAsync("<userId>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteUser (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteUser(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteUser(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteUser (userId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteUser : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteUser : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.DeleteUser (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a user from the Confidential Ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteUser.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.DeleteUser("<userId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteUser with all parameters.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.DeleteUser("<userId>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteUserAsync (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteUserAsync(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteUserAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteUserAsync (userId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.DeleteUserAsync (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a user from the Confidential Ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteUserAsync.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.DeleteUserAsync("<userId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteUserAsync with all parameters.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.DeleteUserAsync("<userId>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteUserDefinedFunction">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteUserDefinedFunction (string functionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteUserDefinedFunction(string functionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteUserDefinedFunction(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteUserDefinedFunction (functionId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteUserDefinedFunction : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteUserDefinedFunction : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.DeleteUserDefinedFunction (functionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="functionId"> Identifies a user defined function. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a user defined function from the Confidential Ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteUserDefinedFunction.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.DeleteUserDefinedFunction("<functionId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteUserDefinedFunction with all parameters.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.DeleteUserDefinedFunction("<functionId>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteUserDefinedFunctionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteUserDefinedFunctionAsync (string functionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteUserDefinedFunctionAsync(string functionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteUserDefinedFunctionAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteUserDefinedFunctionAsync (functionId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteUserDefinedFunctionAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteUserDefinedFunctionAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.DeleteUserDefinedFunctionAsync (functionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="functionId"> Identifies a user defined function. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes a user defined function from the Confidential Ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteUserDefinedFunctionAsync.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.DeleteUserDefinedFunctionAsync("<functionId>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteUserDefinedFunctionAsync with all parameters.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.DeleteUserDefinedFunctionAsync("<functionId>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteUserDefinedRole">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteUserDefinedRole (string roleName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteUserDefinedRole(string roleName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteUserDefinedRole(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteUserDefinedRole (roleName As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteUserDefinedRole : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteUserDefinedRole : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.DeleteUserDefinedRole (roleName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="roleName"> user defined role name. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes user defined roles
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteUserDefinedRole.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.DeleteUserDefinedRole("<roleName>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteUserDefinedRole with all parameters.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.DeleteUserDefinedRole("<roleName>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="DeleteUserDefinedRoleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteUserDefinedRoleAsync (string roleName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteUserDefinedRoleAsync(string roleName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteUserDefinedRoleAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteUserDefinedRoleAsync (roleName As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteUserDefinedRoleAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteUserDefinedRoleAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.DeleteUserDefinedRoleAsync (roleName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="roleName"> user defined role name. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Deletes user defined roles
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call DeleteUserDefinedRoleAsync.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.DeleteUserDefinedRoleAsync("<roleName>");

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteUserDefinedRoleAsync with all parameters.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.DeleteUserDefinedRoleAsync("<roleName>");

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ExecuteUserDefinedFunction">
      <MemberSignature Language="C#" Value="public virtual Azure.Response ExecuteUserDefinedFunction (string functionId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response ExecuteUserDefinedFunction(string functionId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.ExecuteUserDefinedFunction(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExecuteUserDefinedFunction (functionId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member ExecuteUserDefinedFunction : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.ExecuteUserDefinedFunction : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.ExecuteUserDefinedFunction (functionId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="functionId"> Identifies a user defined function. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Executes a user defined function.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ExecuteUserDefinedFunction and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = null;
Response response = client.ExecuteUserDefinedFunction("<functionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("status").ToString());
]]></code>
This sample shows how to call ExecuteUserDefinedFunction with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    arguments = new object[]
    {
        "<arguments>"
    },
    exportedFunctionName = "<exportedFunctionName>",
    runtimeOptions = new
    {
        log_exception_details = true,
        max_cached_interpreters = 1234L,
        max_execution_time_ms = 1234L,
        max_heap_bytes = 1234L,
        max_stack_bytes = 1234L,
        return_exception_details = true,
    },
});
Response response = client.ExecuteUserDefinedFunction("<functionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("result").GetProperty("returnValue").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="ExecuteUserDefinedFunctionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; ExecuteUserDefinedFunctionAsync (string functionId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; ExecuteUserDefinedFunctionAsync(string functionId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.ExecuteUserDefinedFunctionAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExecuteUserDefinedFunctionAsync (functionId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member ExecuteUserDefinedFunctionAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.ExecuteUserDefinedFunctionAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.ExecuteUserDefinedFunctionAsync (functionId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="2" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="functionId"> Identifies a user defined function. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Executes a user defined function.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call ExecuteUserDefinedFunctionAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = null;
Response response = await client.ExecuteUserDefinedFunctionAsync("<functionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("status").ToString());
]]></code>
This sample shows how to call ExecuteUserDefinedFunctionAsync with all parameters and request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    arguments = new object[]
    {
        "<arguments>"
    },
    exportedFunctionName = "<exportedFunctionName>",
    runtimeOptions = new
    {
        log_exception_details = true,
        max_cached_interpreters = 1234L,
        max_execution_time_ms = 1234L,
        max_heap_bytes = 1234L,
        max_stack_bytes = 1234L,
        return_exception_details = true,
    },
});
Response response = await client.ExecuteUserDefinedFunctionAsync("<functionId>", content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
Console.WriteLine(result.GetProperty("result").GetProperty("returnValue").ToString());
Console.WriteLine(result.GetProperty("status").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetCollections">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetCollections (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetCollections(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetCollections(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCollections (Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetCollections : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetCollections : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetCollections context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Retrieves a list of collection ids present in the Confidential Ledger
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>
Collection ids are user-created collections of ledger entries

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>PagedCollections</c>:
<code>{
  collectionId: string, # Required.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetCollections and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetCollections())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("collectionId").ToString());
}
]]></code>
This sample shows how to call GetCollections with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetCollections())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("collectionId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetCollectionsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetCollectionsAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetCollectionsAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetCollectionsAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCollectionsAsync (Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetCollectionsAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetCollectionsAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetCollectionsAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Retrieves a list of collection ids present in the Confidential Ledger
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>
Collection ids are user-created collections of ledger entries

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>PagedCollections</c>:
<code>{
  collectionId: string, # Required.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetCollectionsAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetCollectionsAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("collectionId").ToString());
}
]]></code>
This sample shows how to call GetCollectionsAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetCollectionsAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("collectionId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetConsortiumMembers">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetConsortiumMembers (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetConsortiumMembers(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetConsortiumMembers(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConsortiumMembers (Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetConsortiumMembers : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetConsortiumMembers : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetConsortiumMembers context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the consortium members.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>
Consortium members can manage the Confidential Ledger.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>ConsortiumMembers</c>:
<code>{
  certificate: string, # Required. PEM-encoded certificate associated with the member.
  id: string, # Required. Identifier assigned to the member.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetConsortiumMembers and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetConsortiumMembers())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("certificate").ToString());
    Console.WriteLine(result.GetProperty("id").ToString());
}
]]></code>
This sample shows how to call GetConsortiumMembers with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetConsortiumMembers())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("certificate").ToString());
    Console.WriteLine(result.GetProperty("id").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetConsortiumMembersAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetConsortiumMembersAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetConsortiumMembersAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetConsortiumMembersAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConsortiumMembersAsync (Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetConsortiumMembersAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetConsortiumMembersAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetConsortiumMembersAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Lists the consortium members.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>
Consortium members can manage the Confidential Ledger.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>ConsortiumMembers</c>:
<code>{
  certificate: string, # Required. PEM-encoded certificate associated with the member.
  id: string, # Required. Identifier assigned to the member.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetConsortiumMembersAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetConsortiumMembersAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("certificate").ToString());
    Console.WriteLine(result.GetProperty("id").ToString());
}
]]></code>
This sample shows how to call GetConsortiumMembersAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetConsortiumMembersAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("certificate").ToString());
    Console.WriteLine(result.GetProperty("id").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetConstitution">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetConstitution (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetConstitution(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetConstitution(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConstitution (Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetConstitution : Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetConstitution : Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetConstitution context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the constitution used for governance.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
The constitution is a script that assesses and applies proposals from consortium members.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>Constitution</c>:
<code>{
  digest: string, # Required. SHA256 digest of the constitution script.
  script: string, # Required. Contents of the constitution.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetConstitution and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetConstitution();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("digest").ToString());
Console.WriteLine(result.GetProperty("script").ToString());
]]></code>
This sample shows how to call GetConstitution with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetConstitution();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("digest").ToString());
Console.WriteLine(result.GetProperty("script").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetConstitutionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetConstitutionAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetConstitutionAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetConstitutionAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConstitutionAsync (Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetConstitutionAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetConstitutionAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetConstitutionAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the constitution used for governance.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
The constitution is a script that assesses and applies proposals from consortium members.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>Constitution</c>:
<code>{
  digest: string, # Required. SHA256 digest of the constitution script.
  script: string, # Required. Contents of the constitution.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetConstitutionAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetConstitutionAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("digest").ToString());
Console.WriteLine(result.GetProperty("script").ToString());
]]></code>
This sample shows how to call GetConstitutionAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetConstitutionAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("digest").ToString());
Console.WriteLine(result.GetProperty("script").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetCurrentLedgerEntry (string collectionId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetCurrentLedgerEntry(string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetCurrentLedgerEntry(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCurrentLedgerEntry (Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentLedgerEntry : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetCurrentLedgerEntry : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetCurrentLedgerEntry (collectionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection id. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the current value available in the ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A collection id may optionally be specified.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>LedgerEntry</c>:
<code>{
  contents: string, # Required. Contents of the ledger entry.
  collectionId: string, # Optional.
  transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetCurrentLedgerEntry and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetCurrentLedgerEntry();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("contents").ToString());
]]></code>
This sample shows how to call GetCurrentLedgerEntry with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetCurrentLedgerEntry(collectionId: "<collectionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("contents").ToString());
Console.WriteLine(result.GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("functionId").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("functionId").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetCurrentLedgerEntryAsync (string collectionId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetCurrentLedgerEntryAsync(string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetCurrentLedgerEntryAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCurrentLedgerEntryAsync (Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentLedgerEntryAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetCurrentLedgerEntryAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetCurrentLedgerEntryAsync (collectionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection id. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the current value available in the ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A collection id may optionally be specified.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>LedgerEntry</c>:
<code>{
  contents: string, # Required. Contents of the ledger entry.
  collectionId: string, # Optional.
  transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetCurrentLedgerEntryAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetCurrentLedgerEntryAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("contents").ToString());
]]></code>
This sample shows how to call GetCurrentLedgerEntryAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetCurrentLedgerEntryAsync(collectionId: "<collectionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("contents").ToString());
Console.WriteLine(result.GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("functionId").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("functionId").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnclaveQuotes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetEnclaveQuotes (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetEnclaveQuotes(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetEnclaveQuotes(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnclaveQuotes (Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetEnclaveQuotes : Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetEnclaveQuotes : Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetEnclaveQuotes context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets quotes for all nodes of the Confidential Ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A quote is an SGX enclave measurement that can be used to verify the validity of a node and its enclave.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>ConfidentialLedgerEnclaves</c>:
<code>{
  currentNodeId: string, # Required. Id of the Confidential Ledger node responding to the request.
  enclaveQuotes: Dictionary&lt;string, EnclaveQuote&gt;, # Required. Dictionary of enclave quotes, indexed by node id.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEnclaveQuotes and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetEnclaveQuotes();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("currentNodeId").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("nodeId").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("quoteVersion").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("raw").ToString());
]]></code>
This sample shows how to call GetEnclaveQuotes with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetEnclaveQuotes();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("currentNodeId").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("nodeId").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("mrenclave").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("quoteVersion").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("raw").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetEnclaveQuotesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetEnclaveQuotesAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetEnclaveQuotesAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetEnclaveQuotesAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnclaveQuotesAsync (Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetEnclaveQuotesAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetEnclaveQuotesAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetEnclaveQuotesAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets quotes for all nodes of the Confidential Ledger.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A quote is an SGX enclave measurement that can be used to verify the validity of a node and its enclave.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>ConfidentialLedgerEnclaves</c>:
<code>{
  currentNodeId: string, # Required. Id of the Confidential Ledger node responding to the request.
  enclaveQuotes: Dictionary&lt;string, EnclaveQuote&gt;, # Required. Dictionary of enclave quotes, indexed by node id.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetEnclaveQuotesAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetEnclaveQuotesAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("currentNodeId").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("nodeId").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("quoteVersion").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("raw").ToString());
]]></code>
This sample shows how to call GetEnclaveQuotesAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetEnclaveQuotesAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("currentNodeId").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("nodeId").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("mrenclave").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("quoteVersion").ToString());
Console.WriteLine(result.GetProperty("enclaveQuotes").GetProperty("<key>").GetProperty("raw").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntries">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetLedgerEntries (string collectionId = default, string fromTransactionId = default, string toTransactionId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetLedgerEntries(string collectionId, string fromTransactionId, string toTransactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntries(System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntries (Optional collectionId As String = Nothing, Optional fromTransactionId As String = Nothing, Optional toTransactionId As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntries : string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetLedgerEntries : string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetLedgerEntries (collectionId, fromTransactionId, toTransactionId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetLedgerEntries (string collectionId, string fromTransactionId, string toTransactionId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntries (collectionId As String, fromTransactionId As String, toTransactionId As String, context As RequestContext) As Pageable(Of BinaryData)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="fromTransactionId" Type="System.String" />
        <Parameter Name="toTransactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection id. </param>
        <param name="fromTransactionId"> The from transaction id. </param>
        <param name="toTransactionId"> The to transaction id. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets all ledger entries.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A collection id may optionally be specified. Only entries in the specified (or default) collection will be returned.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>LedgerEntries</c>:
<code>{
  contents: string, # Required. Contents of the ledger entry.
  collectionId: string, # Optional.
  transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code></remarks>
        <example>
This sample shows how to call GetLedgerEntries and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(endpoint, credential);

foreach (BinaryData item in client.GetLedgerEntries())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("contents").ToString());
}
]]></code>
This sample shows how to call GetLedgerEntries with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(endpoint, credential);

foreach (BinaryData item in client.GetLedgerEntries(collectionId: "<collectionId>", fromTransactionId: "<fromTransactionId>", toTransactionId: "<toTransactionId>"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("contents").ToString());
    Console.WriteLine(result.GetProperty("collectionId").ToString());
    Console.WriteLine(result.GetProperty("transactionId").ToString());
}
]]></code></example>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntries">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetLedgerEntries (string collectionId = default, string fromTransactionId = default, string toTransactionId = default, string tag = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetLedgerEntries(string collectionId, string fromTransactionId, string toTransactionId, string tag, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntries(System.String,System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntries (Optional collectionId As String = Nothing, Optional fromTransactionId As String = Nothing, Optional toTransactionId As String = Nothing, Optional tag As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntries : string * string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetLedgerEntries : string * string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetLedgerEntries (collectionId, fromTransactionId, toTransactionId, tag, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="fromTransactionId" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="toTransactionId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="tag" Type="System.String" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="4" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection id. </param>
        <param name="fromTransactionId"> Specify the first transaction ID in a range. </param>
        <param name="toTransactionId"> Specify the last transaction ID in a range. </param>
        <param name="tag"> Single tag. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets ledger entries from a collection corresponding to a range.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerEntries and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetLedgerEntries())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("contents").ToString());
}
]]></code>
This sample shows how to call GetLedgerEntries with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetLedgerEntries(collectionId: "<collectionId>", fromTransactionId: "<fromTransactionId>", toTransactionId: "<toTransactionId>", tag: "<tag>"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("contents").ToString());
    Console.WriteLine(result.GetProperty("collectionId").ToString());
    Console.WriteLine(result.GetProperty("transactionId").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("functionId").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("functionId").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntriesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetLedgerEntriesAsync (string collectionId = default, string fromTransactionId = default, string toTransactionId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetLedgerEntriesAsync(string collectionId, string fromTransactionId, string toTransactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntriesAsync(System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntriesAsync (Optional collectionId As String = Nothing, Optional fromTransactionId As String = Nothing, Optional toTransactionId As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntriesAsync : string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetLedgerEntriesAsync : string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetLedgerEntriesAsync (collectionId, fromTransactionId, toTransactionId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetLedgerEntriesAsync (string collectionId, string fromTransactionId, string toTransactionId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntriesAsync (collectionId As String, fromTransactionId As String, toTransactionId As String, context As RequestContext) As AsyncPageable(Of BinaryData)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="fromTransactionId" Type="System.String" />
        <Parameter Name="toTransactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection id. </param>
        <param name="fromTransactionId"> The from transaction id. </param>
        <param name="toTransactionId"> The to transaction id. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets all ledger entries.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
A collection id may optionally be specified. Only entries in the specified (or default) collection will be returned.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>LedgerEntries</c>:
<code>{
  contents: string, # Required. Contents of the ledger entry.
  collectionId: string, # Optional.
  transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code></remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerEntriesAsync and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(endpoint, credential);

await foreach (BinaryData item in client.GetLedgerEntriesAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("contents").ToString());
}
]]></code>
This sample shows how to call GetLedgerEntriesAsync with all parameters and parse the result.
<code><![CDATA[
Uri endpoint = new Uri("<endpoint>");
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(endpoint, credential);

await foreach (BinaryData item in client.GetLedgerEntriesAsync(collectionId: "<collectionId>", fromTransactionId: "<fromTransactionId>", toTransactionId: "<toTransactionId>"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("contents").ToString());
    Console.WriteLine(result.GetProperty("collectionId").ToString());
    Console.WriteLine(result.GetProperty("transactionId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntriesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetLedgerEntriesAsync (string collectionId = default, string fromTransactionId = default, string toTransactionId = default, string tag = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetLedgerEntriesAsync(string collectionId, string fromTransactionId, string toTransactionId, string tag, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntriesAsync(System.String,System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntriesAsync (Optional collectionId As String = Nothing, Optional fromTransactionId As String = Nothing, Optional toTransactionId As String = Nothing, Optional tag As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntriesAsync : string * string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetLedgerEntriesAsync : string * string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetLedgerEntriesAsync (collectionId, fromTransactionId, toTransactionId, tag, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="fromTransactionId" Type="System.String" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="toTransactionId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="tag" Type="System.String" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="4" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="collectionId"> The collection id. </param>
        <param name="fromTransactionId"> Specify the first transaction ID in a range. </param>
        <param name="toTransactionId"> Specify the last transaction ID in a range. </param>
        <param name="tag"> Single tag. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets ledger entries from a collection corresponding to a range.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerEntriesAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetLedgerEntriesAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("contents").ToString());
}
]]></code>
This sample shows how to call GetLedgerEntriesAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetLedgerEntriesAsync(collectionId: "<collectionId>", fromTransactionId: "<fromTransactionId>", toTransactionId: "<toTransactionId>", tag: "<tag>"))
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("contents").ToString());
    Console.WriteLine(result.GetProperty("collectionId").ToString());
    Console.WriteLine(result.GetProperty("transactionId").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("functionId").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
    Console.WriteLine(result.GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("functionId").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
    Console.WriteLine(result.GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetLedgerEntry (string transactionId, string collectionId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetLedgerEntry(string transactionId, string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntry(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntry (transactionId As String, Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntry : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetLedgerEntry : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetLedgerEntry (transactionId, collectionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the ledger entry at the specified transaction id. A collection id may optionally be specified to indicate the collection from which to fetch the value.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
To return older ledger entries, the relevant sections of the ledger must be read from disk and validated. To prevent blocking within the enclave, the response will indicate whether the entry is ready and part of the response, or if the loading is still ongoing.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>LedgerQueryResult</c>:
<code>{
  state: "Loading" | "Ready", # Required. State of a ledger query.
  entry: {
    contents: string, # Required. Contents of the ledger entry.
    collectionId: string, # Optional.
    transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
  }, # Optional. The ledger entry found as a result of the query. This is only available if the query is in Ready state.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerEntry and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetLedgerEntry("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
]]></code>
This sample shows how to call GetLedgerEntry with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetLedgerEntry("<transactionId>", collectionId: "<collectionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("contents").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("transactionId").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("functionId").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("functionId").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetLedgerEntryAsync (string transactionId, string collectionId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetLedgerEntryAsync(string transactionId, string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntryAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntryAsync (transactionId As String, Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntryAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetLedgerEntryAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetLedgerEntryAsync (transactionId, collectionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the ledger entry at the specified transaction id. A collection id may optionally be specified to indicate the collection from which to fetch the value.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
To return older ledger entries, the relevant sections of the ledger must be read from disk and validated. To prevent blocking within the enclave, the response will indicate whether the entry is ready and part of the response, or if the loading is still ongoing.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>LedgerQueryResult</c>:
<code>{
  state: "Loading" | "Ready", # Required. State of a ledger query.
  entry: {
    contents: string, # Required. Contents of the ledger entry.
    collectionId: string, # Optional.
    transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
  }, # Optional. The ledger entry found as a result of the query. This is only available if the query is in Ready state.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerEntryAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetLedgerEntryAsync("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
]]></code>
This sample shows how to call GetLedgerEntryAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetLedgerEntryAsync("<transactionId>", collectionId: "<collectionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("contents").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("transactionId").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("functionId").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("preHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("functionId").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("arguments")[0].ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("exportedFunctionName").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("entry").GetProperty("postHooks")[0].GetProperty("properties").GetProperty("runtimeOptions").GetProperty("return_exception_details").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetLedgerUser (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetLedgerUser(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerUser(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerUser (userId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerUser : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetLedgerUser : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetLedgerUser (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a user with multiple roles.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerUser and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetLedgerUser("<userId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
]]></code>
This sample shows how to call GetLedgerUser with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetLedgerUser("<userId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
Console.WriteLine(result.GetProperty("userId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetLedgerUserAsync (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetLedgerUserAsync(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerUserAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerUserAsync (userId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetLedgerUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetLedgerUserAsync (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a user with multiple roles.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerUserAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetLedgerUserAsync("<userId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
]]></code>
This sample shows how to call GetLedgerUserAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetLedgerUserAsync("<userId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
Console.WriteLine(result.GetProperty("userId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerUsers">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetLedgerUsers (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetLedgerUsers(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerUsers(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerUsers (Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerUsers : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetLedgerUsers : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetLedgerUsers context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets details on a list of users.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerUsers and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetLedgerUsers())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
}
]]></code>
This sample shows how to call GetLedgerUsers with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetLedgerUsers())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
    Console.WriteLine(result.GetProperty("userId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerUsersAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetLedgerUsersAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetLedgerUsersAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerUsersAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerUsersAsync (Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerUsersAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetLedgerUsersAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetLedgerUsersAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets details on a list of users.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetLedgerUsersAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetLedgerUsersAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
}
]]></code>
This sample shows how to call GetLedgerUsersAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetLedgerUsersAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("assignedRoles")[0].ToString());
    Console.WriteLine(result.GetProperty("userId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetReceipt">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetReceipt (string transactionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetReceipt(string transactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetReceipt(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReceipt (transactionId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetReceipt : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetReceipt : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetReceipt (transactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a receipt certifying ledger contents at a particular transaction id.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TransactionReceipt</c>:
<code>{
  receipt: {
    cert: string, # Optional.
    leaf: string, # Optional.
    leafComponents: {
      claimsDigest: string, # Optional.
      commitEvidence: string, # Optional.
      writeSetDigest: string, # Optional.
    }, # Optional.
    nodeId: string, # Required.
    proof: [
      {
        left: string, # Optional.
        right: string, # Optional.
      }
    ], # Required.
    root: string, # Optional.
    serviceEndorsements: [string], # Optional.
    signature: string, # Required.
  }, # Optional.
  state: "Loading" | "Ready", # Required. State of a ledger query.
  transactionId: string, # Required. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetReceipt and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetReceipt("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
]]></code>
This sample shows how to call GetReceipt with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetReceipt("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("digest").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("digest").GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("ledgerEntry").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("ledgerEntry").GetProperty("contents").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("ledgerEntry").GetProperty("secretKey").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("ledgerEntry").GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("cert").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("leaf").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("leafComponents").GetProperty("claimsDigest").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("leafComponents").GetProperty("commitEvidence").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("leafComponents").GetProperty("writeSetDigest").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("nodeId").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("proof")[0].GetProperty("left").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("proof")[0].GetProperty("right").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("root").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("serviceEndorsements")[0].ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("signature").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetReceiptAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetReceiptAsync (string transactionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetReceiptAsync(string transactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetReceiptAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReceiptAsync (transactionId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetReceiptAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetReceiptAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetReceiptAsync (transactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a receipt certifying ledger contents at a particular transaction id.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TransactionReceipt</c>:
<code>{
  receipt: {
    cert: string, # Optional.
    leaf: string, # Optional.
    leafComponents: {
      claimsDigest: string, # Optional.
      commitEvidence: string, # Optional.
      writeSetDigest: string, # Optional.
    }, # Optional.
    nodeId: string, # Required.
    proof: [
      {
        left: string, # Optional.
        right: string, # Optional.
      }
    ], # Required.
    root: string, # Optional.
    serviceEndorsements: [string], # Optional.
    signature: string, # Required.
  }, # Optional.
  state: "Loading" | "Ready", # Required. State of a ledger query.
  transactionId: string, # Required. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetReceiptAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetReceiptAsync("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
]]></code>
This sample shows how to call GetReceiptAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetReceiptAsync("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("digest").GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("digest").GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("kind").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("ledgerEntry").GetProperty("collectionId").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("ledgerEntry").GetProperty("contents").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("ledgerEntry").GetProperty("secretKey").ToString());
Console.WriteLine(result.GetProperty("applicationClaims")[0].GetProperty("ledgerEntry").GetProperty("protocol").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("cert").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("leaf").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("leafComponents").GetProperty("claimsDigest").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("leafComponents").GetProperty("commitEvidence").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("leafComponents").GetProperty("writeSetDigest").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("nodeId").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("proof")[0].GetProperty("left").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("proof")[0].GetProperty("right").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("root").ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("serviceEndorsements")[0].ToString());
Console.WriteLine(result.GetProperty("receipt").GetProperty("signature").ToString());
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeOptions">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetRuntimeOptions (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetRuntimeOptions(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetRuntimeOptions(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeOptions (Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeOptions : Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetRuntimeOptions : Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetRuntimeOptions context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Runtime options for user defined endpoints.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetRuntimeOptions and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetRuntimeOptions();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetRuntimeOptions with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetRuntimeOptions();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("return_exception_details").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeOptionsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetRuntimeOptionsAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetRuntimeOptionsAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetRuntimeOptionsAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeOptionsAsync (Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeOptionsAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetRuntimeOptionsAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetRuntimeOptionsAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Runtime options for user defined endpoints.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetRuntimeOptionsAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetRuntimeOptionsAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetRuntimeOptionsAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetRuntimeOptionsAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("return_exception_details").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTransactionStatus">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTransactionStatus (string transactionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTransactionStatus(string transactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetTransactionStatus(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTransactionStatus (transactionId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTransactionStatus : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTransactionStatus : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetTransactionStatus (transactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the status of an entry identified by a transaction id.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TransactionStatus</c>:
<code>{
  state: "Committed" | "Pending", # Required. Represents the state of the transaction.
  transactionId: string, # Required. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTransactionStatus and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetTransactionStatus("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
]]></code>
This sample shows how to call GetTransactionStatus with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetTransactionStatus("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetTransactionStatusAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTransactionStatusAsync (string transactionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTransactionStatusAsync(string transactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetTransactionStatusAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTransactionStatusAsync (transactionId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTransactionStatusAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTransactionStatusAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetTransactionStatusAsync (transactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets the status of an entry identified by a transaction id.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TransactionStatus</c>:
<code>{
  state: "Committed" | "Pending", # Required. Represents the state of the transaction.
  transactionId: string, # Required. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetTransactionStatusAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetTransactionStatusAsync("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
]]></code>
This sample shows how to call GetTransactionStatusAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetTransactionStatusAsync("<transactionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("state").ToString());
Console.WriteLine(result.GetProperty("transactionId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetUser (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetUser(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUser(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUser (userId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetUser : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetUser : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetUser (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a user.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>LedgerUser</c>:
<code>{
  assignedRole: "Administrator" | "Contributor" | "Reader", # Required. Represents an assignable role.
  userId: string, # Optional. Identifier for the user. This must either be an AAD object id or a certificate fingerprint.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUser and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUser("<userId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRole").ToString());
]]></code>
This sample shows how to call GetUser with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUser("<userId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRole").ToString());
Console.WriteLine(result.GetProperty("userId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetUserAsync (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetUserAsync(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserAsync (userId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetUserAsync (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a user.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>LedgerUser</c>:
<code>{
  assignedRole: "Administrator" | "Contributor" | "Reader", # Required. Represents an assignable role.
  userId: string, # Optional. Identifier for the user. This must either be an AAD object id or a certificate fingerprint.
}
</code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserAsync("<userId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRole").ToString());
]]></code>
This sample shows how to call GetUserAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserAsync("<userId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("assignedRole").ToString());
Console.WriteLine(result.GetProperty("userId").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedEndpoint">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetUserDefinedEndpoint (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetUserDefinedEndpoint(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedEndpoint(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedEndpoint (Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedEndpoint : Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetUserDefinedEndpoint : Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetUserDefinedEndpoint context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a user defined endpoint.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedEndpoint and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUserDefinedEndpoint();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("modules").ToString());
]]></code>
This sample shows how to call GetUserDefinedEndpoint with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUserDefinedEndpoint();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("authn_policies")[0].ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("forwarding_required").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("interpreter_reuse").GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("js_function").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("js_module").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("openapi").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("openapi_hidden").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("redirection_strategy").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("authn_policies")[0].ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("forwarding_required").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("interpreter_reuse").GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("js_function").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("js_module").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("openapi").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("openapi_hidden").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("redirection_strategy").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("authn_policies")[0].ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("forwarding_required").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("interpreter_reuse").GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("js_function").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("js_module").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("openapi").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("openapi_hidden").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("redirection_strategy").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("authn_policies")[0].ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("forwarding_required").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("interpreter_reuse").GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("js_function").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("js_module").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("openapi").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("openapi_hidden").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("redirection_strategy").ToString());
Console.WriteLine(result.GetProperty("modules").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedEndpointAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetUserDefinedEndpointAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetUserDefinedEndpointAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedEndpointAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedEndpointAsync (Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedEndpointAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetUserDefinedEndpointAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetUserDefinedEndpointAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a user defined endpoint.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedEndpointAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserDefinedEndpointAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").ToString());
Console.WriteLine(result.GetProperty("modules").ToString());
]]></code>
This sample shows how to call GetUserDefinedEndpointAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserDefinedEndpointAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("authn_policies")[0].ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("forwarding_required").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("interpreter_reuse").GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("js_function").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("js_module").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("openapi").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("openapi_hidden").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("get").GetProperty("redirection_strategy").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("authn_policies")[0].ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("forwarding_required").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("interpreter_reuse").GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("js_function").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("js_module").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("openapi").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("openapi_hidden").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("put").GetProperty("redirection_strategy").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("authn_policies")[0].ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("forwarding_required").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("interpreter_reuse").GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("js_function").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("js_module").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("openapi").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("openapi_hidden").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("patch").GetProperty("redirection_strategy").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("authn_policies")[0].ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("forwarding_required").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("interpreter_reuse").GetProperty("key").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("js_function").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("js_module").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("mode").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("openapi").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("openapi_hidden").ToString());
Console.WriteLine(result.GetProperty("metadata").GetProperty("endpoints").GetProperty("<key>").GetProperty("delete").GetProperty("redirection_strategy").ToString());
Console.WriteLine(result.GetProperty("modules").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedEndpointsModule">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetUserDefinedEndpointsModule (string moduleName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetUserDefinedEndpointsModule(string moduleName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedEndpointsModule(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedEndpointsModule (moduleName As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedEndpointsModule : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetUserDefinedEndpointsModule : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetUserDefinedEndpointsModule (moduleName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="moduleName"> module name of the user defined endpoint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Module for user defined endpoints.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedEndpointsModule and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUserDefinedEndpointsModule("<moduleName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("module").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
]]></code>
This sample shows how to call GetUserDefinedEndpointsModule with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUserDefinedEndpointsModule("<moduleName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("module").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedEndpointsModuleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetUserDefinedEndpointsModuleAsync (string moduleName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetUserDefinedEndpointsModuleAsync(string moduleName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedEndpointsModuleAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedEndpointsModuleAsync (moduleName As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedEndpointsModuleAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetUserDefinedEndpointsModuleAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetUserDefinedEndpointsModuleAsync (moduleName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="moduleName"> module name of the user defined endpoint. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Module for user defined endpoints.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedEndpointsModuleAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserDefinedEndpointsModuleAsync("<moduleName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("module").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
]]></code>
This sample shows how to call GetUserDefinedEndpointsModuleAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserDefinedEndpointsModuleAsync("<moduleName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("module").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedFunction">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetUserDefinedFunction (string functionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetUserDefinedFunction(string functionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedFunction(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedFunction (functionId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedFunction : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetUserDefinedFunction : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetUserDefinedFunction (functionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="functionId"> Identifies a user defined function. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a user defined function.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedFunction and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUserDefinedFunction("<functionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("code").ToString());
]]></code>
This sample shows how to call GetUserDefinedFunction with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUserDefinedFunction("<functionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedFunctionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetUserDefinedFunctionAsync (string functionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetUserDefinedFunctionAsync(string functionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedFunctionAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedFunctionAsync (functionId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedFunctionAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetUserDefinedFunctionAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetUserDefinedFunctionAsync (functionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionId" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="functionId"> Identifies a user defined function. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets a user defined function.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionId" /> is an empty string, and was expected to be non-empty. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedFunctionAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserDefinedFunctionAsync("<functionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("code").ToString());
]]></code>
This sample shows how to call GetUserDefinedFunctionAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserDefinedFunctionAsync("<functionId>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("code").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedFunctions">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetUserDefinedFunctions (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetUserDefinedFunctions(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedFunctions(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedFunctions (Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedFunctions : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetUserDefinedFunctions : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetUserDefinedFunctions context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Retrieves a list of user defined functions present in the Confidential Ledger
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedFunctions and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetUserDefinedFunctions())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("code").ToString());
}
]]></code>
This sample shows how to call GetUserDefinedFunctions with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetUserDefinedFunctions())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("id").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedFunctionsAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetUserDefinedFunctionsAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetUserDefinedFunctionsAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedFunctionsAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedFunctionsAsync (Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedFunctionsAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetUserDefinedFunctionsAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetUserDefinedFunctionsAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Retrieves a list of user defined functions present in the Confidential Ledger
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedFunctionsAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetUserDefinedFunctionsAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("code").ToString());
}
]]></code>
This sample shows how to call GetUserDefinedFunctionsAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetUserDefinedFunctionsAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("code").ToString());
    Console.WriteLine(result.GetProperty("id").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedRole">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetUserDefinedRole (string roleName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetUserDefinedRole(string roleName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedRole(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedRole (roleName As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedRole : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetUserDefinedRole : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetUserDefinedRole (roleName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="roleName"> user defined role name. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets role actions for user defined roles
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedRole and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUserDefinedRole("<roleName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code>
This sample shows how to call GetUserDefinedRole with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = client.GetUserDefinedRole("<roleName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].GetProperty("roleName").ToString());
Console.WriteLine(result[0].GetProperty("roleActions")[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUserDefinedRoleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetUserDefinedRoleAsync (string roleName, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetUserDefinedRoleAsync(string roleName, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserDefinedRoleAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserDefinedRoleAsync (roleName As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetUserDefinedRoleAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetUserDefinedRoleAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetUserDefinedRoleAsync (roleName, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="roleName"> user defined role name. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets role actions for user defined roles
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUserDefinedRoleAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserDefinedRoleAsync("<roleName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code>
This sample shows how to call GetUserDefinedRoleAsync with all parameters and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

Response response = await client.GetUserDefinedRoleAsync("<roleName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].GetProperty("roleName").ToString());
Console.WriteLine(result[0].GetProperty("roleActions")[0].ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUsers">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetUsers (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetUsers(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUsers(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUsers (Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetUsers : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetUsers : Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetUsers context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets details on a list of users.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.Pageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUsers and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetUsers())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("assignedRole").ToString());
}
]]></code>
This sample shows how to call GetUsers with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

foreach (BinaryData item in client.GetUsers())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("assignedRole").ToString());
    Console.WriteLine(result.GetProperty("userId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetUsersAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetUsersAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetUsersAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUsersAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUsersAsync (Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetUsersAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetUsersAsync : Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetUsersAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" Index="0" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Gets details on a list of users.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The <see cref="T:Azure.AsyncPageable`1" /> from the service containing a list of <see cref="T:System.BinaryData" /> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call GetUsersAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetUsersAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("assignedRole").ToString());
}
]]></code>
This sample shows how to call GetUsersAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

await foreach (BinaryData item in client.GetUsersAsync())
{
    JsonElement result = JsonDocument.Parse(item.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("assignedRole").ToString());
    Console.WriteLine(result.GetProperty("userId").ToString());
}
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Operation PostLedgerEntry (Azure.WaitUntil waitUntil, Azure.Core.RequestContent content, string collectionId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Operation PostLedgerEntry(valuetype Azure.WaitUntil waitUntil, class Azure.Core.RequestContent content, string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.PostLedgerEntry(Azure.WaitUntil,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntry (waitUntil As WaitUntil, content As RequestContent, Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Operation" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member PostLedgerEntry : Azure.WaitUntil * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Operation&#xA;override this.PostLedgerEntry : Azure.WaitUntil * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Operation" Usage="confidentialLedgerClient.PostLedgerEntry (waitUntil, content, collectionId, context)" />
      <MemberSignature Language="C#" Value="public virtual Azure.Operation PostLedgerEntry (Azure.WaitUntil waitUntil, Azure.Core.RequestContent content, string collectionId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntry (waitUntil As WaitUntil, content As RequestContent, collectionId As String, context As RequestContext) As Operation" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Operation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>.</param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="context"> The request context. </param>
        <summary>
            [Protocol Method] Gets all ledger entries.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
             Below is the JSON schema for the request and response payloads.
            
             Request Body:
            
             Schema for <c>LedgerEntry</c>:
             <code>{
               contents: string, # Required. Contents of the ledger entry.
               collectionId: string, # Optional.
               transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
             }
             </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="PostLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Operation PostLedgerEntry (Azure.WaitUntil waitUntil, Azure.Core.RequestContent content, string collectionId = default, string tags = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Operation PostLedgerEntry(valuetype Azure.WaitUntil waitUntil, class Azure.Core.RequestContent content, string collectionId, string tags, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.PostLedgerEntry(Azure.WaitUntil,Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntry (waitUntil As WaitUntil, content As RequestContent, Optional collectionId As String = Nothing, Optional tags As String = Nothing, Optional context As RequestContext = Nothing) As Operation" />
      <MemberSignature Language="F#" Value="abstract member PostLedgerEntry : Azure.WaitUntil * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Operation&#xA;override this.PostLedgerEntry : Azure.WaitUntil * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; Azure.Operation" Usage="confidentialLedgerClient.PostLedgerEntry (waitUntil, content, collectionId, tags, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Operation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="collectionId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="tags" Type="System.String" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="4" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>.</param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="tags"> The tags. </param>
        <param name="context"> The request context. </param>
        <summary> Posts a new entry to the ledger. A collection id may optionally be specified. </summary>
        <returns>To be added.</returns>
        <remarks>
             Below is the JSON schema for the request and response payloads.
            
             Request Body:
            
             Schema for <c>LedgerEntry</c>:
             <code>{
               contents: string, # Required. Contents of the ledger entry.
               collectionId: string, # Required.
               transactionId: string, # Required. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
               tags: string, # Optional.
             }
             </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="PostLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Operation&gt; PostLedgerEntryAsync (Azure.WaitUntil waitUntil, Azure.Core.RequestContent content, string collectionId = default, Azure.RequestContext context = default);" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Operation&gt; PostLedgerEntryAsync(valuetype Azure.WaitUntil waitUntil, class Azure.Core.RequestContent content, string collectionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.PostLedgerEntryAsync(Azure.WaitUntil,Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntryAsync (waitUntil As WaitUntil, content As RequestContent, Optional collectionId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Operation)" FrameworkAlternate="azure-dotnet" />
      <MemberSignature Language="F#" Value="abstract member PostLedgerEntryAsync : Azure.WaitUntil * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Operation&gt;&#xA;override this.PostLedgerEntryAsync : Azure.WaitUntil * Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Operation&gt;" Usage="confidentialLedgerClient.PostLedgerEntryAsync (waitUntil, content, collectionId, context)" />
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Operation&gt; PostLedgerEntryAsync (Azure.WaitUntil waitUntil, Azure.Core.RequestContent content, string collectionId, Azure.RequestContext context);" FrameworkAlternate="azure-dotnet-preview" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntryAsync (waitUntil As WaitUntil, content As RequestContent, collectionId As String, context As RequestContext) As Task(Of Operation)" FrameworkAlternate="azure-dotnet-preview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Operation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="collectionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>.</param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="context"> The request context. </param>
        <summary>
            [Protocol Method] Gets all ledger entries.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>
             Below is the JSON schema for the request and response payloads.
            
             Request Body:
            
             Schema for <c>LedgerEntry</c>:
             <code>{
               contents: string, # Required. Contents of the ledger entry.
               collectionId: string, # Optional.
               transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
             }
             </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="PostLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Operation&gt; PostLedgerEntryAsync (Azure.WaitUntil waitUntil, Azure.Core.RequestContent content, string collectionId = default, string tags = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Operation&gt; PostLedgerEntryAsync(valuetype Azure.WaitUntil waitUntil, class Azure.Core.RequestContent content, string collectionId, string tags, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.PostLedgerEntryAsync(Azure.WaitUntil,Azure.Core.RequestContent,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntryAsync (waitUntil As WaitUntil, content As RequestContent, Optional collectionId As String = Nothing, Optional tags As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Operation)" />
      <MemberSignature Language="F#" Value="abstract member PostLedgerEntryAsync : Azure.WaitUntil * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Operation&gt;&#xA;override this.PostLedgerEntryAsync : Azure.WaitUntil * Azure.Core.RequestContent * string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Operation&gt;" Usage="confidentialLedgerClient.PostLedgerEntryAsync (waitUntil, content, collectionId, tags, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Operation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="1" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="collectionId" Type="System.String" Index="2" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="tags" Type="System.String" Index="3" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="4" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>.</param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="collectionId"> The collection id. </param>
        <param name="tags"> The tags. </param>
        <param name="context"> The request context. </param>
        <summary> Posts a new entry to the ledger. A collection id may optionally be specified. </summary>
        <returns>To be added.</returns>
        <remarks>
             Below is the JSON schema for the request and response payloads.
            
             Request Body:
            
             Schema for <c>LedgerEntry</c>:
             <code>{
               contents: string, # Required. Contents of the ledger entry.
               collectionId: string, # Optional.
               transactionId: string, # Optional. A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.
             }
             </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateRuntimeOptions">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateRuntimeOptions (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateRuntimeOptions(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.UpdateRuntimeOptions(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateRuntimeOptions (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateRuntimeOptions : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdateRuntimeOptions : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.UpdateRuntimeOptions (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Runtime options for user defined endpoints.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateRuntimeOptions and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object());
Response response = client.UpdateRuntimeOptions(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateRuntimeOptions with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    log_exception_details = true,
    max_cached_interpreters = 1234L,
    max_execution_time_ms = 1234L,
    max_heap_bytes = 1234L,
    max_stack_bytes = 1234L,
    return_exception_details = true,
});
Response response = client.UpdateRuntimeOptions(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("return_exception_details").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateRuntimeOptionsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateRuntimeOptionsAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateRuntimeOptionsAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.UpdateRuntimeOptionsAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateRuntimeOptionsAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateRuntimeOptionsAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateRuntimeOptionsAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.UpdateRuntimeOptionsAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Runtime options for user defined endpoints.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateRuntimeOptionsAsync and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object());
Response response = await client.UpdateRuntimeOptionsAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateRuntimeOptionsAsync with all request content and parse the result.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new
{
    log_exception_details = true,
    max_cached_interpreters = 1234L,
    max_execution_time_ms = 1234L,
    max_heap_bytes = 1234L,
    max_stack_bytes = 1234L,
    return_exception_details = true,
});
Response response = await client.UpdateRuntimeOptionsAsync(content);

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("log_exception_details").ToString());
Console.WriteLine(result.GetProperty("max_cached_interpreters").ToString());
Console.WriteLine(result.GetProperty("max_execution_time_ms").ToString());
Console.WriteLine(result.GetProperty("max_heap_bytes").ToString());
Console.WriteLine(result.GetProperty("max_stack_bytes").ToString());
Console.WriteLine(result.GetProperty("return_exception_details").ToString());
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateUserDefinedRole">
      <MemberSignature Language="C#" Value="public virtual Azure.Response UpdateUserDefinedRole (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response UpdateUserDefinedRole(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.UpdateUserDefinedRole(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateUserDefinedRole (content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member UpdateUserDefinedRole : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.UpdateUserDefinedRole : Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.UpdateUserDefinedRole (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Patch replaces the allowed action on existing roles,if the desire is to remove an existing action, the role must be deleted and recreated.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateUserDefinedRole.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = client.UpdateUserDefinedRole(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateUserDefinedRole with all request content.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        roleName = "<roleName>",
        roleActions = new object[]
        {
            "<roleActions>"
        },
    }
});
Response response = client.UpdateUserDefinedRole(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
    <Member MemberName="UpdateUserDefinedRoleAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; UpdateUserDefinedRoleAsync (Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; UpdateUserDefinedRoleAsync(class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.UpdateUserDefinedRoleAsync(Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function UpdateUserDefinedRoleAsync (content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member UpdateUserDefinedRoleAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.UpdateUserDefinedRoleAsync : Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.UpdateUserDefinedRoleAsync (content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" Index="0" FrameworkAlternate="azure-dotnet-preview" />
        <Parameter Name="context" Type="Azure.RequestContext" Index="1" FrameworkAlternate="azure-dotnet-preview" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        <summary>
            [Protocol Method] Patch replaces the allowed action on existing roles,if the desire is to remove an existing action, the role must be deleted and recreated.
            <list type="bullet"><item><description>
            This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
            </description></item></list></summary>
        <returns> The response returned from the service. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="content" /> is null. </exception>
        <exception cref="T:Azure.RequestFailedException"> Service returned a non-success status code. </exception>
        <example>
This sample shows how to call UpdateUserDefinedRoleAsync.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object[]
{
    new object()
});
Response response = await client.UpdateUserDefinedRoleAsync(content);

Console.WriteLine(response.Status);
]]></code>
This sample shows how to call UpdateUserDefinedRoleAsync with all request content.
<code><![CDATA[
TokenCredential credential = new DefaultAzureCredential();
ConfidentialLedgerClient client = new ConfidentialLedgerClient(new Uri("http://localhost:3000"), credential);

using RequestContent content = RequestContent.Create(new object[]
{
    new
    {
        roleName = "<roleName>",
        roleActions = new object[]
        {
            "<roleActions>"
        },
    }
});
Response response = await client.UpdateUserDefinedRoleAsync(content);

Console.WriteLine(response.Status);
]]></code></example>
      </Docs>
    </Member>
  </Members>
</Type>
