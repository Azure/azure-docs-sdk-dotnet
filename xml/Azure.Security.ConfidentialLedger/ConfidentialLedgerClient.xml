<Type Name="ConfidentialLedgerClient" FullName="Azure.Security.ConfidentialLedger.ConfidentialLedgerClient">
  <TypeSignature Language="C#" Value="public class ConfidentialLedgerClient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ConfidentialLedgerClient extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient" />
  <TypeSignature Language="VB.NET" Value="Public Class ConfidentialLedgerClient" />
  <TypeSignature Language="F#" Value="type ConfidentialLedgerClient = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The ConfidentialLedger service client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfidentialLedgerClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of ConfidentialLedgerClient for mocking. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConfidentialLedgerClient (Uri ledgerUri, Azure.Core.TokenCredential credential);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri ledgerUri, class Azure.Core.TokenCredential credential) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.#ctor(System.Uri,Azure.Core.TokenCredential)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ledgerUri As Uri, credential As TokenCredential)" />
      <MemberSignature Language="F#" Value="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient : Uri * Azure.Core.TokenCredential -&gt; Azure.Security.ConfidentialLedger.ConfidentialLedgerClient" Usage="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient (ledgerUri, credential)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ledgerUri" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
      </Parameters>
      <Docs>
        <param name="ledgerUri"> The Confidential Ledger URL, for example https://contoso.confidentialledger.azure.com. </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <summary> Initializes a new instance of ConfidentialLedgerClient. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ledgerUri" /> or <paramref name="credential" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConfidentialLedgerClient (Uri ledgerUri, Azure.Core.TokenCredential credential, Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri ledgerUri, class Azure.Core.TokenCredential credential, class Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.#ctor(System.Uri,Azure.Core.TokenCredential,Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ledgerUri As Uri, credential As TokenCredential, options As ConfidentialLedgerClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient : Uri * Azure.Core.TokenCredential * Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions -&gt; Azure.Security.ConfidentialLedger.ConfidentialLedgerClient" Usage="new Azure.Security.ConfidentialLedger.ConfidentialLedgerClient (ledgerUri, credential, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ledgerUri" Type="System.Uri" />
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
        <Parameter Name="options" Type="Azure.Security.ConfidentialLedger.ConfidentialLedgerClientOptions" />
      </Parameters>
      <Docs>
        <param name="ledgerUri"> The Confidential Ledger URL, for example https://contoso.confidentialledger.azure.com. </param>
        <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of ConfidentialLedgerClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response CreateOrUpdateUser (string userId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response CreateOrUpdateUser(string userId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateOrUpdateUser(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateUser (userId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateUser : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response&#xA;override this.CreateOrUpdateUser : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.CreateOrUpdateUser (userId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A JSON merge patch is applied for existing users. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Request Body</c>:
            <code>{
              assignedRole: "Administrator" | "Contributor" | "Reader" (required),
              userId: string
            }
            </code>
            Schema for <c>Response Body</c>:
            <code>{
              assignedRole: "Administrator" | "Contributor" | "Reader",
              userId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="userId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrUpdateUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; CreateOrUpdateUserAsync (string userId, Azure.Core.RequestContent content, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; CreateOrUpdateUserAsync(string userId, class Azure.Core.RequestContent content, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.CreateOrUpdateUserAsync(System.String,Azure.Core.RequestContent,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateOrUpdateUserAsync (userId As String, content As RequestContent, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member CreateOrUpdateUserAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.CreateOrUpdateUserAsync : string * Azure.Core.RequestContent * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.CreateOrUpdateUserAsync (userId, content, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A JSON merge patch is applied for existing users. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Request Body</c>:
            <code>{
              assignedRole: "Administrator" | "Contributor" | "Reader" (required),
              userId: string
            }
            </code>
            Schema for <c>Response Body</c>:
            <code>{
              assignedRole: "Administrator" | "Contributor" | "Reader",
              userId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> or <paramref name="content" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="userId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response DeleteUser (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response DeleteUser(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteUser(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteUser (userId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member DeleteUser : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.DeleteUser : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.DeleteUser (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Deletes a user from the Confidential Ledger. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="userId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; DeleteUserAsync (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; DeleteUserAsync(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.DeleteUserAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeleteUserAsync (userId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member DeleteUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.DeleteUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.DeleteUserAsync (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Deletes a user from the Confidential Ledger. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="userId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsortiumMembers">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetConsortiumMembers (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetConsortiumMembers(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetConsortiumMembers(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConsortiumMembers (Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetConsortiumMembers : Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetConsortiumMembers : Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetConsortiumMembers context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Consortium members can manage the Confidential Ledger. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              members: [
                {
                  certificate: string,
                  id: string
                }
              ]
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConsortiumMembersAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetConsortiumMembersAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetConsortiumMembersAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetConsortiumMembersAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConsortiumMembersAsync (Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetConsortiumMembersAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetConsortiumMembersAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetConsortiumMembersAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Consortium members can manage the Confidential Ledger. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              members: [
                {
                  certificate: string,
                  id: string
                }
              ]
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstitution">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetConstitution (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetConstitution(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetConstitution(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConstitution (Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetConstitution : Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetConstitution : Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetConstitution context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> The constitution is a script that assesses and applies proposals from consortium members. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              digest: string,
              script: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstitutionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetConstitutionAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetConstitutionAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetConstitutionAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConstitutionAsync (Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetConstitutionAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetConstitutionAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetConstitutionAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> The constitution is a script that assesses and applies proposals from consortium members. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              digest: string,
              script: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetCurrentLedgerEntry (string subLedgerId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetCurrentLedgerEntry(string subLedgerId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetCurrentLedgerEntry(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCurrentLedgerEntry (Optional subLedgerId As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentLedgerEntry : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetCurrentLedgerEntry : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetCurrentLedgerEntry (subLedgerId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A sub-ledger id may optionally be specified. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              contents: string,
              subLedgerId: string,
              transactionId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetCurrentLedgerEntryAsync (string subLedgerId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetCurrentLedgerEntryAsync(string subLedgerId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetCurrentLedgerEntryAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCurrentLedgerEntryAsync (Optional subLedgerId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentLedgerEntryAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetCurrentLedgerEntryAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetCurrentLedgerEntryAsync (subLedgerId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A sub-ledger id may optionally be specified. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              contents: string,
              subLedgerId: string,
              transactionId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclaveQuotes">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetEnclaveQuotes (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetEnclaveQuotes(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetEnclaveQuotes(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnclaveQuotes (Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetEnclaveQuotes : Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetEnclaveQuotes : Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetEnclaveQuotes context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A quote is an SGX enclave measurement that can be used to verify the validity of a node and its enclave. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              currentNodeId: string,
              enclaveQuotes: Dictionary&lt;string, EnclaveQuote&gt;
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclaveQuotesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetEnclaveQuotesAsync (Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetEnclaveQuotesAsync(class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetEnclaveQuotesAsync(Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnclaveQuotesAsync (Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetEnclaveQuotesAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetEnclaveQuotesAsync : Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetEnclaveQuotesAsync context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A quote is an SGX enclave measurement that can be used to verify the validity of a node and its enclave. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              currentNodeId: string,
              enclaveQuotes: Dictionary&lt;string, EnclaveQuote&gt;
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntries">
      <MemberSignature Language="C#" Value="public virtual Azure.Pageable&lt;BinaryData&gt; GetLedgerEntries (string subLedgerId = default, string fromTransactionId = default, string toTransactionId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Pageable`1&lt;class System.BinaryData&gt; GetLedgerEntries(string subLedgerId, string fromTransactionId, string toTransactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntries(System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntries (Optional subLedgerId As String = Nothing, Optional fromTransactionId As String = Nothing, Optional toTransactionId As String = Nothing, Optional context As RequestContext = Nothing) As Pageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntries : string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;&#xA;override this.GetLedgerEntries : string * string * string * Azure.RequestContext -&gt; Azure.Pageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetLedgerEntries (subLedgerId, fromTransactionId, toTransactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Pageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="fromTransactionId" Type="System.String" />
        <Parameter Name="toTransactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="fromTransactionId"> Specify the first transaction ID in a range. </param>
        <param name="toTransactionId"> Specify the last transaction ID in a range. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A sub-ledger id may optionally be specified. Only entries in the specified (or default) sub-ledger will be returned. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              state: "Loading" | "Ready",
              @nextLink: string,
              entries: [
                {
                  contents: string,
                  subLedgerId: string,
                  transactionId: string
                }
              ]
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntriesAsync">
      <MemberSignature Language="C#" Value="public virtual Azure.AsyncPageable&lt;BinaryData&gt; GetLedgerEntriesAsync (string subLedgerId = default, string fromTransactionId = default, string toTransactionId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.AsyncPageable`1&lt;class System.BinaryData&gt; GetLedgerEntriesAsync(string subLedgerId, string fromTransactionId, string toTransactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntriesAsync(System.String,System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntriesAsync (Optional subLedgerId As String = Nothing, Optional fromTransactionId As String = Nothing, Optional toTransactionId As String = Nothing, Optional context As RequestContext = Nothing) As AsyncPageable(Of BinaryData)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntriesAsync : string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;&#xA;override this.GetLedgerEntriesAsync : string * string * string * Azure.RequestContext -&gt; Azure.AsyncPageable&lt;BinaryData&gt;" Usage="confidentialLedgerClient.GetLedgerEntriesAsync (subLedgerId, fromTransactionId, toTransactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.AsyncPageable&lt;System.BinaryData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="fromTransactionId" Type="System.String" />
        <Parameter Name="toTransactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="fromTransactionId"> Specify the first transaction ID in a range. </param>
        <param name="toTransactionId"> Specify the last transaction ID in a range. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A sub-ledger id may optionally be specified. Only entries in the specified (or default) sub-ledger will be returned. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              state: "Loading" | "Ready",
              @nextLink: string,
              entries: [
                {
                  contents: string,
                  subLedgerId: string,
                  transactionId: string
                }
              ]
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetLedgerEntry (string transactionId, string subLedgerId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetLedgerEntry(string transactionId, string subLedgerId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntry(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntry (transactionId As String, Optional subLedgerId As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntry : string * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetLedgerEntry : string * string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetLedgerEntry (transactionId, subLedgerId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> To return older ledger entries, the relevant sections of the ledger must be read from disk and validated. To prevent blocking within the enclave, the response will indicate whether the entry is ready and part of the response, or if the loading is still ongoing. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              state: "Loading" | "Ready",
              entry: {
                contents: string,
                subLedgerId: string,
                transactionId: string
              }
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetLedgerEntryAsync (string transactionId, string subLedgerId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetLedgerEntryAsync(string transactionId, string subLedgerId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetLedgerEntryAsync(System.String,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLedgerEntryAsync (transactionId As String, Optional subLedgerId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetLedgerEntryAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetLedgerEntryAsync : string * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetLedgerEntryAsync (transactionId, subLedgerId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> To return older ledger entries, the relevant sections of the ledger must be read from disk and validated. To prevent blocking within the enclave, the response will indicate whether the entry is ready and part of the response, or if the loading is still ongoing. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              state: "Loading" | "Ready",
              entry: {
                contents: string,
                subLedgerId: string,
                transactionId: string
              }
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetReceipt">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetReceipt (string transactionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetReceipt(string transactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetReceipt(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReceipt (transactionId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetReceipt : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetReceipt : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetReceipt (transactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Gets a receipt certifying ledger contents at a particular transaction id. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              receipt: {
                leaf: string,
                nodeId: string,
                proof: [
                  {
                    left: string,
                    right: string
                  }
                ],
                root: string,
                signature: string
              },
              state: "Loading" | "Ready",
              transactionId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetReceiptAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetReceiptAsync (string transactionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetReceiptAsync(string transactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetReceiptAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReceiptAsync (transactionId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetReceiptAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetReceiptAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetReceiptAsync (transactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Gets a receipt certifying ledger contents at a particular transaction id. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              receipt: {
                leaf: string,
                nodeId: string,
                proof: [
                  {
                    left: string,
                    right: string
                  }
                ],
                root: string,
                signature: string
              },
              state: "Loading" | "Ready",
              transactionId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTransactionStatus">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetTransactionStatus (string transactionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetTransactionStatus(string transactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetTransactionStatus(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTransactionStatus (transactionId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetTransactionStatus : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetTransactionStatus : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetTransactionStatus (transactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Gets the status of an entry identified by a transaction id. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              state: "Committed" | "Pending",
              transactionId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTransactionStatusAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetTransactionStatusAsync (string transactionId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetTransactionStatusAsync(string transactionId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetTransactionStatusAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTransactionStatusAsync (transactionId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetTransactionStatusAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetTransactionStatusAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetTransactionStatusAsync (transactionId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="transactionId"> Identifies a write transaction. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Gets the status of an entry identified by a transaction id. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              state: "Committed" | "Pending",
              transactionId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transactionId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="transactionId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetUser">
      <MemberSignature Language="C#" Value="public virtual Azure.Response GetUser (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response GetUser(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUser(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUser (userId As String, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member GetUser : string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.GetUser : string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.GetUser (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Gets a user. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              assignedRole: "Administrator" | "Contributor" | "Reader",
              userId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="userId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="GetUserAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; GetUserAsync (string userId, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; GetUserAsync(string userId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.GetUserAsync(System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetUserAsync (userId As String, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member GetUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.GetUserAsync : string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.GetUserAsync (userId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> Gets a user. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Response Body</c>:
            <code>{
              assignedRole: "Administrator" | "Contributor" | "Reader",
              userId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userId" /> is null. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="userId" /> is an empty string, and was expected to be non-empty. </exception>
      </Docs>
    </Member>
    <Member MemberName="Pipeline">
      <MemberSignature Language="C#" Value="public virtual Azure.Core.Pipeline.HttpPipeline Pipeline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Azure.Core.Pipeline.HttpPipeline Pipeline" />
      <MemberSignature Language="DocId" Value="P:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.Pipeline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Pipeline As HttpPipeline" />
      <MemberSignature Language="F#" Value="member this.Pipeline : Azure.Core.Pipeline.HttpPipeline" Usage="Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.Pipeline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Core.Pipeline.HttpPipeline</ReturnType>
      </ReturnValue>
      <Docs>
        <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response PostLedgerEntry (Azure.Core.RequestContent content, string subLedgerId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response PostLedgerEntry(class Azure.Core.RequestContent content, string subLedgerId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.PostLedgerEntry(Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntry (content As RequestContent, Optional subLedgerId As String = Nothing, Optional context As RequestContext = Nothing) As Response" />
      <MemberSignature Language="F#" Value="abstract member PostLedgerEntry : Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response&#xA;override this.PostLedgerEntry : Azure.Core.RequestContent * string * Azure.RequestContext -&gt; Azure.Response" Usage="confidentialLedgerClient.PostLedgerEntry (content, subLedgerId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A sub-ledger id may optionally be specified. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Request Body</c>:
            <code>{
              contents: string (required),
              subLedgerId: string,
              transactionId: string
            }
            </code>
            Schema for <c>Response Body</c>:
            <code>{
              subLedgerId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="PostLedgerEntry">
      <MemberSignature Language="C#" Value="public virtual Azure.Security.ConfidentialLedger.PostLedgerEntryOperation PostLedgerEntry (Azure.Core.RequestContent content, string subLedgerId = default, bool waitForCompletion = true, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Security.ConfidentialLedger.PostLedgerEntryOperation PostLedgerEntry(class Azure.Core.RequestContent content, string subLedgerId, bool waitForCompletion, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.PostLedgerEntry(Azure.Core.RequestContent,System.String,System.Boolean,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntry (content As RequestContent, Optional subLedgerId As String = Nothing, Optional waitForCompletion As Boolean = true, Optional context As RequestContext = Nothing) As PostLedgerEntryOperation" />
      <MemberSignature Language="F#" Value="abstract member PostLedgerEntry : Azure.Core.RequestContent * string * bool * Azure.RequestContext -&gt; Azure.Security.ConfidentialLedger.PostLedgerEntryOperation&#xA;override this.PostLedgerEntry : Azure.Core.RequestContent * string * bool * Azure.RequestContext -&gt; Azure.Security.ConfidentialLedger.PostLedgerEntryOperation" Usage="confidentialLedgerClient.PostLedgerEntry (content, subLedgerId, waitForCompletion, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Security.ConfidentialLedger.PostLedgerEntryOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="waitForCompletion" Type="System.Boolean" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="waitForCompletion"> If <c>true</c>, the <see cref="T:Azure.Security.ConfidentialLedger.PostLedgerEntryOperation" /> will not be returned until the ledger entry is committed.
            If <c>false</c>,<see cref="M:Azure.Operation.WaitForCompletionResponse(System.Threading.CancellationToken)" /> must be called to ensure the operation has completed.</param>
        <param name="context"> The request context. </param>
        <summary> Posts a new entry to the ledger. A sub-ledger id may optionally be specified. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Request Body</c>:
            <list type="table"><listheader><term>Name</term><term>Type</term><term>Required</term><term>Description</term></listheader><item><term>contents</term><term>string</term><term>Yes</term><term> Contents of the ledger entry. </term></item><item><term>subLedgerId</term><term>string</term><term /><term> Identifier for sub-ledgers. </term></item><item><term>transactionId</term><term>string</term><term /><term> A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read. </term></item></list></remarks>
      </Docs>
    </Member>
    <Member MemberName="PostLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&gt; PostLedgerEntryAsync (Azure.Core.RequestContent content, string subLedgerId = default, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response&gt; PostLedgerEntryAsync(class Azure.Core.RequestContent content, string subLedgerId, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.PostLedgerEntryAsync(Azure.Core.RequestContent,System.String,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntryAsync (content As RequestContent, Optional subLedgerId As String = Nothing, Optional context As RequestContext = Nothing) As Task(Of Response)" />
      <MemberSignature Language="F#" Value="abstract member PostLedgerEntryAsync : Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;&#xA;override this.PostLedgerEntryAsync : Azure.Core.RequestContent * string * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Response&gt;" Usage="confidentialLedgerClient.PostLedgerEntryAsync (content, subLedgerId, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        <summary> A sub-ledger id may optionally be specified. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Request Body</c>:
            <code>{
              contents: string (required),
              subLedgerId: string,
              transactionId: string
            }
            </code>
            Schema for <c>Response Body</c>:
            <code>{
              subLedgerId: string
            }
            </code>
            Schema for <c>Response Error</c>:
            <code>{
              error: {
                code: string,
                message: string,
                innererror: ConfidentialLedgerErrorBody
              }
            }
            </code></remarks>
      </Docs>
    </Member>
    <Member MemberName="PostLedgerEntryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Security.ConfidentialLedger.PostLedgerEntryOperation&gt; PostLedgerEntryAsync (Azure.Core.RequestContent content, string subLedgerId = default, bool waitForCompletion = true, Azure.RequestContext context = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Security.ConfidentialLedger.PostLedgerEntryOperation&gt; PostLedgerEntryAsync(class Azure.Core.RequestContent content, string subLedgerId, bool waitForCompletion, class Azure.RequestContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Security.ConfidentialLedger.ConfidentialLedgerClient.PostLedgerEntryAsync(Azure.Core.RequestContent,System.String,System.Boolean,Azure.RequestContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PostLedgerEntryAsync (content As RequestContent, Optional subLedgerId As String = Nothing, Optional waitForCompletion As Boolean = true, Optional context As RequestContext = Nothing) As Task(Of PostLedgerEntryOperation)" />
      <MemberSignature Language="F#" Value="abstract member PostLedgerEntryAsync : Azure.Core.RequestContent * string * bool * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Security.ConfidentialLedger.PostLedgerEntryOperation&gt;&#xA;override this.PostLedgerEntryAsync : Azure.Core.RequestContent * string * bool * Azure.RequestContext -&gt; System.Threading.Tasks.Task&lt;Azure.Security.ConfidentialLedger.PostLedgerEntryOperation&gt;" Usage="confidentialLedgerClient.PostLedgerEntryAsync (content, subLedgerId, waitForCompletion, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Security.ConfidentialLedger</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Security.ConfidentialLedger.PostLedgerEntryOperation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Azure.Core.RequestContent" />
        <Parameter Name="subLedgerId" Type="System.String" />
        <Parameter Name="waitForCompletion" Type="System.Boolean" />
        <Parameter Name="context" Type="Azure.RequestContext" />
      </Parameters>
      <Docs>
        <param name="content"> The content to send as the body of the request. </param>
        <param name="subLedgerId"> The sub-ledger id. </param>
        <param name="waitForCompletion"> If <c>true</c>, the <see cref="T:Azure.Security.ConfidentialLedger.PostLedgerEntryOperation" />
            will automatically poll for status until the ledger entry is committed before it is returned.
            If <c>false</c>,<see cref="M:Azure.Operation.WaitForCompletionResponseAsync(System.Threading.CancellationToken)" />
            must be called to ensure the operation has completed.</param>
        <param name="context"> The request context. </param>
        <summary> Posts a new entry to the ledger. A sub-ledger id may optionally be specified. </summary>
        <returns>To be added.</returns>
        <remarks>
            Schema for <c>Request Body</c>:
            <list type="table"><listheader><term>Name</term><term>Type</term><term>Required</term><term>Description</term></listheader><item><term>contents</term><term>string</term><term>Yes</term><term> Contents of the ledger entry. </term></item><item><term>subLedgerId</term><term>string</term><term /><term> Identifier for sub-ledgers. </term></item><item><term>transactionId</term><term>string</term><term /><term> A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read. </term></item></list></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
