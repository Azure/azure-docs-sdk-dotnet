### YamlMime:NetMember
type: property
members:
- returnsWithMoniker:
    type:
    - value: <xref href="System.String?alt=System.String&text=String" data-throw-if-not-resolved="True"/>
    description: The token for use with session consistency.
  type: property
  uid: Azure.Cosmos.ItemRequestOptions.SessionToken
  commentId: P:Azure.Cosmos.ItemRequestOptions.SessionToken
  name: SessionToken
  fullName: Azure.Cosmos.ItemRequestOptions.SessionToken
  nameWithType: ItemRequestOptions.SessionToken
  syntaxWithMoniker:
  - lang: csharp
    values:
    - value: public string SessionToken { get; set; }
  - lang: fsharp
    values:
    - value: 'member this.SessionToken : string with get, set'
  - lang: vb
    values:
    - value: Public Property SessionToken As String
  monikers:
  - azure-dotnet-preview
  summary: Gets or sets the token for use with session consistency in the Azure Cosmos DB service.
  remarks: <p>One of the <xref data-throw-if-not-resolved="true" uid="Azure.Cosmos.ItemRequestOptions.ConsistencyLevel"></xref> for Azure Cosmos DB is Session. In fact, this is the default level applied to accounts.</p><p>When working with Session consistency, each new write request to Azure Cosmos DB is assigned a new SessionToken. The DocumentClient will use this token internally with each read/query request to ensure that the set consistency level is maintained.</p><p>In some scenarios you need to manage this Session yourself; Consider a web application with multiple nodes, each node will have its own instance of <xref data-throw-if-not-resolved="true" uid="Azure.Cosmos.CosmosClient"></xref> If you wanted these nodes to participate in the same session (to be able read your own writes consistently across web tiers) you would have to send the SessionToken from the response of the write action on one node to the client tier, using a cookie or some other mechanism, and have that token flow back to the web tier for subsequent reads. If you are using a round-robin load balancer which does not maintain session affinity between requests, such as the Azure Load Balancer, the read could potentially land on a different node to the write request, where the session was created.</p><p>If you do not flow the Azure Cosmos DB SessionToken across as described above you could end up with inconsistent read results for a period of time. </p><p></p>
  metadata: {}
uid: Azure.Cosmos.ItemRequestOptions.SessionToken*
commentId: Overload:Azure.Cosmos.ItemRequestOptions.SessionToken
namespace: Azure.Cosmos
name: SessionToken
fullName: Azure.Cosmos.ItemRequestOptions.SessionToken
nameWithType: ItemRequestOptions.SessionToken
assembliesWithMoniker:
- value: Azure.Cosmos.dll
packagesWithMoniker:
- value: Azure.Cosmos v4.0.0-preview3
devLangs:
- csharp
- vb
- fsharp
monikers:
- azure-dotnet-preview
metadata:
  api_name:
  - Azure.Cosmos.ItemRequestOptions.SessionToken
  - Azure.Cosmos.ItemRequestOptions.get_SessionToken
  - Azure.Cosmos.ItemRequestOptions.set_SessionToken
  api_location:
  - Azure.Cosmos.dll
  topic_type:
  - apiref
  api_type:
  - Assembly
  f1_keywords:
  - Azure.Cosmos.ItemRequestOptions.SessionToken
  - Azure::Cosmos::ItemRequestOptions::SessionToken
  - SessionToken
  - ItemRequestOptions.SessionToken
  - ItemRequestOptions::SessionToken
  helpviewer_keywords:
  - ItemRequestOptions.SessionToken property [.NET]
  - SessionToken property [.NET], class ItemRequestOptions
  monikers:
  - azure-dotnet-preview
