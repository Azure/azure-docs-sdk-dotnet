### YamlMime:NetMember
type: method
members:
- returnsWithMoniker:
    type:
    - value: <xref href="System.Threading.Tasks.Task`1?alt=System.Threading.Tasks.Task&text=Task" data-throw-if-not-resolved="True"/>&lt;<xref href="Azure.Operation`1?alt=Azure.Operation&text=Operation" data-throw-if-not-resolved="True"/>&lt;<xref href="System.BinaryData?alt=System.BinaryData&text=BinaryData" data-throw-if-not-resolved="True"/>&gt;&gt;
    description: The <xref data-throw-if-not-resolved="true" uid="Azure.Operation`1"></xref> from the service that will contain a <xref data-throw-if-not-resolved="true" uid="System.BinaryData"></xref> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below.
  parameters:
  - namesWithMoniker:
    - value: waitUntil
    description: <xref data-throw-if-not-resolved="true" uid="Azure.WaitUntil.Completed"></xref> if the method should wait to return until the long-running operation has completed on the service; <xref data-throw-if-not-resolved="true" uid="Azure.WaitUntil.Started"></xref> if it should return after starting the operation. For more information on long-running operations, please see <a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</a>.
    type: <xref href="Azure.WaitUntil?alt=Azure.WaitUntil&text=WaitUntil" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: content
    description: The content to send as the body of the request. Details of the request body schema are in the Remarks section below.
    type: <xref href="Azure.Core.RequestContent?alt=Azure.Core.RequestContent&text=RequestContent" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: repeatabilityRequestId
    description: An opaque, globally-unique, client-generated string identifier for the request.
    type: <xref href="System.String?alt=System.String&text=String" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: repeatabilityFirstSent
    description: Specifies the date and time at which the request was first created.
    type: <xref href="System.Nullable`1?alt=System.Nullable&text=Nullable" data-throw-if-not-resolved="True"/>&lt;<xref href="System.DateTimeOffset?alt=System.DateTimeOffset&text=DateTimeOffset" data-throw-if-not-resolved="True"/>&gt;
  - namesWithMoniker:
    - value: context
    description: The request context, which can override default behaviors of the client pipeline on a per-call basis.
    type: <xref href="Azure.RequestContext?alt=Azure.RequestContext&text=RequestContext" data-throw-if-not-resolved="True"/>
  exceptions:
  - description: <code data-dev-comment-type="paramref">content</code> is null.
    type: <xref href="System.ArgumentNullException" data-throw-if-not-resolved="True"/>
  - description: Service returned a non-success status code.
    type: <xref href="Azure.RequestFailedException?alt=Azure.RequestFailedException&text=RequestFailedException" data-throw-if-not-resolved="True"/>
  type: method
  uid: Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync(Azure.WaitUntil,Azure.Core.RequestContent,System.String,System.Nullable{System.DateTimeOffset},Azure.RequestContext)
  commentId: M:Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync(Azure.WaitUntil,Azure.Core.RequestContent,System.String,System.Nullable{System.DateTimeOffset},Azure.RequestContext)
  name: MatchTrialsAsync(WaitUntil, RequestContent, String, Nullable<DateTimeOffset>, RequestContext)
  fullName: Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync(WaitUntil, RequestContent, String, Nullable<DateTimeOffset>, RequestContext)
  nameWithType: ClinicalMatchingClient.MatchTrialsAsync(WaitUntil, RequestContent, String, Nullable<DateTimeOffset>, RequestContext)
  syntaxWithMoniker:
  - lang: csharp
    values:
    - value: public virtual System.Threading.Tasks.Task<Azure.Operation<BinaryData>> MatchTrialsAsync (Azure.WaitUntil waitUntil, Azure.Core.RequestContent content, string repeatabilityRequestId = default, DateTimeOffset? repeatabilityFirstSent = default, Azure.RequestContext context = default);
  - lang: fsharp
    values:
    - value: >-
        abstract member MatchTrialsAsync : Azure.WaitUntil * Azure.Core.RequestContent * string * Nullable<DateTimeOffset> * Azure.RequestContext -> System.Threading.Tasks.Task<Azure.Operation<BinaryData>>

        override this.MatchTrialsAsync : Azure.WaitUntil * Azure.Core.RequestContent * string * Nullable<DateTimeOffset> * Azure.RequestContext -> System.Threading.Tasks.Task<Azure.Operation<BinaryData>>
  - lang: vb
    values:
    - value: Public Overridable Function MatchTrialsAsync (waitUntil As WaitUntil, content As RequestContent, Optional repeatabilityRequestId As String = Nothing, Optional repeatabilityFirstSent As Nullable(Of DateTimeOffset) = Nothing, Optional context As RequestContext = Nothing) As Task(Of Operation(Of BinaryData))
  monikers:
  - azure-dotnet-preview
  summary: Create Trial Matcher job.
  remarks: >-
    <p>Creates a Trial Matcher job with the given request body.</p><p>Below is the JSON schema for the request and response payloads.</p><p>Request Body:</p><p>Schema for <code data-dev-comment-type="c">TrialMatcherData</code>: 


    ```

    {
      patients: [
        {
          id: string, # Required. A given identifier for the patient. Has to be unique across all patients in a single request.
          info: {
            sex: "female" | "male" | "unspecified", # Optional. The patient's sex.
            birthDate: string (date), # Optional. The patient's date of birth.
            clinicalInfo: [ClinicalCodedElement], # Optional. Known clinical information for the patient, structured.
          }, # Optional. Patient structured information, including demographics and known structured clinical information.
          data: [PatientDocument], # Optional. Patient unstructured clinical data, given as documents.
        }
      ], # Required. The list of patients, including their clinical information and data.
      configuration: {
        verbose: boolean, # Optional. An indication whether the model should produce verbose output.
        includeEvidence: boolean, # Optional. An indication whether the model's output should include evidence for the inferences.
        clinicalTrials: {
          customTrials: [ClinicalTrialDetails], # Optional. A list of clinical trials.
          registryFilters: [ClinicalTrialRegistryFilter], # Optional. A list of filters, each one creating a selection of trials from a given
    clinical trial registry.
        }, # Required. The clinical trials that the patient(s) should be matched to. &lt;br /&gt;The trial
    selection can be given as a list of custom clinical trials and/or a list of

    filters to known clinical trial registries. In case both are given, the

    resulting trial set is a union of the two sets.
      }, # Optional. Configuration affecting the Trial Matcher model's inference.
    }

    ```

    </p><p>Response Body:</p><p>Schema for <code data-dev-comment-type="c">TrialMatcherResult</code>: 


    ```

    {
      jobId: string, # Required. A processing job identifier.
      createdDateTime: string (date & time), # Required. The date and time when the processing job was created.
      expirationDateTime: string (date & time), # Required. The date and time when the processing job is set to expire.
      lastUpdateDateTime: string (date & time), # Required. The date and time when the processing job was last updated.
      status: "notStarted" | "running" | "succeeded" | "failed" | "partiallyCompleted", # Required. The status of the processing job.
      errors: [
        {
          code: string, # Required. One of a server-defined set of error codes.
          message: string, # Required. A human-readable representation of the error.
          target: string, # Optional. The target of the error.
          details: [Error], # Required. An array of details about specific errors that led to this reported error.
          innererror: {
            code: string, # Required. One of a server-defined set of error codes.
            innererror: InnerError, # Optional. Inner error.
          }, # Optional. An object containing more specific information than the current object about the error.
        }
      ], # Optional. An array of errors, if any errors occurred during the processing job.
      results: {
        patients: [TrialMatcherPatientResult], # Required. Results for the patients given in the request.
        modelVersion: string, # Required. The version of the model used for inference, expressed as the model date.
        knowledgeGraphLastUpdateDate: string (date), # Optional. The date when the clinical trials knowledge graph was last updated.
      }, # Optional. The inference results for the Trial Matcher request.
    }

    ```

    </p>
  examples: >-
    This sample shows how to call MatchTrialsAsync with required parameters and request content, and how to parse the result.


    ```

    var credential = new AzureKeyCredential("<key>");

    var endpoint = new Uri("<https://my-service.azure.com>");

    var client = new ClinicalMatchingClient(endpoint, credential);


    var data = new {
        patients = new[] {
            new {
                id = "<id>",
            }
        },
    };


    var operation = await client.MatchTrialsAsync(WaitUntil.Completed, RequestContent.Create(data));


    BinaryData data = operation.Value;

    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;

    Console.WriteLine(result.GetProperty("jobId").ToString());

    Console.WriteLine(result.GetProperty("createdDateTime").ToString());

    Console.WriteLine(result.GetProperty("expirationDateTime").ToString());

    Console.WriteLine(result.GetProperty("lastUpdateDateTime").ToString());

    Console.WriteLine(result.GetProperty("status").ToString());

    ```

    This sample shows how to call MatchTrialsAsync with all parameters and request content, and how to parse the result.


    ```

    var credential = new AzureKeyCredential("<key>");

    var endpoint = new Uri("<https://my-service.azure.com>");

    var client = new ClinicalMatchingClient(endpoint, credential);


    var data = new {
        patients = new[] {
            new {
                id = "<id>",
                info = new {
                    sex = "female",
                    birthDate = "2022-05-10",
                    clinicalInfo = new[] {
                        new {
                            system = "<system>",
                            code = "<code>",
                            name = "<name>",
                            value = "<value>",
                        }
                    },
                },
                data = new[] {
                    new {
                        type = "note",
                        clinicalType = "consultation",
                        id = "<id>",
                        language = "<language>",
                        createdDateTime = "2022-05-10T14:57:31.2311892-04:00",
                        content = new {
                            sourceType = "inline",
                            value = "<value>",
                        },
                    }
                },
            }
        },
        configuration = new {
            verbose = true,
            includeEvidence = true,
            clinicalTrials = new {
                customTrials = new[] {
                    new {
                        id = "<id>",
                        eligibilityCriteriaText = "<eligibilityCriteriaText>",
                        demographics = new {
                            acceptedSex = "all",
                            acceptedAgeRange = new {
                                minimumAge = new {
                                    unit = "years",
                                    value = 123.45f,
                                },
                                maximumAge = new {
                                    unit = "years",
                                    value = 123.45f,
                                },
                            },
                        },
                        metadata = new {
                            phases = new[] {
                                "notApplicable"
                            },
                            studyType = "interventional",
                            recruitmentStatus = "unknownStatus",
                            conditions = new[] {
                                "<String>"
                            },
                            sponsors = new[] {
                                "<String>"
                            },
                            contacts = new[] {
                                new {
                                    name = "<name>",
                                    email = "<email>",
                                    phone = "<phone>",
                                }
                            },
                            facilities = new[] {
                                new {
                                    name = "<name>",
                                    city = "<city>",
                                    state = "<state>",
                                    countryOrRegion = "<countryOrRegion>",
                                }
                            },
                        },
                    }
                },
                registryFilters = new[] {
                    new {
                        conditions = new[] {
                            "<String>"
                        },
                        studyTypes = new[] {
                            "interventional"
                        },
                        recruitmentStatuses = new[] {
                            "unknownStatus"
                        },
                        sponsors = new[] {
                            "<String>"
                        },
                        phases = new[] {
                            "notApplicable"
                        },
                        purposes = new[] {
                            "notApplicable"
                        },
                        ids = new[] {
                            "<String>"
                        },
                        sources = new[] {
                            "custom"
                        },
                        facilityNames = new[] {
                            "<String>"
                        },
                        facilityLocations = new[] {
                            new {
                                city = "<city>",
                                state = "<state>",
                                countryOrRegion = "<countryOrRegion>",
                            }
                        },
                        facilityAreas = new[] {
                            new {
                                type = "Feature",
                                geometry = new {
                                    type = "Point",
                                    coordinates = new[] {
                                        123.45f
                                    },
                                },
                                properties = new {
                                    subType = "Circle",
                                    radius = 123.45d,
                                },
                            }
                        },
                    }
                },
            },
        },
    };


    var operation = await client.MatchTrialsAsync(WaitUntil.Completed, RequestContent.Create(data), "<repeatabilityRequestId>", DateTimeOffset.UtcNow);


    BinaryData data = operation.Value;

    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;

    Console.WriteLine(result.GetProperty("jobId").ToString());

    Console.WriteLine(result.GetProperty("createdDateTime").ToString());

    Console.WriteLine(result.GetProperty("expirationDateTime").ToString());

    Console.WriteLine(result.GetProperty("lastUpdateDateTime").ToString());

    Console.WriteLine(result.GetProperty("status").ToString());

    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());

    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());

    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());

    Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("id").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("type").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("value").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("description").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("confidenceScore").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("eligibilityCriteriaEvidence").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("patientDataEvidence").GetProperty("id").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("patientDataEvidence").GetProperty("text").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("patientDataEvidence").GetProperty("offset").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("patientDataEvidence").GetProperty("length").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("patientInfoEvidence").GetProperty("system").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("patientInfoEvidence").GetProperty("code").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("patientInfoEvidence").GetProperty("name").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("patientInfoEvidence").GetProperty("value").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("evidence")[0].GetProperty("importance").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("id").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("source").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("phases")[0].ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("studyType").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("recruitmentStatus").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("conditions")[0].ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("sponsors")[0].ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("contacts")[0].GetProperty("name").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("contacts")[0].GetProperty("email").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("contacts")[0].GetProperty("phone").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("facilities")[0].GetProperty("name").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("facilities")[0].GetProperty("city").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("facilities")[0].GetProperty("state").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("inferences")[0].GetProperty("metadata").GetProperty("facilities")[0].GetProperty("countryOrRegion").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("neededClinicalInfo")[0].GetProperty("system").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("neededClinicalInfo")[0].GetProperty("code").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("neededClinicalInfo")[0].GetProperty("name").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("neededClinicalInfo")[0].GetProperty("value").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("neededClinicalInfo")[0].GetProperty("semanticType").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("patients")[0].GetProperty("neededClinicalInfo")[0].GetProperty("category").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("modelVersion").ToString());

    Console.WriteLine(result.GetProperty("results").GetProperty("knowledgeGraphLastUpdateDate").ToString());

    ```
  metadata: {}
- returnsWithMoniker:
    type:
    - value: <xref href="System.Threading.Tasks.Task`1?alt=System.Threading.Tasks.Task&text=Task" data-throw-if-not-resolved="True"/>&lt;<xref href="Azure.Operation`1?alt=Azure.Operation&text=Operation" data-throw-if-not-resolved="True"/>&lt;<xref href="Azure.Health.Insights.ClinicalMatching.TrialMatcherResult?alt=Azure.Health.Insights.ClinicalMatching.TrialMatcherResult&text=TrialMatcherResult" data-throw-if-not-resolved="True"/>&gt;&gt;
  parameters:
  - namesWithMoniker:
    - value: waitUntil
    description: <xref data-throw-if-not-resolved="true" uid="Azure.WaitUntil.Completed"></xref> if the method should wait to return until the long-running operation has completed on the service; <xref data-throw-if-not-resolved="true" uid="Azure.WaitUntil.Started"></xref> if it should return after starting the operation. For more information on long-running operations, please see <a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</a>.
    type: <xref href="Azure.WaitUntil?alt=Azure.WaitUntil&text=WaitUntil" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: trialMatcherData
    description: The body of the Trial Matcher request.
    type: <xref href="Azure.Health.Insights.ClinicalMatching.TrialMatcherData?alt=Azure.Health.Insights.ClinicalMatching.TrialMatcherData&text=TrialMatcherData" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: repeatabilityRequestId
    description: An opaque, globally-unique, client-generated string identifier for the request.
    type: <xref href="System.String?alt=System.String&text=String" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: repeatabilityFirstSent
    description: Specifies the date and time at which the request was first created.
    type: <xref href="System.Nullable`1?alt=System.Nullable&text=Nullable" data-throw-if-not-resolved="True"/>&lt;<xref href="System.DateTimeOffset?alt=System.DateTimeOffset&text=DateTimeOffset" data-throw-if-not-resolved="True"/>&gt;
  - namesWithMoniker:
    - value: cancellationToken
    description: The cancellation token to use.
    type: <xref href="System.Threading.CancellationToken?alt=System.Threading.CancellationToken&text=CancellationToken" data-throw-if-not-resolved="True"/>
  exceptions:
  - description: <code data-dev-comment-type="paramref">trialMatcherData</code> is null.
    type: <xref href="System.ArgumentNullException" data-throw-if-not-resolved="True"/>
  type: method
  uid: Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync(Azure.WaitUntil,Azure.Health.Insights.ClinicalMatching.TrialMatcherData,System.String,System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)
  commentId: M:Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync(Azure.WaitUntil,Azure.Health.Insights.ClinicalMatching.TrialMatcherData,System.String,System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)
  name: MatchTrialsAsync(WaitUntil, TrialMatcherData, String, Nullable<DateTimeOffset>, CancellationToken)
  fullName: Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync(WaitUntil, TrialMatcherData, String, Nullable<DateTimeOffset>, CancellationToken)
  nameWithType: ClinicalMatchingClient.MatchTrialsAsync(WaitUntil, TrialMatcherData, String, Nullable<DateTimeOffset>, CancellationToken)
  syntaxWithMoniker:
  - lang: csharp
    values:
    - value: public virtual System.Threading.Tasks.Task<Azure.Operation<Azure.Health.Insights.ClinicalMatching.TrialMatcherResult>> MatchTrialsAsync (Azure.WaitUntil waitUntil, Azure.Health.Insights.ClinicalMatching.TrialMatcherData trialMatcherData, string repeatabilityRequestId = default, DateTimeOffset? repeatabilityFirstSent = default, System.Threading.CancellationToken cancellationToken = default);
  - lang: fsharp
    values:
    - value: >-
        abstract member MatchTrialsAsync : Azure.WaitUntil * Azure.Health.Insights.ClinicalMatching.TrialMatcherData * string * Nullable<DateTimeOffset> * System.Threading.CancellationToken -> System.Threading.Tasks.Task<Azure.Operation<Azure.Health.Insights.ClinicalMatching.TrialMatcherResult>>

        override this.MatchTrialsAsync : Azure.WaitUntil * Azure.Health.Insights.ClinicalMatching.TrialMatcherData * string * Nullable<DateTimeOffset> * System.Threading.CancellationToken -> System.Threading.Tasks.Task<Azure.Operation<Azure.Health.Insights.ClinicalMatching.TrialMatcherResult>>
  - lang: vb
    values:
    - value: Public Overridable Function MatchTrialsAsync (waitUntil As WaitUntil, trialMatcherData As TrialMatcherData, Optional repeatabilityRequestId As String = Nothing, Optional repeatabilityFirstSent As Nullable(Of DateTimeOffset) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Operation(Of TrialMatcherResult))
  monikers:
  - azure-dotnet-preview
  summary: Create Trial Matcher job.
  remarks: Creates a Trial Matcher job with the given request body.
  metadata: {}
uid: Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync*
commentId: Overload:Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync
namespace: Azure.Health.Insights.ClinicalMatching
name: MatchTrialsAsync
fullName: Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync
nameWithType: ClinicalMatchingClient.MatchTrialsAsync
assembliesWithMoniker:
- value: Azure.Health.Insights.ClinicalMatching.dll
packagesWithMoniker:
- value: Azure.Health.Insights.ClinicalMatching v1.0.0-beta.1
devLangs:
- csharp
- vb
- fsharp
monikers:
- azure-dotnet-preview
metadata:
  api_name:
  - Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync
  api_location:
  - Azure.Health.Insights.ClinicalMatching.dll
  topic_type:
  - apiref
  api_type:
  - Assembly
  f1_keywords:
  - Azure.Health.Insights.ClinicalMatching.ClinicalMatchingClient.MatchTrialsAsync
  - Azure::Health::Insights::ClinicalMatching::ClinicalMatchingClient::MatchTrialsAsync
  - MatchTrialsAsync
  - ClinicalMatchingClient.MatchTrialsAsync
  - ClinicalMatchingClient::MatchTrialsAsync
  helpviewer_keywords:
  - ClinicalMatchingClient.MatchTrialsAsync method [.NET]
  - MatchTrialsAsync method [.NET], class ClinicalMatchingClient
  - ClinicalMatchingClient.MatchTrialsAsync(WaitUntil, RequestContent, String, Nullable<DateTimeOffset>, RequestContext) method [.NET]
  - MatchTrialsAsync(WaitUntil, RequestContent, String, Nullable<DateTimeOffset>, RequestContext) method [.NET], class ClinicalMatchingClient
  - ClinicalMatchingClient.MatchTrialsAsync(WaitUntil, TrialMatcherData, String, Nullable<DateTimeOffset>, CancellationToken) method [.NET]
  - MatchTrialsAsync(WaitUntil, TrialMatcherData, String, Nullable<DateTimeOffset>, CancellationToken) method [.NET], class ClinicalMatchingClient
  monikers:
  - azure-dotnet-preview
